"use strict";
var agent = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __defProps = Object.defineProperties;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
  var __restKey = (key) => typeof key === "symbol" ? key : key + "";
  var __objRest = (source, exclude) => {
    var target = {};
    for (var prop in source)
      if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
        target[prop] = source[prop];
    if (source != null && __getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(source)) {
        if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
          target[prop] = source[prop];
      }
    return target;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to2, from2, except, desc) => {
    if (from2 && typeof from2 === "object" || typeof from2 === "function") {
      for (let key of __getOwnPropNames(from2))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // node_modules/scheduler/cjs/scheduler.production.js
  var require_scheduler_production = __commonJS({
    "node_modules/scheduler/cjs/scheduler.production.js"(exports) {
      "use strict";
      function push(heap, node2) {
        var index = heap.length;
        heap.push(node2);
        a: for (; 0 < index; ) {
          var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
          if (0 < compare(parent, node2))
            heap[parentIndex] = node2, heap[index] = parent, index = parentIndex;
          else break a;
        }
      }
      function peek2(heap) {
        return 0 === heap.length ? null : heap[0];
      }
      function pop(heap) {
        if (0 === heap.length) return null;
        var first = heap[0], last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          a: for (var index = 0, length2 = heap.length, halfLength = length2 >>> 1; index < halfLength; ) {
            var leftIndex = 2 * (index + 1) - 1, left2 = heap[leftIndex], rightIndex = leftIndex + 1, right2 = heap[rightIndex];
            if (0 > compare(left2, last))
              rightIndex < length2 && 0 > compare(right2, left2) ? (heap[index] = right2, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left2, heap[leftIndex] = last, index = leftIndex);
            else if (rightIndex < length2 && 0 > compare(right2, last))
              heap[index] = right2, heap[rightIndex] = last, index = rightIndex;
            else break a;
          }
        }
        return first;
      }
      function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return 0 !== diff ? diff : a.id - b.id;
      }
      exports.unstable_now = void 0;
      if ("object" === typeof performance && "function" === typeof performance.now) {
        localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        localDate2 = Date, initialTime = localDate2.now();
        exports.unstable_now = function() {
          return localDate2.now() - initialTime;
        };
      }
      var localPerformance;
      var localDate2;
      var initialTime;
      var taskQueue = [];
      var timerQueue = [];
      var taskIdCounter = 1;
      var currentTask = null;
      var currentPriorityLevel = 3;
      var isPerformingWork = false;
      var isHostCallbackScheduled = false;
      var isHostTimeoutScheduled = false;
      var needsPaint = false;
      var localSetTimeout = "function" === typeof setTimeout ? setTimeout : null;
      var localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null;
      var localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null;
      function advanceTimers(currentTime) {
        for (var timer = peek2(timerQueue); null !== timer; ) {
          if (null === timer.callback) pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else break;
          timer = peek2(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled)
          if (null !== peek2(taskQueue))
            isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
          else {
            var firstTimer = peek2(timerQueue);
            null !== firstTimer && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      var isMessageLoopRunning = false;
      var taskTimeoutID = -1;
      var frameInterval = 5;
      var startTime = -1;
      function shouldYieldToHost() {
        return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
      }
      function performWorkUntilDeadline() {
        needsPaint = false;
        if (isMessageLoopRunning) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasMoreWork = true;
          try {
            a: {
              isHostCallbackScheduled = false;
              isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
              isPerformingWork = true;
              var previousPriorityLevel = currentPriorityLevel;
              try {
                b: {
                  advanceTimers(currentTime);
                  for (currentTask = peek2(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
                    var callback = currentTask.callback;
                    if ("function" === typeof callback) {
                      currentTask.callback = null;
                      currentPriorityLevel = currentTask.priorityLevel;
                      var continuationCallback = callback(
                        currentTask.expirationTime <= currentTime
                      );
                      currentTime = exports.unstable_now();
                      if ("function" === typeof continuationCallback) {
                        currentTask.callback = continuationCallback;
                        advanceTimers(currentTime);
                        hasMoreWork = true;
                        break b;
                      }
                      currentTask === peek2(taskQueue) && pop(taskQueue);
                      advanceTimers(currentTime);
                    } else pop(taskQueue);
                    currentTask = peek2(taskQueue);
                  }
                  if (null !== currentTask) hasMoreWork = true;
                  else {
                    var firstTimer = peek2(timerQueue);
                    null !== firstTimer && requestHostTimeout(
                      handleTimeout,
                      firstTimer.startTime - currentTime
                    );
                    hasMoreWork = false;
                  }
                }
                break a;
              } finally {
                currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
              }
              hasMoreWork = void 0;
            }
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
          }
        }
      }
      var schedulePerformWorkUntilDeadline;
      if ("function" === typeof localSetImmediate)
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if ("undefined" !== typeof MessageChannel) {
        channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      var channel;
      var port;
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      exports.unstable_IdlePriority = 5;
      exports.unstable_ImmediatePriority = 1;
      exports.unstable_LowPriority = 4;
      exports.unstable_NormalPriority = 3;
      exports.unstable_Profiling = null;
      exports.unstable_UserBlockingPriority = 2;
      exports.unstable_cancelCallback = function(task) {
        task.callback = null;
      };
      exports.unstable_forceFrameRate = function(fps) {
        0 > fps || 125 < fps ? console.error(
          "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
        ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
      };
      exports.unstable_getCurrentPriorityLevel = function() {
        return currentPriorityLevel;
      };
      exports.unstable_next = function(eventHandler) {
        switch (currentPriorityLevel) {
          case 1:
          case 2:
          case 3:
            var priorityLevel = 3;
            break;
          default:
            priorityLevel = currentPriorityLevel;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_requestPaint = function() {
        needsPaint = true;
      };
      exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            priorityLevel = 3;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      };
      exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
        switch (priorityLevel) {
          case 1:
            var timeout2 = -1;
            break;
          case 2:
            timeout2 = 250;
            break;
          case 5:
            timeout2 = 1073741823;
            break;
          case 4:
            timeout2 = 1e4;
            break;
          default:
            timeout2 = 5e3;
        }
        timeout2 = options + timeout2;
        priorityLevel = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: options,
          expirationTime: timeout2,
          sortIndex: -1
        };
        options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek2(taskQueue) && priorityLevel === peek2(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout2, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
        return priorityLevel;
      };
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = function(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      };
    }
  });

  // node_modules/scheduler/index.js
  var require_scheduler = __commonJS({
    "node_modules/scheduler/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_scheduler_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react/cjs/react.production.js
  var require_react_production = __commonJS({
    "node_modules/react/cjs/react.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function() {
        },
        enqueueReplaceState: function() {
        },
        enqueueSetState: function() {
        }
      };
      var assign3 = Object.assign;
      var emptyObject = {};
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      function ComponentDummy() {
      }
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
      pureComponentPrototype.constructor = PureComponent;
      assign3(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      var isArrayImpl = Array.isArray;
      var ReactSharedInternals = { H: null, A: null, T: null, S: null, V: null };
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function ReactElement(type, key, self2, source, owner, props) {
        self2 = props.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== self2 ? self2 : null,
          props
        };
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        return ReactElement(
          oldElement.type,
          newKey,
          void 0,
          void 0,
          void 0,
          oldElement.props
        );
      }
      function isValidElement8(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match2) {
          return escaperLookup[match2];
        });
      }
      var userProvidedKeyEscapeRegex = /\/+/g;
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
      }
      function noop$1() {
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback)
          return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
            return c;
          })) : null != callback && (isValidElement8(callback) && (callback = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + invokeCallback
          )), array.push(callback)), 1;
        invokeCallback = 0;
        var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i = 0; i < children.length; i++)
            nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i = getIteratorFn(children), "function" === typeof i)
          for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ctor = payload._result;
          ctor = ctor();
          ctor.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 1, payload._result = moduleObject;
            },
            function(error) {
              if (0 === payload._status || -1 === payload._status)
                payload._status = 2, payload._result = error;
            }
          );
          -1 === payload._status && (payload._status = 0, payload._result = ctor);
        }
        if (1 === payload._status) return payload._result.default;
        throw payload._result;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      function noop6() {
      }
      exports.Children = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n = 0;
          mapChildren(children, function() {
            n++;
          });
          return n;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement8(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = {
        __proto__: null,
        c: function(size) {
          return ReactSharedInternals.H.useMemoCache(size);
        }
      };
      exports.cache = function(fn2) {
        return function() {
          return fn2.apply(null, arguments);
        };
      };
      exports.cloneElement = function(element, config2, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign3({}, element.props), key = element.key, owner = void 0;
        if (null != config2)
          for (propName in void 0 !== config2.ref && (owner = void 0), void 0 !== config2.key && (key = "" + config2.key), config2)
            !hasOwnProperty.call(config2, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config2.ref || (props[propName] = config2[propName]);
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          for (var childArray = Array(propName), i = 0; i < propName; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        return ReactElement(element.type, key, void 0, void 0, owner, props);
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        return defaultValue;
      };
      exports.createElement = function(type, config2, children) {
        var propName, props = {}, key = null;
        if (null != config2)
          for (propName in void 0 !== config2.key && (key = "" + config2.key), config2)
            hasOwnProperty.call(config2, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config2[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) props.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
            childArray[i] = arguments[i + 2];
          props.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === props[propName] && (props[propName] = childrenLength[propName]);
        return ReactElement(type, key, void 0, void 0, null, props);
      };
      exports.createRef = function() {
        return { current: null };
      };
      exports.forwardRef = function(render) {
        return { $$typeof: REACT_FORWARD_REF_TYPE, render };
      };
      exports.isValidElement = isValidElement8;
      exports.lazy = function(ctor) {
        return {
          $$typeof: REACT_LAZY_TYPE,
          _payload: { _status: -1, _result: ctor },
          _init: lazyInitializer
        };
      };
      exports.memo = function(type, compare) {
        return {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop6, reportGlobalError);
        } catch (error) {
          reportGlobalError(error);
        } finally {
          ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return ReactSharedInternals.H.useCacheRefresh();
      };
      exports.use = function(usable) {
        return ReactSharedInternals.H.use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useActionState(action, initialState, permalink);
      };
      exports.useCallback = function(callback, deps) {
        return ReactSharedInternals.H.useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        return ReactSharedInternals.H.useContext(Context);
      };
      exports.useDebugValue = function() {
      };
      exports.useDeferredValue = function(value, initialValue) {
        return ReactSharedInternals.H.useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, createDeps, update3) {
        var dispatcher = ReactSharedInternals.H;
        if ("function" === typeof update3)
          throw Error(
            "useEffect CRUD overload is not enabled in this build of React."
          );
        return dispatcher.useEffect(create, createDeps);
      };
      exports.useId = function() {
        return ReactSharedInternals.H.useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        return ReactSharedInternals.H.useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        return ReactSharedInternals.H.useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return ReactSharedInternals.H.useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init) {
        return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
      };
      exports.useRef = function(initialValue) {
        return ReactSharedInternals.H.useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return ReactSharedInternals.H.useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return ReactSharedInternals.H.useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return ReactSharedInternals.H.useTransition();
      };
      exports.version = "19.1.0";
    }
  });

  // node_modules/react/index.js
  var require_react = __commonJS({
    "node_modules/react/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom.production.js
  var require_react_dom_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom.production.js"(exports) {
      "use strict";
      var React141 = require_react();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function noop6() {
      }
      var Internals = {
        d: {
          f: noop6,
          r: function() {
            throw Error(formatProdErrorMessage(522));
          },
          D: noop6,
          C: noop6,
          L: noop6,
          m: noop6,
          X: noop6,
          S: noop6,
          M: noop6
        },
        p: 0,
        findDOMNode: null
      };
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var ReactSharedInternals = React141.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children, container2) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container2 || 1 !== container2.nodeType && 9 !== container2.nodeType && 11 !== container2.nodeType)
          throw Error(formatProdErrorMessage(299));
        return createPortal$1(children, container2, null, key);
      };
      exports.flushSync = function(fn2) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn2) return fn2();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f();
        }
      };
      exports.preconnect = function(href, options) {
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports.prefetchDNS = function(href) {
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options) {
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options) {
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as) {
              var crossOrigin = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              );
              Internals.d.M(href, {
                crossOrigin,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
            }
          } else null == options && Internals.d.M(href);
      };
      exports.preload = function(href, options) {
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin);
          Internals.d.L(href, as, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options) {
        if ("string" === typeof href)
          if (options) {
            var crossOrigin = getCrossOriginStringAs(options.as, options.crossOrigin);
            Internals.d.m(href, {
              as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
              crossOrigin,
              integrity: "string" === typeof options.integrity ? options.integrity : void 0
            });
          } else Internals.d.m(href);
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn2, a) {
        return fn2(a);
      };
      exports.useFormState = function(action, initialState, permalink) {
        return ReactSharedInternals.H.useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function() {
        return ReactSharedInternals.H.useHostTransitionStatus();
      };
      exports.version = "19.1.0";
    }
  });

  // node_modules/react-dom/index.js
  var require_react_dom = __commonJS({
    "node_modules/react-dom/index.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react-dom/cjs/react-dom-client.production.js
  var require_react_dom_client_production = __commonJS({
    "node_modules/react-dom/cjs/react-dom-client.production.js"(exports) {
      "use strict";
      var Scheduler = require_scheduler();
      var React141 = require_react();
      var ReactDOM3 = require_react_dom();
      function formatProdErrorMessage(code) {
        var url = "https://react.dev/errors/" + code;
        if (1 < arguments.length) {
          url += "?args[]=" + encodeURIComponent(arguments[1]);
          for (var i = 2; i < arguments.length; i++)
            url += "&args[]=" + encodeURIComponent(arguments[i]);
        }
        return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
      }
      function isValidContainer(node2) {
        return !(!node2 || 1 !== node2.nodeType && 9 !== node2.nodeType && 11 !== node2.nodeType);
      }
      function getNearestMountedFiber(fiber) {
        var node2 = fiber, nearestMounted = fiber;
        if (fiber.alternate) for (; node2.return; ) node2 = node2.return;
        else {
          fiber = node2;
          do
            node2 = fiber, 0 !== (node2.flags & 4098) && (nearestMounted = node2.return), fiber = node2.return;
          while (fiber);
        }
        return 3 === node2.tag ? nearestMounted : null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (13 === fiber.tag) {
          var suspenseState = fiber.memoizedState;
          null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
          if (null !== suspenseState) return suspenseState.dehydrated;
        }
        return null;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber)
          throw Error(formatProdErrorMessage(188));
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          alternate = getNearestMountedFiber(fiber);
          if (null === alternate) throw Error(formatProdErrorMessage(188));
          return alternate !== fiber ? null : fiber;
        }
        for (var a = fiber, b = alternate; ; ) {
          var parentA = a.return;
          if (null === parentA) break;
          var parentB = parentA.alternate;
          if (null === parentB) {
            b = parentA.return;
            if (null !== b) {
              a = b;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            for (parentB = parentA.child; parentB; ) {
              if (parentB === a) return assertIsMounted(parentA), fiber;
              if (parentB === b) return assertIsMounted(parentA), alternate;
              parentB = parentB.sibling;
            }
            throw Error(formatProdErrorMessage(188));
          }
          if (a.return !== b.return) a = parentA, b = parentB;
          else {
            for (var didFindChild = false, child$0 = parentA.child; child$0; ) {
              if (child$0 === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (child$0 === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              child$0 = child$0.sibling;
            }
            if (!didFindChild) {
              for (child$0 = parentB.child; child$0; ) {
                if (child$0 === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (child$0 === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                child$0 = child$0.sibling;
              }
              if (!didFindChild) throw Error(formatProdErrorMessage(189));
            }
          }
          if (a.alternate !== b) throw Error(formatProdErrorMessage(190));
        }
        if (3 !== a.tag) throw Error(formatProdErrorMessage(188));
        return a.stateNode.current === a ? fiber : alternate;
      }
      function findCurrentHostFiberImpl(node2) {
        var tag = node2.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node2;
        for (node2 = node2.child; null !== node2; ) {
          tag = findCurrentHostFiberImpl(node2);
          if (null !== tag) return tag;
          node2 = node2.sibling;
        }
        return null;
      }
      var assign3 = Object.assign;
      var REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      Symbol.for("react.scope");
      var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
      Symbol.for("react.legacy_hidden");
      Symbol.for("react.tracing_marker");
      var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
      Symbol.for("react.view_transition");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable) return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch (type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return (type.displayName || "Context") + ".Provider";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      var isArrayImpl = Array.isArray;
      var ReactSharedInternals = React141.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var ReactDOMSharedInternals = ReactDOM3.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      var sharedNotPendingObject = {
        pending: false,
        data: null,
        method: null,
        action: null
      };
      var valueStack = [];
      var index = -1;
      function createCursor(defaultValue) {
        return { current: defaultValue };
      }
      function pop(cursor2) {
        0 > index || (cursor2.current = valueStack[index], valueStack[index] = null, index--);
      }
      function push(cursor2, value) {
        index++;
        valueStack[index] = cursor2.current;
        cursor2.current = value;
      }
      var contextStackCursor = createCursor(null);
      var contextFiberStackCursor = createCursor(null);
      var rootInstanceStackCursor = createCursor(null);
      var hostTransitionProviderCursor = createCursor(null);
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance);
        push(contextFiberStackCursor, fiber);
        push(contextStackCursor, null);
        switch (nextRootInstance.nodeType) {
          case 9:
          case 11:
            fiber = (fiber = nextRootInstance.documentElement) ? (fiber = fiber.namespaceURI) ? getOwnHostContext(fiber) : 0 : 0;
            break;
          default:
            if (fiber = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
              nextRootInstance = getOwnHostContext(nextRootInstance), fiber = getChildHostContextProd(nextRootInstance, fiber);
            else
              switch (fiber) {
                case "svg":
                  fiber = 1;
                  break;
                case "math":
                  fiber = 2;
                  break;
                default:
                  fiber = 0;
              }
        }
        pop(contextStackCursor);
        push(contextStackCursor, fiber);
      }
      function popHostContainer() {
        pop(contextStackCursor);
        pop(contextFiberStackCursor);
        pop(rootInstanceStackCursor);
      }
      function pushHostContext(fiber) {
        null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);
        var context = contextStackCursor.current;
        var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);
        context !== JSCompiler_inline_result && (push(contextFiberStackCursor, fiber), push(contextStackCursor, JSCompiler_inline_result));
      }
      function popHostContext(fiber) {
        contextFiberStackCursor.current === fiber && (pop(contextStackCursor), pop(contextFiberStackCursor));
        hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor), HostTransitionContext._currentValue = sharedNotPendingObject);
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;
      var cancelCallback$1 = Scheduler.unstable_cancelCallback;
      var shouldYield = Scheduler.unstable_shouldYield;
      var requestPaint = Scheduler.unstable_requestPaint;
      var now = Scheduler.unstable_now;
      var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
      var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
      var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
      var NormalPriority$1 = Scheduler.unstable_NormalPriority;
      var LowPriority = Scheduler.unstable_LowPriority;
      var IdlePriority = Scheduler.unstable_IdlePriority;
      var log$1 = Scheduler.log;
      var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;
      var rendererID = null;
      var injectedHook = null;
      function setIsStrictModeForDevtools(newIsStrictMode) {
        "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
        if (injectedHook && "function" === typeof injectedHook.setStrictMode)
          try {
            injectedHook.setStrictMode(rendererID, newIsStrictMode);
          } catch (err) {
          }
      }
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log2 = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        x >>>= 0;
        return 0 === x ? 32 : 31 - (log2(x) / LN2 | 0) | 0;
      }
      var nextTransitionLane = 256;
      var nextRetryLane = 4194304;
      function getHighestPriorityLanes(lanes) {
        var pendingSyncLanes = lanes & 42;
        if (0 !== pendingSyncLanes) return pendingSyncLanes;
        switch (lanes & -lanes) {
          case 1:
            return 1;
          case 2:
            return 2;
          case 4:
            return 4;
          case 8:
            return 8;
          case 16:
            return 16;
          case 32:
            return 32;
          case 64:
            return 64;
          case 128:
            return 128;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return lanes & 4194048;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return lanes & 62914560;
          case 67108864:
            return 67108864;
          case 134217728:
            return 134217728;
          case 268435456:
            return 268435456;
          case 536870912:
            return 536870912;
          case 1073741824:
            return 0;
          default:
            return lanes;
        }
      }
      function getNextLanes(root3, wipLanes, rootHasPendingCommit) {
        var pendingLanes = root3.pendingLanes;
        if (0 === pendingLanes) return 0;
        var nextLanes = 0, suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes;
        root3 = root3.warmLanes;
        var nonIdlePendingLanes = pendingLanes & 134217727;
        0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root3, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
        return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
      }
      function checkIfRootIsPrerendering(root3, renderLanes2) {
        return 0 === (root3.pendingLanes & ~(root3.suspendedLanes & ~root3.pingedLanes) & renderLanes2);
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case 1:
          case 2:
          case 4:
          case 8:
          case 64:
            return currentTime + 250;
          case 16:
          case 32:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
            return currentTime + 5e3;
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            return -1;
          case 67108864:
          case 134217728:
          case 268435456:
          case 536870912:
          case 1073741824:
            return -1;
          default:
            return -1;
        }
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
        return lane;
      }
      function createLaneMap(initial) {
        for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
        return laneMap;
      }
      function markRootUpdated$1(root3, updateLane) {
        root3.pendingLanes |= updateLane;
        268435456 !== updateLane && (root3.suspendedLanes = 0, root3.pingedLanes = 0, root3.warmLanes = 0);
      }
      function markRootFinished(root3, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
        var previouslyPendingLanes = root3.pendingLanes;
        root3.pendingLanes = remainingLanes;
        root3.suspendedLanes = 0;
        root3.pingedLanes = 0;
        root3.warmLanes = 0;
        root3.expiredLanes &= remainingLanes;
        root3.entangledLanes &= remainingLanes;
        root3.errorRecoveryDisabledLanes &= remainingLanes;
        root3.shellSuspendCounter = 0;
        var entanglements = root3.entanglements, expirationTimes = root3.expirationTimes, hiddenUpdates = root3.hiddenUpdates;
        for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
          var index$5 = 31 - clz32(remainingLanes), lane = 1 << index$5;
          entanglements[index$5] = 0;
          expirationTimes[index$5] = -1;
          var hiddenUpdatesForLane = hiddenUpdates[index$5];
          if (null !== hiddenUpdatesForLane)
            for (hiddenUpdates[index$5] = null, index$5 = 0; index$5 < hiddenUpdatesForLane.length; index$5++) {
              var update3 = hiddenUpdatesForLane[index$5];
              null !== update3 && (update3.lane &= -536870913);
            }
          remainingLanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, 0);
        0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root3.tag && (root3.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
      }
      function markSpawnedDeferredLane(root3, spawnedLane, entangledLanes) {
        root3.pendingLanes |= spawnedLane;
        root3.suspendedLanes &= ~spawnedLane;
        var spawnedLaneIndex = 31 - clz32(spawnedLane);
        root3.entangledLanes |= spawnedLane;
        root3.entanglements[spawnedLaneIndex] = root3.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
      }
      function markRootEntangled(root3, entangledLanes) {
        var rootEntangledLanes = root3.entangledLanes |= entangledLanes;
        for (root3 = root3.entanglements; rootEntangledLanes; ) {
          var index$6 = 31 - clz32(rootEntangledLanes), lane = 1 << index$6;
          lane & entangledLanes | root3[index$6] & entangledLanes && (root3[index$6] |= entangledLanes);
          rootEntangledLanes &= ~lane;
        }
      }
      function getBumpedLaneForHydrationByLane(lane) {
        switch (lane) {
          case 2:
            lane = 1;
            break;
          case 8:
            lane = 4;
            break;
          case 32:
            lane = 16;
            break;
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
            lane = 128;
            break;
          case 268435456:
            lane = 134217728;
            break;
          default:
            lane = 0;
        }
        return lane;
      }
      function lanesToEventPriority(lanes) {
        lanes &= -lanes;
        return 2 < lanes ? 8 < lanes ? 0 !== (lanes & 134217727) ? 32 : 268435456 : 8 : 2;
      }
      function resolveUpdatePriority() {
        var updatePriority = ReactDOMSharedInternals.p;
        if (0 !== updatePriority) return updatePriority;
        updatePriority = window.event;
        return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);
      }
      function runWithPriority(priority2, fn2) {
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          return ReactDOMSharedInternals.p = priority2, fn2();
        } finally {
          ReactDOMSharedInternals.p = previousPriority;
        }
      }
      var randomKey = Math.random().toString(36).slice(2);
      var internalInstanceKey = "__reactFiber$" + randomKey;
      var internalPropsKey = "__reactProps$" + randomKey;
      var internalContainerInstanceKey = "__reactContainer$" + randomKey;
      var internalEventHandlersKey = "__reactEvents$" + randomKey;
      var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
      var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
      var internalRootNodeResourcesKey = "__reactResources$" + randomKey;
      var internalHoistableMarker = "__reactMarker$" + randomKey;
      function detachDeletedInstance(node2) {
        delete node2[internalInstanceKey];
        delete node2[internalPropsKey];
        delete node2[internalEventHandlersKey];
        delete node2[internalEventHandlerListenersKey];
        delete node2[internalEventHandlesSetKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) return targetInst;
        for (var parentNode = targetNode.parentNode; parentNode; ) {
          if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
            parentNode = targetInst.alternate;
            if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
              for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
                if (parentNode = targetNode[internalInstanceKey]) return parentNode;
                targetNode = getParentSuspenseInstance(targetNode);
              }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node2) {
        if (node2 = node2[internalInstanceKey] || node2[internalContainerInstanceKey]) {
          var tag = node2.tag;
          if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
            return node2;
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        var tag = inst.tag;
        if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;
        throw Error(formatProdErrorMessage(33));
      }
      function getResourcesFromRoot(root3) {
        var resources = root3[internalRootNodeResourcesKey];
        resources || (resources = root3[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
        return resources;
      }
      function markNodeAsHoistable(node2) {
        node2[internalHoistableMarker] = true;
      }
      var allNativeEvents = /* @__PURE__ */ new Set();
      var registrationNameDependencies = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        registrationNameDependencies[registrationName] = dependencies;
        for (registrationName = 0; registrationName < dependencies.length; registrationName++)
          allNativeEvents.add(dependencies[registrationName]);
      }
      var VALID_ATTRIBUTE_NAME_REGEX = RegExp(
        "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
      );
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
          return true;
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return false;
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
          return validatedAttributeNameCache[attributeName] = true;
        illegalAttributeNameCache[attributeName] = true;
        return false;
      }
      function setValueForAttribute(node2, name, value) {
        if (isAttributeNameSafe(name))
          if (null === value) node2.removeAttribute(name);
          else {
            switch (typeof value) {
              case "undefined":
              case "function":
              case "symbol":
                node2.removeAttribute(name);
                return;
              case "boolean":
                var prefix$8 = name.toLowerCase().slice(0, 5);
                if ("data-" !== prefix$8 && "aria-" !== prefix$8) {
                  node2.removeAttribute(name);
                  return;
                }
            }
            node2.setAttribute(name, "" + value);
          }
      }
      function setValueForKnownAttribute(node2, name, value) {
        if (null === value) node2.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node2.removeAttribute(name);
              return;
          }
          node2.setAttribute(name, "" + value);
        }
      }
      function setValueForNamespacedAttribute(node2, namespace, name, value) {
        if (null === value) node2.removeAttribute(name);
        else {
          switch (typeof value) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
              node2.removeAttribute(name);
              return;
          }
          node2.setAttributeNS(namespace, name, "" + value);
        }
      }
      var prefix3;
      var suffix;
      function describeBuiltInComponentFrame(name) {
        if (void 0 === prefix3)
          try {
            throw Error();
          } catch (x) {
            var match2 = x.stack.trim().match(/\n( *(at )?)/);
            prefix3 = match2 && match2[1] || "";
            suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
          }
        return "\n" + prefix3 + name + suffix;
      }
      var reentry = false;
      function describeNativeComponentFrame(fn2, construct) {
        if (!fn2 || reentry) return "";
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
          var RunInRootFrame = {
            DetermineComponentFrameRoot: function() {
              try {
                if (construct) {
                  var Fake = function() {
                    throw Error();
                  };
                  Object.defineProperty(Fake.prototype, "props", {
                    set: function() {
                      throw Error();
                    }
                  });
                  if ("object" === typeof Reflect && Reflect.construct) {
                    try {
                      Reflect.construct(Fake, []);
                    } catch (x) {
                      var control = x;
                    }
                    Reflect.construct(fn2, [], Fake);
                  } else {
                    try {
                      Fake.call();
                    } catch (x$9) {
                      control = x$9;
                    }
                    fn2.call(Fake.prototype);
                  }
                } else {
                  try {
                    throw Error();
                  } catch (x$10) {
                    control = x$10;
                  }
                  (Fake = fn2()) && "function" === typeof Fake.catch && Fake.catch(function() {
                  });
                }
              } catch (sample) {
                if (sample && control && "string" === typeof sample.stack)
                  return [sample.stack, control.stack];
              }
              return [null, null];
            }
          };
          RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
          var namePropDescriptor = Object.getOwnPropertyDescriptor(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name"
          );
          namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
            RunInRootFrame.DetermineComponentFrameRoot,
            "name",
            { value: "DetermineComponentFrameRoot" }
          );
          var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
          if (sampleStack && controlStack) {
            var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
            for (namePropDescriptor = RunInRootFrame = 0; RunInRootFrame < sampleLines.length && !sampleLines[RunInRootFrame].includes("DetermineComponentFrameRoot"); )
              RunInRootFrame++;
            for (; namePropDescriptor < controlLines.length && !controlLines[namePropDescriptor].includes(
              "DetermineComponentFrameRoot"
            ); )
              namePropDescriptor++;
            if (RunInRootFrame === sampleLines.length || namePropDescriptor === controlLines.length)
              for (RunInRootFrame = sampleLines.length - 1, namePropDescriptor = controlLines.length - 1; 1 <= RunInRootFrame && 0 <= namePropDescriptor && sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]; )
                namePropDescriptor--;
            for (; 1 <= RunInRootFrame && 0 <= namePropDescriptor; RunInRootFrame--, namePropDescriptor--)
              if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {
                  do
                    if (RunInRootFrame--, namePropDescriptor--, 0 > namePropDescriptor || sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {
                      var frame = "\n" + sampleLines[RunInRootFrame].replace(" at new ", " at ");
                      fn2.displayName && frame.includes("<anonymous>") && (frame = frame.replace("<anonymous>", fn2.displayName));
                      return frame;
                    }
                  while (1 <= RunInRootFrame && 0 <= namePropDescriptor);
                }
                break;
              }
          }
        } finally {
          reentry = false, Error.prepareStackTrace = previousPrepareStackTrace;
        }
        return (previousPrepareStackTrace = fn2 ? fn2.displayName || fn2.name : "") ? describeBuiltInComponentFrame(previousPrepareStackTrace) : "";
      }
      function describeFiber(fiber) {
        switch (fiber.tag) {
          case 26:
          case 27:
          case 5:
            return describeBuiltInComponentFrame(fiber.type);
          case 16:
            return describeBuiltInComponentFrame("Lazy");
          case 13:
            return describeBuiltInComponentFrame("Suspense");
          case 19:
            return describeBuiltInComponentFrame("SuspenseList");
          case 0:
          case 15:
            return describeNativeComponentFrame(fiber.type, false);
          case 11:
            return describeNativeComponentFrame(fiber.type.render, false);
          case 1:
            return describeNativeComponentFrame(fiber.type, true);
          case 31:
            return describeBuiltInComponentFrame("Activity");
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "";
          do
            info += describeFiber(workInProgress2), workInProgress2 = workInProgress2.return;
          while (workInProgress2);
          return info;
        } catch (x) {
          return "\nError generating stack: " + x.message + "\n" + x.stack;
        }
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "bigint":
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            return value;
          default:
            return "";
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
      }
      function trackValueOnNode(node2) {
        var valueField = isCheckable(node2) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
          node2.constructor.prototype,
          valueField
        ), currentValue = "" + node2[valueField];
        if (!node2.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
          var get = descriptor.get, set = descriptor.set;
          Object.defineProperty(node2, valueField, {
            configurable: true,
            get: function() {
              return get.call(this);
            },
            set: function(value) {
              currentValue = "" + value;
              set.call(this, value);
            }
          });
          Object.defineProperty(node2, valueField, {
            enumerable: descriptor.enumerable
          });
          return {
            getValue: function() {
              return currentValue;
            },
            setValue: function(value) {
              currentValue = "" + value;
            },
            stopTracking: function() {
              node2._valueTracker = null;
              delete node2[valueField];
            }
          };
        }
      }
      function track(node2) {
        node2._valueTracker || (node2._valueTracker = trackValueOnNode(node2));
      }
      function updateValueIfChanged(node2) {
        if (!node2) return false;
        var tracker = node2._valueTracker;
        if (!tracker) return true;
        var lastValue = tracker.getValue();
        var value = "";
        node2 && (value = isCheckable(node2) ? node2.checked ? "true" : "false" : node2.value);
        node2 = value;
        return node2 !== lastValue ? (tracker.setValue(node2), true) : false;
      }
      function getActiveElement(doc) {
        doc = doc || ("undefined" !== typeof document ? document : void 0);
        if ("undefined" === typeof doc) return null;
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      var escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g;
      function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
        return value.replace(
          escapeSelectorAttributeValueInsideDoubleQuotesRegex,
          function(ch) {
            return "\\" + ch.charCodeAt(0).toString(16) + " ";
          }
        );
      }
      function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
        element.name = "";
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? element.type = type : element.removeAttribute("type");
        if (null != value)
          if ("number" === type) {
            if (0 === value && "" === element.value || element.value != value)
              element.value = "" + getToStringValue(value);
          } else
            element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
        else
          "submit" !== type && "reset" !== type || element.removeAttribute("value");
        null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
        null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
        null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? element.name = "" + getToStringValue(name) : element.removeAttribute("name");
      }
      function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
        null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (element.type = type);
        if (null != value || null != defaultValue) {
          if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
            return;
          defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
          value = null != value ? "" + getToStringValue(value) : defaultValue;
          isHydrating2 || value === element.value || (element.value = value);
          element.defaultValue = value;
        }
        checked = null != checked ? checked : defaultChecked;
        checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
        element.checked = isHydrating2 ? element.checked : !!checked;
        element.defaultChecked = !!checked;
        null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (element.name = name);
      }
      function setDefaultValue(node2, type, value) {
        "number" === type && getActiveElement(node2.ownerDocument) === node2 || node2.defaultValue === "" + value || (node2.defaultValue = "" + value);
      }
      function updateOptions(node2, multiple, propValue, setDefaultSelected) {
        node2 = node2.options;
        if (multiple) {
          multiple = {};
          for (var i = 0; i < propValue.length; i++)
            multiple["$" + propValue[i]] = true;
          for (propValue = 0; propValue < node2.length; propValue++)
            i = multiple.hasOwnProperty("$" + node2[propValue].value), node2[propValue].selected !== i && (node2[propValue].selected = i), i && setDefaultSelected && (node2[propValue].defaultSelected = true);
        } else {
          propValue = "" + getToStringValue(propValue);
          multiple = null;
          for (i = 0; i < node2.length; i++) {
            if (node2[i].value === propValue) {
              node2[i].selected = true;
              setDefaultSelected && (node2[i].defaultSelected = true);
              return;
            }
            null !== multiple || node2[i].disabled || (multiple = node2[i]);
          }
          null !== multiple && (multiple.selected = true);
        }
      }
      function updateTextarea(element, value, defaultValue) {
        if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
          element.defaultValue !== value && (element.defaultValue = value);
          return;
        }
        element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
      }
      function initTextarea(element, value, defaultValue, children) {
        if (null == value) {
          if (null != children) {
            if (null != defaultValue) throw Error(formatProdErrorMessage(92));
            if (isArrayImpl(children)) {
              if (1 < children.length) throw Error(formatProdErrorMessage(93));
              children = children[0];
            }
            defaultValue = children;
          }
          null == defaultValue && (defaultValue = "");
          value = defaultValue;
        }
        defaultValue = getToStringValue(value);
        element.defaultValue = defaultValue;
        children = element.textContent;
        children === defaultValue && "" !== children && null !== children && (element.value = children);
      }
      function setTextContent(node2, text) {
        if (text) {
          var firstChild = node2.firstChild;
          if (firstChild && firstChild === node2.lastChild && 3 === firstChild.nodeType) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node2.textContent = text;
      }
      var unitlessNumbers = new Set(
        "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
          " "
        )
      );
      function setValueForStyle(style5, styleName, value) {
        var isCustomProperty3 = 0 === styleName.indexOf("--");
        null == value || "boolean" === typeof value || "" === value ? isCustomProperty3 ? style5.setProperty(styleName, "") : "float" === styleName ? style5.cssFloat = "" : style5[styleName] = "" : isCustomProperty3 ? style5.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style5.cssFloat = value : style5[styleName] = ("" + value).trim() : style5[styleName] = value + "px";
      }
      function setValueForStyles(node2, styles2, prevStyles) {
        if (null != styles2 && "object" !== typeof styles2)
          throw Error(formatProdErrorMessage(62));
        node2 = node2.style;
        if (null != prevStyles) {
          for (var styleName in prevStyles)
            !prevStyles.hasOwnProperty(styleName) || null != styles2 && styles2.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node2.setProperty(styleName, "") : "float" === styleName ? node2.cssFloat = "" : node2[styleName] = "");
          for (var styleName$16 in styles2)
            styleName = styles2[styleName$16], styles2.hasOwnProperty(styleName$16) && prevStyles[styleName$16] !== styleName && setValueForStyle(node2, styleName$16, styleName);
        } else
          for (var styleName$17 in styles2)
            styles2.hasOwnProperty(styleName$17) && setValueForStyle(node2, styleName$17, styles2[styleName$17]);
      }
      function isCustomElement(tagName) {
        if (-1 === tagName.indexOf("-")) return false;
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var aliases2 = /* @__PURE__ */ new Map([
        ["acceptCharset", "accept-charset"],
        ["htmlFor", "for"],
        ["httpEquiv", "http-equiv"],
        ["crossOrigin", "crossorigin"],
        ["accentHeight", "accent-height"],
        ["alignmentBaseline", "alignment-baseline"],
        ["arabicForm", "arabic-form"],
        ["baselineShift", "baseline-shift"],
        ["capHeight", "cap-height"],
        ["clipPath", "clip-path"],
        ["clipRule", "clip-rule"],
        ["colorInterpolation", "color-interpolation"],
        ["colorInterpolationFilters", "color-interpolation-filters"],
        ["colorProfile", "color-profile"],
        ["colorRendering", "color-rendering"],
        ["dominantBaseline", "dominant-baseline"],
        ["enableBackground", "enable-background"],
        ["fillOpacity", "fill-opacity"],
        ["fillRule", "fill-rule"],
        ["floodColor", "flood-color"],
        ["floodOpacity", "flood-opacity"],
        ["fontFamily", "font-family"],
        ["fontSize", "font-size"],
        ["fontSizeAdjust", "font-size-adjust"],
        ["fontStretch", "font-stretch"],
        ["fontStyle", "font-style"],
        ["fontVariant", "font-variant"],
        ["fontWeight", "font-weight"],
        ["glyphName", "glyph-name"],
        ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
        ["glyphOrientationVertical", "glyph-orientation-vertical"],
        ["horizAdvX", "horiz-adv-x"],
        ["horizOriginX", "horiz-origin-x"],
        ["imageRendering", "image-rendering"],
        ["letterSpacing", "letter-spacing"],
        ["lightingColor", "lighting-color"],
        ["markerEnd", "marker-end"],
        ["markerMid", "marker-mid"],
        ["markerStart", "marker-start"],
        ["overlinePosition", "overline-position"],
        ["overlineThickness", "overline-thickness"],
        ["paintOrder", "paint-order"],
        ["panose-1", "panose-1"],
        ["pointerEvents", "pointer-events"],
        ["renderingIntent", "rendering-intent"],
        ["shapeRendering", "shape-rendering"],
        ["stopColor", "stop-color"],
        ["stopOpacity", "stop-opacity"],
        ["strikethroughPosition", "strikethrough-position"],
        ["strikethroughThickness", "strikethrough-thickness"],
        ["strokeDasharray", "stroke-dasharray"],
        ["strokeDashoffset", "stroke-dashoffset"],
        ["strokeLinecap", "stroke-linecap"],
        ["strokeLinejoin", "stroke-linejoin"],
        ["strokeMiterlimit", "stroke-miterlimit"],
        ["strokeOpacity", "stroke-opacity"],
        ["strokeWidth", "stroke-width"],
        ["textAnchor", "text-anchor"],
        ["textDecoration", "text-decoration"],
        ["textRendering", "text-rendering"],
        ["transformOrigin", "transform-origin"],
        ["underlinePosition", "underline-position"],
        ["underlineThickness", "underline-thickness"],
        ["unicodeBidi", "unicode-bidi"],
        ["unicodeRange", "unicode-range"],
        ["unitsPerEm", "units-per-em"],
        ["vAlphabetic", "v-alphabetic"],
        ["vHanging", "v-hanging"],
        ["vIdeographic", "v-ideographic"],
        ["vMathematical", "v-mathematical"],
        ["vectorEffect", "vector-effect"],
        ["vertAdvY", "vert-adv-y"],
        ["vertOriginX", "vert-origin-x"],
        ["vertOriginY", "vert-origin-y"],
        ["wordSpacing", "word-spacing"],
        ["writingMode", "writing-mode"],
        ["xmlnsXlink", "xmlns:xlink"],
        ["xHeight", "x-height"]
      ]);
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
      function sanitizeURL(url) {
        return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
      }
      var currentReplayingEvent = null;
      function getEventTarget(nativeEvent) {
        nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
        nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
        return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
      }
      var restoreTarget = null;
      var restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (internalInstance && (target = internalInstance.stateNode)) {
          var props = target[internalPropsKey] || null;
          a: switch (target = internalInstance.stateNode, internalInstance.type) {
            case "input":
              updateInput(
                target,
                props.value,
                props.defaultValue,
                props.defaultValue,
                props.checked,
                props.defaultChecked,
                props.type,
                props.name
              );
              internalInstance = props.name;
              if ("radio" === props.type && null != internalInstance) {
                for (props = target; props.parentNode; ) props = props.parentNode;
                props = props.querySelectorAll(
                  'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
                    "" + internalInstance
                  ) + '"][type="radio"]'
                );
                for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
                  var otherNode = props[internalInstance];
                  if (otherNode !== target && otherNode.form === target.form) {
                    var otherProps = otherNode[internalPropsKey] || null;
                    if (!otherProps) throw Error(formatProdErrorMessage(90));
                    updateInput(
                      otherNode,
                      otherProps.value,
                      otherProps.defaultValue,
                      otherProps.defaultValue,
                      otherProps.checked,
                      otherProps.defaultChecked,
                      otherProps.type,
                      otherProps.name
                    );
                  }
                }
                for (internalInstance = 0; internalInstance < props.length; internalInstance++)
                  otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
              }
              break a;
            case "textarea":
              updateTextarea(target, props.value, props.defaultValue);
              break a;
            case "select":
              internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
          }
        }
      }
      var isInsideEventHandler = false;
      function batchedUpdates$1(fn2, a, b) {
        if (isInsideEventHandler) return fn2(a, b);
        isInsideEventHandler = true;
        try {
          var JSCompiler_inline_result = fn2(a);
          return JSCompiler_inline_result;
        } finally {
          if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
            if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn2 = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn2))
              for (a = 0; a < fn2.length; a++) restoreStateOfTarget(fn2[a]);
          }
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (null === stateNode) return null;
        var props = stateNode[internalPropsKey] || null;
        if (null === props) return null;
        stateNode = props[registrationName];
        a: switch (registrationName) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
            inst = !props;
            break a;
          default:
            inst = false;
        }
        if (inst) return null;
        if (stateNode && "function" !== typeof stateNode)
          throw Error(
            formatProdErrorMessage(231, registrationName, typeof stateNode)
          );
        return stateNode;
      }
      var canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement);
      var passiveBrowserEventsSupported = false;
      if (canUseDOM)
        try {
          options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      var options;
      var root2 = null;
      var startText = null;
      var fallbackText = null;
      function getData() {
        if (fallbackText) return fallbackText;
        var start3, startValue = startText, startLength = startValue.length, end2, endValue = "value" in root2 ? root2.value : root2.textContent, endLength = endValue.length;
        for (start3 = 0; start3 < startLength && startValue[start3] === endValue[start3]; start3++) ;
        var minEnd = startLength - start3;
        for (end2 = 1; end2 <= minEnd && startValue[startLength - end2] === endValue[endLength - end2]; end2++) ;
        return fallbackText = endValue.slice(start3, 1 < end2 ? 1 - end2 : void 0);
      }
      function getEventCharCode(nativeEvent) {
        var keyCode = nativeEvent.keyCode;
        "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
        10 === nativeEvent && (nativeEvent = 13);
        return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var propName in Interface)
            Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
          this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign3(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
          },
          persist: function() {
          },
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      };
      var SyntheticEvent = createSyntheticEvent(EventInterface);
      var UIEventInterface = assign3({}, EventInterface, { view: 0, detail: 0 });
      var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
      var lastMovementX;
      var lastMovementY;
      var lastMouseEvent;
      var MouseEventInterface = assign3({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) return event.movementX;
          event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
          return lastMovementX;
        },
        movementY: function(event) {
          return "movementY" in event ? event.movementY : lastMovementY;
        }
      });
      var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
      var DragEventInterface = assign3({}, MouseEventInterface, { dataTransfer: 0 });
      var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
      var FocusEventInterface = assign3({}, UIEventInterface, { relatedTarget: 0 });
      var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
      var AnimationEventInterface = assign3({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
      var ClipboardEventInterface = assign3({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      });
      var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
      var CompositionEventInterface = assign3({}, EventInterface, { data: 0 });
      var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
      var normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var translateToKey = {
        8: "Backspace",
        9: "Tab",
        12: "Clear",
        13: "Enter",
        16: "Shift",
        17: "Control",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Escape",
        32: " ",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "ArrowLeft",
        38: "ArrowUp",
        39: "ArrowRight",
        40: "ArrowDown",
        45: "Insert",
        46: "Delete",
        112: "F1",
        113: "F2",
        114: "F3",
        115: "F4",
        116: "F5",
        117: "F6",
        118: "F7",
        119: "F8",
        120: "F9",
        121: "F10",
        122: "F11",
        123: "F12",
        144: "NumLock",
        145: "ScrollLock",
        224: "Meta"
      };
      var modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var nativeEvent = this.nativeEvent;
        return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
      }
      function getEventModifierState() {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign3({}, UIEventInterface, {
        key: function(nativeEvent) {
          if (nativeEvent.key) {
            var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
            if ("Unidentified" !== key) return key;
          }
          return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
        },
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : 0;
        },
        keyCode: function(event) {
          return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        },
        which: function(event) {
          return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
        }
      });
      var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
      var PointerEventInterface = assign3({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      });
      var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
      var TouchEventInterface = assign3({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      });
      var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
      var TransitionEventInterface = assign3({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
      var WheelEventInterface = assign3({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
      var ToggleEventInterface = assign3({}, EventInterface, {
        newState: 0,
        oldState: 0
      });
      var SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface);
      var END_KEYCODES = [9, 13, 27, 32];
      var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
      var documentMode = null;
      canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
      var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode);
      var SPACEBAR_CHAR = String.fromCharCode(32);
      var hasSpaceKeypress = false;
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
          case "keydown":
            return 229 !== nativeEvent.keyCode;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        nativeEvent = nativeEvent.detail;
        return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
      }
      var isComposing = false;
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            if (32 !== nativeEvent.which) return null;
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing)
          return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root2 = null, isComposing = false, domEventName) : null;
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
              if (nativeEvent.char && 1 < nativeEvent.char.length)
                return nativeEvent.char;
              if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
        inst = accumulateTwoPhaseListeners(inst, "onChange");
        0 < inst.length && (nativeEvent = new SyntheticEvent(
          "onChange",
          "change",
          null,
          nativeEvent,
          target
        ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
      }
      var activeElement$1 = null;
      var activeElementInst$1 = null;
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) return targetInst;
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if ("change" === domEventName) return targetInst;
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        if (canUseDOM) {
          isSupported$jscomp$inline_417 = "oninput" in document;
          if (!isSupported$jscomp$inline_417) {
            element$jscomp$inline_418 = document.createElement("div");
            element$jscomp$inline_418.setAttribute("oninput", "return;");
            isSupported$jscomp$inline_417 = "function" === typeof element$jscomp$inline_418.oninput;
          }
          JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;
        } else JSCompiler_inline_result$jscomp$282 = false;
        isInputEventSupported = JSCompiler_inline_result$jscomp$282 && (!document.documentMode || 9 < document.documentMode);
      }
      var JSCompiler_inline_result$jscomp$282;
      var isSupported$jscomp$inline_417;
      var element$jscomp$inline_418;
      function stopWatchingForValueChange() {
        activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
      }
      function handlePropertyChange(nativeEvent) {
        if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
          var dispatchQueue = [];
          createAndAccumulateChangeEvent(
            dispatchQueue,
            activeElementInst$1,
            nativeEvent,
            getEventTarget(nativeEvent)
          );
          batchedUpdates$1(runEventInBatch, dispatchQueue);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
      }
      function getTargetInstForInputEventPolyfill(domEventName) {
        if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
          return getInstIfValueChanged(activeElementInst$1);
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if ("click" === domEventName) return getInstIfValueChanged(targetInst);
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if ("input" === domEventName || "change" === domEventName)
          return getInstIfValueChanged(targetInst);
      }
      function is2(x, y) {
        return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = "function" === typeof Object.is ? Object.is : is2;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) return true;
        if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
          return false;
        var keysA = Object.keys(objA), keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) return false;
        for (keysB = 0; keysB < keysA.length; keysB++) {
          var currentKey = keysA[keysB];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
            return false;
        }
        return true;
      }
      function getLeafNode(node2) {
        for (; node2 && node2.firstChild; ) node2 = node2.firstChild;
        return node2;
      }
      function getNodeForCharacterOffset(root3, offset2) {
        var node2 = getLeafNode(root3);
        root3 = 0;
        for (var nodeEnd; node2; ) {
          if (3 === node2.nodeType) {
            nodeEnd = root3 + node2.textContent.length;
            if (root3 <= offset2 && nodeEnd >= offset2)
              return { node: node2, offset: offset2 - root3 };
            root3 = nodeEnd;
          }
          a: {
            for (; node2; ) {
              if (node2.nextSibling) {
                node2 = node2.nextSibling;
                break a;
              }
              node2 = node2.parentNode;
            }
            node2 = void 0;
          }
          node2 = getLeafNode(node2);
        }
      }
      function containsNode(outerNode, innerNode) {
        return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
      }
      function getActiveElementDeep(containerInfo) {
        containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
        for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
          try {
            var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
          } catch (err) {
            JSCompiler_inline_result = false;
          }
          if (JSCompiler_inline_result) containerInfo = element.contentWindow;
          else break;
          element = getActiveElement(containerInfo.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode;
      var activeElement = null;
      var activeElementInst = null;
      var lastSelection = null;
      var mouseDown = false;
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
        mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
          anchorNode: doc.anchorNode,
          anchorOffset: doc.anchorOffset,
          focusNode: doc.focusNode,
          focusOffset: doc.focusOffset
        }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
          "onSelect",
          "select",
          null,
          nativeEvent,
          nativeEventTarget
        ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes3 = {};
        prefixes3[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes3["Webkit" + styleProp] = "webkit" + eventName;
        prefixes3["Moz" + styleProp] = "moz" + eventName;
        return prefixes3;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionrun: makePrefixMap("Transition", "TransitionRun"),
        transitionstart: makePrefixMap("Transition", "TransitionStart"),
        transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      var prefixedEventNames = {};
      var style4 = {};
      canUseDOM && (style4 = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
        if (!vendorPrefixes[eventName]) return eventName;
        var prefixMap = vendorPrefixes[eventName], styleProp;
        for (styleProp in prefixMap)
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style4)
            return prefixedEventNames[eventName] = prefixMap[styleProp];
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend");
      var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
      var ANIMATION_START = getVendorPrefixedEventName("animationstart");
      var TRANSITION_RUN = getVendorPrefixedEventName("transitionrun");
      var TRANSITION_START = getVendorPrefixedEventName("transitionstart");
      var TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel");
      var TRANSITION_END = getVendorPrefixedEventName("transitionend");
      var topLevelEventsToReactNames = /* @__PURE__ */ new Map();
      var simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
        " "
      );
      simpleEventPluginEvents.push("scrollEnd");
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      var CapturedStacks = /* @__PURE__ */ new WeakMap();
      function createCapturedValueAtFiber(value, source) {
        if ("object" === typeof value && null !== value) {
          var existing = CapturedStacks.get(value);
          if (void 0 !== existing) return existing;
          source = {
            value,
            source,
            stack: getStackByFiberInDevAndProd(source)
          };
          CapturedStacks.set(value, source);
          return source;
        }
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source)
        };
      }
      var concurrentQueues = [];
      var concurrentQueuesIndex = 0;
      var concurrentlyUpdatedLanes = 0;
      function finishQueueingConcurrentUpdates() {
        for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
          var fiber = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var queue = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var update3 = concurrentQueues[i];
          concurrentQueues[i++] = null;
          var lane = concurrentQueues[i];
          concurrentQueues[i++] = null;
          if (null !== queue && null !== update3) {
            var pending = queue.pending;
            null === pending ? update3.next = update3 : (update3.next = pending.next, pending.next = update3);
            queue.pending = update3;
          }
          0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update3, lane);
        }
      }
      function enqueueUpdate$1(fiber, queue, update3, lane) {
        concurrentQueues[concurrentQueuesIndex++] = fiber;
        concurrentQueues[concurrentQueuesIndex++] = queue;
        concurrentQueues[concurrentQueuesIndex++] = update3;
        concurrentQueues[concurrentQueuesIndex++] = lane;
        concurrentlyUpdatedLanes |= lane;
        fiber.lanes |= lane;
        fiber = fiber.alternate;
        null !== fiber && (fiber.lanes |= lane);
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update3, lane) {
        enqueueUpdate$1(fiber, queue, update3, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        enqueueUpdate$1(fiber, null, null, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function markUpdateLaneFromFiberToRoot(sourceFiber, update3, lane) {
        sourceFiber.lanes |= lane;
        var alternate = sourceFiber.alternate;
        null !== alternate && (alternate.lanes |= lane);
        for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
          parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = true)), sourceFiber = parent, parent = parent.return;
        return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update3 && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update3] : alternate.push(update3), update3.lane = lane | 536870912), parent) : null;
      }
      function getRootForUpdatedFiber(sourceFiber) {
        if (50 < nestedUpdateCount)
          throw nestedUpdateCount = 0, rootWithNestedUpdates = null, Error(formatProdErrorMessage(185));
        for (var parent = sourceFiber.return; null !== parent; )
          sourceFiber = parent, parent = sourceFiber.return;
        return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;
      }
      var emptyContextObject = {};
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
        this.index = 0;
        this.refCleanup = this.ref = null;
        this.pendingProps = pendingProps;
        this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
        this.mode = mode;
        this.subtreeFlags = this.flags = 0;
        this.deletions = null;
        this.childLanes = this.lanes = 0;
        this.alternate = null;
      }
      function createFiberImplClass(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      }
      function shouldConstruct(Component) {
        Component = Component.prototype;
        return !(!Component || !Component.isReactComponent);
      }
      function createWorkInProgress(current, pendingProps) {
        var workInProgress2 = current.alternate;
        null === workInProgress2 ? (workInProgress2 = createFiberImplClass(
          current.tag,
          pendingProps,
          current.key,
          current.mode
        ), workInProgress2.elementType = current.elementType, workInProgress2.type = current.type, workInProgress2.stateNode = current.stateNode, workInProgress2.alternate = current, current.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null);
        workInProgress2.flags = current.flags & 65011712;
        workInProgress2.childLanes = current.childLanes;
        workInProgress2.lanes = current.lanes;
        workInProgress2.child = current.child;
        workInProgress2.memoizedProps = current.memoizedProps;
        workInProgress2.memoizedState = current.memoizedState;
        workInProgress2.updateQueue = current.updateQueue;
        pendingProps = current.dependencies;
        workInProgress2.dependencies = null === pendingProps ? null : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };
        workInProgress2.sibling = current.sibling;
        workInProgress2.index = current.index;
        workInProgress2.ref = current.ref;
        workInProgress2.refCleanup = current.refCleanup;
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= 65011714;
        var current = workInProgress2.alternate;
        null === current ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null) : (workInProgress2.childLanes = current.childLanes, workInProgress2.lanes = current.lanes, workInProgress2.child = current.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current.memoizedProps, workInProgress2.memoizedState = current.memoizedState, workInProgress2.updateQueue = current.updateQueue, workInProgress2.type = current.type, renderLanes2 = current.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
          lanes: renderLanes2.lanes,
          firstContext: renderLanes2.firstContext
        });
        return workInProgress2;
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = 0;
        owner = type;
        if ("function" === typeof type) shouldConstruct(type) && (fiberTag = 1);
        else if ("string" === typeof type)
          fiberTag = isHostHoistableType(
            type,
            pendingProps,
            contextStackCursor.current
          ) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
        else
          a: switch (type) {
            case REACT_ACTIVITY_TYPE:
              return type = createFiberImplClass(31, pendingProps, key, mode), type.elementType = REACT_ACTIVITY_TYPE, type.lanes = lanes, type;
            case REACT_FRAGMENT_TYPE:
              return createFiberFromFragment(pendingProps.children, mode, lanes, key);
            case REACT_STRICT_MODE_TYPE:
              fiberTag = 8;
              mode |= 24;
              break;
            case REACT_PROFILER_TYPE:
              return type = createFiberImplClass(12, pendingProps, key, mode | 2), type.elementType = REACT_PROFILER_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_TYPE:
              return type = createFiberImplClass(13, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_TYPE, type.lanes = lanes, type;
            case REACT_SUSPENSE_LIST_TYPE:
              return type = createFiberImplClass(19, pendingProps, key, mode), type.elementType = REACT_SUSPENSE_LIST_TYPE, type.lanes = lanes, type;
            default:
              if ("object" === typeof type && null !== type)
                switch (type.$$typeof) {
                  case REACT_PROVIDER_TYPE:
                  case REACT_CONTEXT_TYPE:
                    fiberTag = 10;
                    break a;
                  case REACT_CONSUMER_TYPE:
                    fiberTag = 9;
                    break a;
                  case REACT_FORWARD_REF_TYPE:
                    fiberTag = 11;
                    break a;
                  case REACT_MEMO_TYPE:
                    fiberTag = 14;
                    break a;
                  case REACT_LAZY_TYPE:
                    fiberTag = 16;
                    owner = null;
                    break a;
                }
              fiberTag = 29;
              pendingProps = Error(
                formatProdErrorMessage(130, null === type ? "null" : typeof type, "")
              );
              owner = null;
          }
        key = createFiberImplClass(fiberTag, pendingProps, key, mode);
        key.elementType = type;
        key.type = owner;
        key.lanes = lanes;
        return key;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        elements = createFiberImplClass(7, elements, key, mode);
        elements.lanes = lanes;
        return elements;
      }
      function createFiberFromText(content, mode, lanes) {
        content = createFiberImplClass(6, content, null, mode);
        content.lanes = lanes;
        return content;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        mode = createFiberImplClass(
          4,
          null !== portal.children ? portal.children : [],
          portal.key,
          mode
        );
        mode.lanes = lanes;
        mode.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return mode;
      }
      var forkStack = [];
      var forkStackIndex = 0;
      var treeForkProvider = null;
      var treeForkCount = 0;
      var idStack = [];
      var idStackIndex = 0;
      var treeContextProvider = null;
      var treeContextId = 1;
      var treeContextOverflow = "";
      function pushTreeFork(workInProgress2, totalChildren) {
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        workInProgress2 = treeContextOverflow;
        var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
        baseIdWithLeadingBit &= ~(1 << baseLength);
        index2 += 1;
        var length2 = 32 - clz32(totalChildren) + baseLength;
        if (30 < length2) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          length2 = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
          baseIdWithLeadingBit >>= numberOfOverflowBits;
          baseLength -= numberOfOverflowBits;
          treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index2 << baseLength | baseIdWithLeadingBit;
          treeContextOverflow = length2 + workInProgress2;
        } else
          treeContextId = 1 << length2 | index2 << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
      }
      function pushMaterializedTreeId(workInProgress2) {
        null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
      }
      function popTreeContext(workInProgress2) {
        for (; workInProgress2 === treeForkProvider; )
          treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
        for (; workInProgress2 === treeContextProvider; )
          treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
      }
      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;
      var hydrationErrors = null;
      var rootOrSingletonContext = false;
      var HydrationMismatchException = Error(formatProdErrorMessage(519));
      function throwOnHydrationMismatch(fiber) {
        var error = Error(formatProdErrorMessage(418, ""));
        queueHydrationError(createCapturedValueAtFiber(error, fiber));
        throw HydrationMismatchException;
      }
      function prepareToHydrateHostInstance(fiber) {
        var instance2 = fiber.stateNode, type = fiber.type, props = fiber.memoizedProps;
        instance2[internalInstanceKey] = fiber;
        instance2[internalPropsKey] = props;
        switch (type) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", instance2);
            listenToNonDelegatedEvent("close", instance2);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", instance2);
            break;
          case "video":
          case "audio":
            for (type = 0; type < mediaEventTypes.length; type++)
              listenToNonDelegatedEvent(mediaEventTypes[type], instance2);
            break;
          case "source":
            listenToNonDelegatedEvent("error", instance2);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", instance2);
            listenToNonDelegatedEvent("load", instance2);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", instance2);
            break;
          case "input":
            listenToNonDelegatedEvent("invalid", instance2);
            initInput(
              instance2,
              props.value,
              props.defaultValue,
              props.checked,
              props.defaultChecked,
              props.type,
              props.name,
              true
            );
            track(instance2);
            break;
          case "select":
            listenToNonDelegatedEvent("invalid", instance2);
            break;
          case "textarea":
            listenToNonDelegatedEvent("invalid", instance2), initTextarea(instance2, props.value, props.defaultValue, props.children), track(instance2);
        }
        type = props.children;
        "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || instance2.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(instance2.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", instance2), listenToNonDelegatedEvent("toggle", instance2)), null != props.onScroll && listenToNonDelegatedEvent("scroll", instance2), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", instance2), null != props.onClick && (instance2.onclick = noop$1), instance2 = true) : instance2 = false;
        instance2 || throwOnHydrationMismatch(fiber);
      }
      function popToNextHostParent(fiber) {
        for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
          switch (hydrationParentFiber.tag) {
            case 5:
            case 13:
              rootOrSingletonContext = false;
              return;
            case 27:
            case 3:
              rootOrSingletonContext = true;
              return;
            default:
              hydrationParentFiber = hydrationParentFiber.return;
          }
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) return false;
        if (!isHydrating) return popToNextHostParent(fiber), isHydrating = true, false;
        var tag = fiber.tag, JSCompiler_temp;
        if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
          if (JSCompiler_temp = 5 === tag)
            JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
          JSCompiler_temp = !JSCompiler_temp;
        }
        JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);
        popToNextHostParent(fiber);
        if (13 === tag) {
          fiber = fiber.memoizedState;
          fiber = null !== fiber ? fiber.dehydrated : null;
          if (!fiber) throw Error(formatProdErrorMessage(317));
          a: {
            fiber = fiber.nextSibling;
            for (tag = 0; fiber; ) {
              if (8 === fiber.nodeType)
                if (JSCompiler_temp = fiber.data, "/$" === JSCompiler_temp) {
                  if (0 === tag) {
                    nextHydratableInstance = getNextHydratable(fiber.nextSibling);
                    break a;
                  }
                  tag--;
                } else
                  "$" !== JSCompiler_temp && "$!" !== JSCompiler_temp && "$?" !== JSCompiler_temp || tag++;
              fiber = fiber.nextSibling;
            }
            nextHydratableInstance = null;
          }
        } else
          27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
        return true;
      }
      function resetHydrationState() {
        nextHydratableInstance = hydrationParentFiber = null;
        isHydrating = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        var queuedErrors = hydrationErrors;
        null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
          workInProgressRootRecoverableErrors,
          queuedErrors
        ), hydrationErrors = null);
        return queuedErrors;
      }
      function queueHydrationError(error) {
        null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
      }
      var valueCursor = createCursor(null);
      var currentlyRenderingFiber$1 = null;
      var lastContextDependency = null;
      function pushProvider(providerFiber, context, nextValue) {
        push(valueCursor, context._currentValue);
        context._currentValue = nextValue;
      }
      function popProvider(context) {
        context._currentValue = valueCursor.current;
        pop(valueCursor);
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        for (; null !== parent; ) {
          var alternate = parent.alternate;
          (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
          if (parent === propagationRoot) break;
          parent = parent.return;
        }
      }
      function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
        var fiber = workInProgress2.child;
        null !== fiber && (fiber.return = workInProgress2);
        for (; null !== fiber; ) {
          var list = fiber.dependencies;
          if (null !== list) {
            var nextFiber = fiber.child;
            list = list.firstContext;
            a: for (; null !== list; ) {
              var dependency = list;
              list = fiber;
              for (var i = 0; i < contexts.length; i++)
                if (dependency.context === contexts[i]) {
                  list.lanes |= renderLanes2;
                  dependency = list.alternate;
                  null !== dependency && (dependency.lanes |= renderLanes2);
                  scheduleContextWorkOnParentPath(
                    list.return,
                    renderLanes2,
                    workInProgress2
                  );
                  forcePropagateEntireTree || (nextFiber = null);
                  break a;
                }
              list = dependency.next;
            }
          } else if (18 === fiber.tag) {
            nextFiber = fiber.return;
            if (null === nextFiber) throw Error(formatProdErrorMessage(341));
            nextFiber.lanes |= renderLanes2;
            list = nextFiber.alternate;
            null !== list && (list.lanes |= renderLanes2);
            scheduleContextWorkOnParentPath(nextFiber, renderLanes2, workInProgress2);
            nextFiber = null;
          } else nextFiber = fiber.child;
          if (null !== nextFiber) nextFiber.return = fiber;
          else
            for (nextFiber = fiber; null !== nextFiber; ) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              fiber = nextFiber.sibling;
              if (null !== fiber) {
                fiber.return = nextFiber.return;
                nextFiber = fiber;
                break;
              }
              nextFiber = nextFiber.return;
            }
          fiber = nextFiber;
        }
      }
      function propagateParentContextChanges(current, workInProgress2, renderLanes2, forcePropagateEntireTree) {
        current = null;
        for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
          if (!isInsidePropagationBailout) {
            if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
            else if (0 !== (parent.flags & 262144)) break;
          }
          if (10 === parent.tag) {
            var currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent = currentParent.memoizedProps;
            if (null !== currentParent) {
              var context = parent.type;
              objectIs(parent.pendingProps.value, currentParent.value) || (null !== current ? current.push(context) : current = [context]);
            }
          } else if (parent === hostTransitionProviderCursor.current) {
            currentParent = parent.alternate;
            if (null === currentParent) throw Error(formatProdErrorMessage(387));
            currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current ? current.push(HostTransitionContext) : current = [HostTransitionContext]);
          }
          parent = parent.return;
        }
        null !== current && propagateContextChanges(
          workInProgress2,
          current,
          renderLanes2,
          forcePropagateEntireTree
        );
        workInProgress2.flags |= 262144;
      }
      function checkIfContextChanged(currentDependencies) {
        for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
          if (!objectIs(
            currentDependencies.context._currentValue,
            currentDependencies.memoizedValue
          ))
            return true;
          currentDependencies = currentDependencies.next;
        }
        return false;
      }
      function prepareToReadContext(workInProgress2) {
        currentlyRenderingFiber$1 = workInProgress2;
        lastContextDependency = null;
        workInProgress2 = workInProgress2.dependencies;
        null !== workInProgress2 && (workInProgress2.firstContext = null);
      }
      function readContext(context) {
        return readContextForConsumer(currentlyRenderingFiber$1, context);
      }
      function readContextDuringReconciliation(consumer, context) {
        null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
        return readContextForConsumer(consumer, context);
      }
      function readContextForConsumer(consumer, context) {
        var value = context._currentValue;
        context = { context, memoizedValue: value, next: null };
        if (null === lastContextDependency) {
          if (null === consumer) throw Error(formatProdErrorMessage(308));
          lastContextDependency = context;
          consumer.dependencies = { lanes: 0, firstContext: context };
          consumer.flags |= 524288;
        } else lastContextDependency = lastContextDependency.next = context;
        return value;
      }
      var AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
        var listeners = [], signal = this.signal = {
          aborted: false,
          addEventListener: function(type, listener) {
            listeners.push(listener);
          }
        };
        this.abort = function() {
          signal.aborted = true;
          listeners.forEach(function(listener) {
            return listener();
          });
        };
      };
      var scheduleCallback$2 = Scheduler.unstable_scheduleCallback;
      var NormalPriority = Scheduler.unstable_NormalPriority;
      var CacheContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Consumer: null,
        Provider: null,
        _currentValue: null,
        _currentValue2: null,
        _threadCount: 0
      };
      function createCache3() {
        return {
          controller: new AbortControllerLocal(),
          data: /* @__PURE__ */ new Map(),
          refCount: 0
        };
      }
      function releaseCache(cache) {
        cache.refCount--;
        0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
          cache.controller.abort();
        });
      }
      var currentEntangledListeners = null;
      var currentEntangledPendingCount = 0;
      var currentEntangledLane = 0;
      var currentEntangledActionThenable = null;
      function entangleAsyncAction(transition, thenable) {
        if (null === currentEntangledListeners) {
          var entangledListeners = currentEntangledListeners = [];
          currentEntangledPendingCount = 0;
          currentEntangledLane = requestTransitionLane();
          currentEntangledActionThenable = {
            status: "pending",
            value: void 0,
            then: function(resolve) {
              entangledListeners.push(resolve);
            }
          };
        }
        currentEntangledPendingCount++;
        thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
        return thenable;
      }
      function pingEngtangledActionScope() {
        if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
          null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
          var listeners = currentEntangledListeners;
          currentEntangledListeners = null;
          currentEntangledLane = 0;
          currentEntangledActionThenable = null;
          for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
        }
      }
      function chainThenableValue(thenable, result) {
        var listeners = [], thenableWithOverride = {
          status: "pending",
          value: null,
          reason: null,
          then: function(resolve) {
            listeners.push(resolve);
          }
        };
        thenable.then(
          function() {
            thenableWithOverride.status = "fulfilled";
            thenableWithOverride.value = result;
            for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
          },
          function(error) {
            thenableWithOverride.status = "rejected";
            thenableWithOverride.reason = error;
            for (error = 0; error < listeners.length; error++)
              (0, listeners[error])(void 0);
          }
        );
        return thenableWithOverride;
      }
      var prevOnStartTransitionFinish = ReactSharedInternals.S;
      ReactSharedInternals.S = function(transition, returnValue) {
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
        null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
      };
      var resumedCache = createCursor(null);
      function peekCacheFromPool() {
        var cacheResumedFromPreviousRender = resumedCache.current;
        return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
      }
      function pushTransition(offscreenWorkInProgress, prevCachePool) {
        null === prevCachePool ? push(resumedCache, resumedCache.current) : push(resumedCache, prevCachePool.pool);
      }
      function getSuspendedCache() {
        var cacheFromPool = peekCacheFromPool();
        return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
      }
      var SuspenseException = Error(formatProdErrorMessage(460));
      var SuspenseyCommitException = Error(formatProdErrorMessage(474));
      var SuspenseActionException = Error(formatProdErrorMessage(542));
      var noopSuspenseyCommitThenable = { then: function() {
      } };
      function isThenableResolved(thenable) {
        thenable = thenable.status;
        return "fulfilled" === thenable || "rejected" === thenable;
      }
      function noop$3() {
      }
      function trackUsedThenable(thenableState2, thenable, index2) {
        index2 = thenableState2[index2];
        void 0 === index2 ? thenableState2.push(thenable) : index2 !== thenable && (thenable.then(noop$3, noop$3), thenable = index2);
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
          default:
            if ("string" === typeof thenable.status) thenable.then(noop$3, noop$3);
            else {
              thenableState2 = workInProgressRoot;
              if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
                throw Error(formatProdErrorMessage(482));
              thenableState2 = thenable;
              thenableState2.status = "pending";
              thenableState2.then(
                function(fulfilledValue) {
                  if ("pending" === thenable.status) {
                    var fulfilledThenable = thenable;
                    fulfilledThenable.status = "fulfilled";
                    fulfilledThenable.value = fulfilledValue;
                  }
                },
                function(error) {
                  if ("pending" === thenable.status) {
                    var rejectedThenable = thenable;
                    rejectedThenable.status = "rejected";
                    rejectedThenable.reason = error;
                  }
                }
              );
            }
            switch (thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
            }
            suspendedThenable = thenable;
            throw SuspenseException;
        }
      }
      var suspendedThenable = null;
      function getSuspendedThenable() {
        if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));
        var thenable = suspendedThenable;
        suspendedThenable = null;
        return thenable;
      }
      function checkIfUseWrappedInAsyncCatch(rejectedReason) {
        if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
          throw Error(formatProdErrorMessage(483));
      }
      var hasForceUpdate = false;
      function initializeUpdateQueue(fiber) {
        fiber.updateQueue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: { pending: null, lanes: 0, hiddenCallbacks: null },
          callbacks: null
        };
      }
      function cloneUpdateQueue(current, workInProgress2) {
        current = current.updateQueue;
        workInProgress2.updateQueue === current && (workInProgress2.updateQueue = {
          baseState: current.baseState,
          firstBaseUpdate: current.firstBaseUpdate,
          lastBaseUpdate: current.lastBaseUpdate,
          shared: current.shared,
          callbacks: null
        });
      }
      function createUpdate2(lane) {
        return { lane, tag: 0, payload: null, callback: null, next: null };
      }
      function enqueueUpdate(fiber, update3, lane) {
        var updateQueue2 = fiber.updateQueue;
        if (null === updateQueue2) return null;
        updateQueue2 = updateQueue2.shared;
        if (0 !== (executionContext & 2)) {
          var pending = updateQueue2.pending;
          null === pending ? update3.next = update3 : (update3.next = pending.next, pending.next = update3);
          updateQueue2.pending = update3;
          update3 = getRootForUpdatedFiber(fiber);
          markUpdateLaneFromFiberToRoot(fiber, null, lane);
          return update3;
        }
        enqueueUpdate$1(fiber, updateQueue2, update3, lane);
        return getRootForUpdatedFiber(fiber);
      }
      function entangleTransitions(root3, fiber, lane) {
        fiber = fiber.updateQueue;
        if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
          var queueLanes = fiber.lanes;
          queueLanes &= root3.pendingLanes;
          lane |= queueLanes;
          fiber.lanes = lane;
          markRootEntangled(root3, lane);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue, current = workInProgress2.alternate;
        if (null !== current && (current = current.updateQueue, queue === current)) {
          var newFirst = null, newLast = null;
          queue = queue.firstBaseUpdate;
          if (null !== queue) {
            do {
              var clone = {
                lane: queue.lane,
                tag: queue.tag,
                payload: queue.payload,
                callback: null,
                next: null
              };
              null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
              queue = queue.next;
            } while (null !== queue);
            null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
          } else newFirst = newLast = capturedUpdate;
          queue = {
            baseState: current.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: current.shared,
            callbacks: current.callbacks
          };
          workInProgress2.updateQueue = queue;
          return;
        }
        workInProgress2 = queue.lastBaseUpdate;
        null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
        queue.lastBaseUpdate = capturedUpdate;
      }
      var didReadFromEntangledAsyncAction = false;
      function suspendIfUpdateReadFromEntangledAsyncAction() {
        if (didReadFromEntangledAsyncAction) {
          var entangledActionThenable = currentEntangledActionThenable;
          if (null !== entangledActionThenable) throw entangledActionThenable;
        }
      }
      function processUpdateQueue(workInProgress$jscomp$0, props, instance$jscomp$0, renderLanes2) {
        didReadFromEntangledAsyncAction = false;
        var queue = workInProgress$jscomp$0.updateQueue;
        hasForceUpdate = false;
        var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
        if (null !== pendingQueue) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
          lastBaseUpdate = lastPendingUpdate;
          var current = workInProgress$jscomp$0.alternate;
          null !== current && (current = current.updateQueue, pendingQueue = current.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current.lastBaseUpdate = lastPendingUpdate));
        }
        if (null !== firstBaseUpdate) {
          var newState = queue.baseState;
          lastBaseUpdate = 0;
          current = firstPendingUpdate = lastPendingUpdate = null;
          pendingQueue = firstBaseUpdate;
          do {
            var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
            if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
              0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
              null !== current && (current = current.next = {
                lane: 0,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: null,
                next: null
              });
              a: {
                var workInProgress2 = workInProgress$jscomp$0, update3 = pendingQueue;
                updateLane = props;
                var instance2 = instance$jscomp$0;
                switch (update3.tag) {
                  case 1:
                    workInProgress2 = update3.payload;
                    if ("function" === typeof workInProgress2) {
                      newState = workInProgress2.call(instance2, newState, updateLane);
                      break a;
                    }
                    newState = workInProgress2;
                    break a;
                  case 3:
                    workInProgress2.flags = workInProgress2.flags & -65537 | 128;
                  case 0:
                    workInProgress2 = update3.payload;
                    updateLane = "function" === typeof workInProgress2 ? workInProgress2.call(instance2, newState, updateLane) : workInProgress2;
                    if (null === updateLane || void 0 === updateLane) break a;
                    newState = assign3({}, newState, updateLane);
                    break a;
                  case 2:
                    hasForceUpdate = true;
                }
              }
              updateLane = pendingQueue.callback;
              null !== updateLane && (workInProgress$jscomp$0.flags |= 64, isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
            } else
              isHiddenUpdate = {
                lane: updateLane,
                tag: pendingQueue.tag,
                payload: pendingQueue.payload,
                callback: pendingQueue.callback,
                next: null
              }, null === current ? (firstPendingUpdate = current = isHiddenUpdate, lastPendingUpdate = newState) : current = current.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
            pendingQueue = pendingQueue.next;
            if (null === pendingQueue)
              if (pendingQueue = queue.shared.pending, null === pendingQueue)
                break;
              else
                isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
          } while (1);
          null === current && (lastPendingUpdate = newState);
          queue.baseState = lastPendingUpdate;
          queue.firstBaseUpdate = firstPendingUpdate;
          queue.lastBaseUpdate = current;
          null === firstBaseUpdate && (queue.shared.lanes = 0);
          workInProgressRootSkippedLanes |= lastBaseUpdate;
          workInProgress$jscomp$0.lanes = lastBaseUpdate;
          workInProgress$jscomp$0.memoizedState = newState;
        }
      }
      function callCallback(callback, context) {
        if ("function" !== typeof callback)
          throw Error(formatProdErrorMessage(191, callback));
        callback.call(context);
      }
      function commitCallbacks(updateQueue2, context) {
        var callbacks = updateQueue2.callbacks;
        if (null !== callbacks)
          for (updateQueue2.callbacks = null, updateQueue2 = 0; updateQueue2 < callbacks.length; updateQueue2++)
            callCallback(callbacks[updateQueue2], context);
      }
      var currentTreeHiddenStackCursor = createCursor(null);
      var prevEntangledRenderLanesCursor = createCursor(0);
      function pushHiddenContext(fiber, context) {
        fiber = entangledRenderLanes;
        push(prevEntangledRenderLanesCursor, fiber);
        push(currentTreeHiddenStackCursor, context);
        entangledRenderLanes = fiber | context.baseLanes;
      }
      function reuseHiddenContextOnStack() {
        push(prevEntangledRenderLanesCursor, entangledRenderLanes);
        push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);
      }
      function popHiddenContext() {
        entangledRenderLanes = prevEntangledRenderLanesCursor.current;
        pop(currentTreeHiddenStackCursor);
        pop(prevEntangledRenderLanesCursor);
      }
      var renderLanes = 0;
      var currentlyRenderingFiber = null;
      var currentHook = null;
      var workInProgressHook = null;
      var didScheduleRenderPhaseUpdate = false;
      var didScheduleRenderPhaseUpdateDuringThisPass = false;
      var shouldDoubleInvokeUserFnsInHooksDEV = false;
      var localIdCounter = 0;
      var thenableIndexCounter$1 = 0;
      var thenableState$1 = null;
      var globalClientIdCounter = 0;
      function throwInvalidHookError() {
        throw Error(formatProdErrorMessage(321));
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        if (null === prevDeps) return false;
        for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
          if (!objectIs(nextDeps[i], prevDeps[i])) return false;
        return true;
      }
      function renderWithHooks(current, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber = workInProgress2;
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = 0;
        ReactSharedInternals.H = null === current || null === current.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate;
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        nextRenderLanes = Component(props, secondArg);
        shouldDoubleInvokeUserFnsInHooksDEV = false;
        didScheduleRenderPhaseUpdateDuringThisPass && (nextRenderLanes = renderWithHooksAgain(
          workInProgress2,
          Component,
          props,
          secondArg
        ));
        finishRenderingHooks(current);
        return nextRenderLanes;
      }
      function finishRenderingHooks(current) {
        ReactSharedInternals.H = ContextOnlyDispatcher;
        var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdate = false;
        thenableIndexCounter$1 = 0;
        thenableState$1 = null;
        if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));
        null === current || didReceiveUpdate || (current = current.dependencies, null !== current && checkIfContextChanged(current) && (didReceiveUpdate = true));
      }
      function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
        currentlyRenderingFiber = workInProgress2;
        var numberOfReRenders = 0;
        do {
          didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
          thenableIndexCounter$1 = 0;
          didScheduleRenderPhaseUpdateDuringThisPass = false;
          if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));
          numberOfReRenders += 1;
          workInProgressHook = currentHook = null;
          if (null != workInProgress2.updateQueue) {
            var children = workInProgress2.updateQueue;
            children.lastEffect = null;
            children.events = null;
            children.stores = null;
            null != children.memoCache && (children.memoCache.index = 0);
          }
          ReactSharedInternals.H = HooksDispatcherOnRerender;
          children = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
        return children;
      }
      function TransitionAwareHostComponent() {
        var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
        maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
        dispatcher = dispatcher.useState()[0];
        (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
        return maybeThenable;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = 0 !== localIdCounter;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current, workInProgress2, lanes) {
        workInProgress2.updateQueue = current.updateQueue;
        workInProgress2.flags &= -2053;
        current.lanes &= ~lanes;
      }
      function resetHooksOnUnwind(workInProgress2) {
        if (didScheduleRenderPhaseUpdate) {
          for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
            var queue = workInProgress2.queue;
            null !== queue && (queue.pending = null);
            workInProgress2 = workInProgress2.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = 0;
        workInProgressHook = currentHook = currentlyRenderingFiber = null;
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        thenableIndexCounter$1 = localIdCounter = 0;
        thenableState$1 = null;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        if (null === currentHook) {
          var nextCurrentHook = currentlyRenderingFiber.alternate;
          nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
        } else nextCurrentHook = currentHook.next;
        var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
        if (null !== nextWorkInProgressHook)
          workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
        else {
          if (null === nextCurrentHook) {
            if (null === currentlyRenderingFiber.alternate)
              throw Error(formatProdErrorMessage(467));
            throw Error(formatProdErrorMessage(310));
          }
          currentHook = nextCurrentHook;
          nextCurrentHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return { lastEffect: null, events: null, stores: null, memoCache: null };
      }
      function useThenable(thenable) {
        var index2 = thenableIndexCounter$1;
        thenableIndexCounter$1 += 1;
        null === thenableState$1 && (thenableState$1 = []);
        thenable = trackUsedThenable(thenableState$1, thenable, index2);
        index2 = currentlyRenderingFiber;
        null === (null === workInProgressHook ? index2.memoizedState : workInProgressHook.next) && (index2 = index2.alternate, ReactSharedInternals.H = null === index2 || null === index2.memoizedState ? HooksDispatcherOnMount : HooksDispatcherOnUpdate);
        return thenable;
      }
      function use(usable) {
        if (null !== usable && "object" === typeof usable) {
          if ("function" === typeof usable.then) return useThenable(usable);
          if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
        }
        throw Error(formatProdErrorMessage(438, String(usable)));
      }
      function useMemoCache(size) {
        var memoCache = null, updateQueue2 = currentlyRenderingFiber.updateQueue;
        null !== updateQueue2 && (memoCache = updateQueue2.memoCache);
        if (null == memoCache) {
          var current = currentlyRenderingFiber.alternate;
          null !== current && (current = current.updateQueue, null !== current && (current = current.memoCache, null != current && (memoCache = {
            data: current.data.map(function(array) {
              return array.slice();
            }),
            index: 0
          })));
        }
        null == memoCache && (memoCache = { data: [], index: 0 });
        null === updateQueue2 && (updateQueue2 = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue2);
        updateQueue2.memoCache = memoCache;
        updateQueue2 = memoCache.data[memoCache.index];
        if (void 0 === updateQueue2)
          for (updateQueue2 = memoCache.data[memoCache.index] = Array(size), current = 0; current < size; current++)
            updateQueue2[current] = REACT_MEMO_CACHE_SENTINEL;
        memoCache.index++;
        return updateQueue2;
      }
      function basicStateReducer(state, action) {
        return "function" === typeof action ? action(state) : action;
      }
      function updateReducer(reducer) {
        var hook = updateWorkInProgressHook();
        return updateReducerImpl(hook, currentHook, reducer);
      }
      function updateReducerImpl(hook, current, reducer) {
        var queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
        if (null !== pendingQueue) {
          if (null !== baseQueue) {
            var baseFirst = baseQueue.next;
            baseQueue.next = pendingQueue.next;
            pendingQueue.next = baseFirst;
          }
          current.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        pendingQueue = hook.baseState;
        if (null === baseQueue) hook.memoizedState = pendingQueue;
        else {
          current = baseQueue.next;
          var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update3 = current, didReadFromEntangledAsyncAction$32 = false;
          do {
            var updateLane = update3.lane & -536870913;
            if (updateLane !== update3.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
              var revertLane = update3.revertLane;
              if (0 === revertLane)
                null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
                  lane: 0,
                  revertLane: 0,
                  action: update3.action,
                  hasEagerState: update3.hasEagerState,
                  eagerState: update3.eagerState,
                  next: null
                }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
              else if ((renderLanes & revertLane) === revertLane) {
                update3 = update3.next;
                revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction$32 = true);
                continue;
              } else
                updateLane = {
                  lane: 0,
                  revertLane: update3.revertLane,
                  action: update3.action,
                  hasEagerState: update3.hasEagerState,
                  eagerState: update3.eagerState,
                  next: null
                }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
              updateLane = update3.action;
              shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
              pendingQueue = update3.hasEagerState ? update3.eagerState : reducer(pendingQueue, updateLane);
            } else
              revertLane = {
                lane: updateLane,
                revertLane: update3.revertLane,
                action: update3.action,
                hasEagerState: update3.hasEagerState,
                eagerState: update3.eagerState,
                next: null
              }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
            update3 = update3.next;
          } while (null !== update3 && update3 !== current);
          null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
          if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction$32 && (reducer = currentEntangledActionThenable, null !== reducer)))
            throw reducer;
          hook.memoizedState = pendingQueue;
          hook.baseState = baseFirst;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = pendingQueue;
        }
        null === baseQueue && (queue.lanes = 0);
        return [hook.memoizedState, queue.dispatch];
      }
      function rerenderReducer(reducer) {
        var hook = updateWorkInProgressHook(), queue = hook.queue;
        if (null === queue) throw Error(formatProdErrorMessage(311));
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
        if (null !== lastRenderPhaseUpdate) {
          queue.pending = null;
          var update3 = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          do
            newState = reducer(newState, update3.action), update3 = update3.next;
          while (update3 !== lastRenderPhaseUpdate);
          objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
          hook.memoizedState = newState;
          null === hook.baseQueue && (hook.baseState = newState);
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
        if (isHydrating$jscomp$0) {
          if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));
          getServerSnapshot = getServerSnapshot();
        } else getServerSnapshot = getSnapshot();
        var snapshotChanged = !objectIs(
          (currentHook || hook).memoizedState,
          getServerSnapshot
        );
        snapshotChanged && (hook.memoizedState = getServerSnapshot, didReceiveUpdate = true);
        hook = hook.queue;
        var create = subscribeToStore.bind(null, fiber, hook, subscribe);
        updateEffectImpl(2048, 8, create, [subscribe]);
        if (hook.getSnapshot !== getSnapshot || snapshotChanged || null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1) {
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              hook,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));
          isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
        }
        return getServerSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= 16384;
        fiber = { getSnapshot, value: renderedSnapshot };
        getSnapshot = currentlyRenderingFiber.updateQueue;
        null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      }
      function subscribeToStore(fiber, inst, subscribe) {
        return subscribe(function() {
          checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
        });
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root3 = enqueueConcurrentRenderForLane(fiber, 2);
        null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2);
      }
      function mountStateImpl(initialState) {
        var hook = mountWorkInProgressHook();
        if ("function" === typeof initialState) {
          var initialStateInitializer = initialState;
          initialState = initialStateInitializer();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              initialStateInitializer();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        hook.memoizedState = hook.baseState = initialState;
        hook.queue = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        return hook;
      }
      function updateOptimisticImpl(hook, current, passthrough, reducer) {
        hook.baseState = passthrough;
        return updateReducerImpl(
          hook,
          currentHook,
          "function" === typeof reducer ? reducer : basicStateReducer
        );
      }
      function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
        if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));
        fiber = actionQueue.action;
        if (null !== fiber) {
          var actionNode = {
            payload,
            action: fiber,
            next: null,
            isTransition: true,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function(listener) {
              actionNode.listeners.push(listener);
            }
          };
          null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
          setState(actionNode);
          setPendingState = actionQueue.pending;
          null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
        }
      }
      function runActionStateAction(actionQueue, node2) {
        var action = node2.action, payload = node2.payload, prevState = actionQueue.state;
        if (node2.isTransition) {
          var prevTransition = ReactSharedInternals.T, currentTransition = {};
          ReactSharedInternals.T = currentTransition;
          try {
            var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
            null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
            handleActionReturnValue(actionQueue, node2, returnValue);
          } catch (error) {
            onActionError(actionQueue, node2, error);
          } finally {
            ReactSharedInternals.T = prevTransition;
          }
        } else
          try {
            prevTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node2, prevTransition);
          } catch (error$38) {
            onActionError(actionQueue, node2, error$38);
          }
      }
      function handleActionReturnValue(actionQueue, node2, returnValue) {
        null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? returnValue.then(
          function(nextState) {
            onActionSuccess(actionQueue, node2, nextState);
          },
          function(error) {
            return onActionError(actionQueue, node2, error);
          }
        ) : onActionSuccess(actionQueue, node2, returnValue);
      }
      function onActionSuccess(actionQueue, actionNode, nextState) {
        actionNode.status = "fulfilled";
        actionNode.value = nextState;
        notifyActionListeners(actionNode);
        actionQueue.state = nextState;
        actionNode = actionQueue.pending;
        null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
      }
      function onActionError(actionQueue, actionNode, error) {
        var last = actionQueue.pending;
        actionQueue.pending = null;
        if (null !== last) {
          last = last.next;
          do
            actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
          while (actionNode !== last);
        }
        actionQueue.action = null;
      }
      function notifyActionListeners(actionNode) {
        actionNode = actionNode.listeners;
        for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
      }
      function actionStateReducer(oldState, newState) {
        return newState;
      }
      function mountActionState(action, initialStateProp) {
        if (isHydrating) {
          var ssrFormState = workInProgressRoot.formState;
          if (null !== ssrFormState) {
            a: {
              var JSCompiler_inline_result = currentlyRenderingFiber;
              if (isHydrating) {
                if (nextHydratableInstance) {
                  b: {
                    var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;
                    for (var inRootOrSingleton = rootOrSingletonContext; 8 !== JSCompiler_inline_result$jscomp$0.nodeType; ) {
                      if (!inRootOrSingleton) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                      JSCompiler_inline_result$jscomp$0 = getNextHydratable(
                        JSCompiler_inline_result$jscomp$0.nextSibling
                      );
                      if (null === JSCompiler_inline_result$jscomp$0) {
                        JSCompiler_inline_result$jscomp$0 = null;
                        break b;
                      }
                    }
                    inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;
                    JSCompiler_inline_result$jscomp$0 = "F!" === inRootOrSingleton || "F" === inRootOrSingleton ? JSCompiler_inline_result$jscomp$0 : null;
                  }
                  if (JSCompiler_inline_result$jscomp$0) {
                    nextHydratableInstance = getNextHydratable(
                      JSCompiler_inline_result$jscomp$0.nextSibling
                    );
                    JSCompiler_inline_result = "F!" === JSCompiler_inline_result$jscomp$0.data;
                    break a;
                  }
                }
                throwOnHydrationMismatch(JSCompiler_inline_result);
              }
              JSCompiler_inline_result = false;
            }
            JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);
          }
        }
        ssrFormState = mountWorkInProgressHook();
        ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
        JSCompiler_inline_result = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: actionStateReducer,
          lastRenderedState: initialStateProp
        };
        ssrFormState.queue = JSCompiler_inline_result;
        ssrFormState = dispatchSetState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result
        );
        JSCompiler_inline_result.dispatch = ssrFormState;
        JSCompiler_inline_result = mountStateImpl(false);
        inRootOrSingleton = dispatchOptimisticSetState.bind(
          null,
          currentlyRenderingFiber,
          false,
          JSCompiler_inline_result.queue
        );
        JSCompiler_inline_result = mountWorkInProgressHook();
        JSCompiler_inline_result$jscomp$0 = {
          state: initialStateProp,
          dispatch: null,
          action,
          pending: null
        };
        JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;
        ssrFormState = dispatchActionState.bind(
          null,
          currentlyRenderingFiber,
          JSCompiler_inline_result$jscomp$0,
          inRootOrSingleton,
          ssrFormState
        );
        JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;
        JSCompiler_inline_result.memoizedState = action;
        return [initialStateProp, ssrFormState, false];
      }
      function updateActionState(action) {
        var stateHook = updateWorkInProgressHook();
        return updateActionStateImpl(stateHook, currentHook, action);
      }
      function updateActionStateImpl(stateHook, currentStateHook, action) {
        currentStateHook = updateReducerImpl(
          stateHook,
          currentStateHook,
          actionStateReducer
        )[0];
        stateHook = updateReducer(basicStateReducer)[0];
        if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
          try {
            var state = useThenable(currentStateHook);
          } catch (x) {
            if (x === SuspenseException) throw SuspenseActionException;
            throw x;
          }
        else state = currentStateHook;
        currentStateHook = updateWorkInProgressHook();
        var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
        action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
          9,
          createEffectInstance(),
          actionStateActionEffect.bind(null, actionQueue, action),
          null
        ));
        return [state, dispatch, stateHook];
      }
      function actionStateActionEffect(actionQueue, action) {
        actionQueue.action = action;
      }
      function rerenderActionState(action) {
        var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
        if (null !== currentStateHook)
          return updateActionStateImpl(stateHook, currentStateHook, action);
        updateWorkInProgressHook();
        stateHook = stateHook.memoizedState;
        currentStateHook = updateWorkInProgressHook();
        var dispatch = currentStateHook.queue.dispatch;
        currentStateHook.memoizedState = action;
        return [stateHook, dispatch, false];
      }
      function pushSimpleEffect(tag, inst, create, createDeps) {
        tag = { tag, create, deps: createDeps, inst, next: null };
        inst = currentlyRenderingFiber.updateQueue;
        null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
        create = inst.lastEffect;
        null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
        return tag;
      }
      function createEffectInstance() {
        return { destroy: void 0, resource: void 0 };
      }
      function updateRef2() {
        return updateWorkInProgressHook().memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
        var hook = mountWorkInProgressHook();
        createDeps = void 0 === createDeps ? null : createDeps;
        currentlyRenderingFiber.flags |= fiberFlags;
        hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          createEffectInstance(),
          create,
          createDeps
        );
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var inst = hook.memoizedState.inst;
        null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
          1 | hookFlags,
          inst,
          create,
          deps
        ));
      }
      function mountEffect(create, createDeps) {
        mountEffectImpl(8390656, 8, create, createDeps);
      }
      function updateEffect(create, createDeps) {
        updateEffectImpl(2048, 8, create, createDeps);
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(4, 2, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(4, 4, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if ("function" === typeof ref) {
          create = create();
          var refCleanup = ref(create);
          return function() {
            "function" === typeof refCleanup ? refCleanup() : ref(null);
          };
        }
        if (null !== ref && void 0 !== ref)
          return create = create(), ref.current = create, function() {
            ref.current = null;
          };
      }
      function updateImperativeHandle(ref, create, deps) {
        deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
        updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);
      }
      function mountDebugValue() {
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        hook.memoizedState = [callback, deps];
        return callback;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        deps = void 0 === deps ? null : deps;
        var prevState = hook.memoizedState;
        if (null !== deps && areHookInputsEqual(deps, prevState[1]))
          return prevState[0];
        prevState = nextCreate();
        if (shouldDoubleInvokeUserFnsInHooksDEV) {
          setIsStrictModeForDevtools(true);
          try {
            nextCreate();
          } finally {
            setIsStrictModeForDevtools(false);
          }
        }
        hook.memoizedState = [prevState, deps];
        return prevState;
      }
      function mountDeferredValueImpl(hook, value, initialValue) {
        if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
          return hook.memoizedState = value;
        hook.memoizedState = initialValue;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return initialValue;
      }
      function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
        if (objectIs(value, prevValue)) return value;
        if (null !== currentTreeHiddenStackCursor.current)
          return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
        if (0 === (renderLanes & 42))
          return didReceiveUpdate = true, hook.memoizedState = value;
        hook = requestDeferredLane();
        currentlyRenderingFiber.lanes |= hook;
        workInProgressRootSkippedLanes |= hook;
        return prevValue;
      }
      function startTransition(fiber, queue, pendingState, finishedState, callback) {
        var previousPriority = ReactDOMSharedInternals.p;
        ReactDOMSharedInternals.p = 0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        ReactSharedInternals.T = currentTransition;
        dispatchOptimisticSetState(fiber, false, queue, pendingState);
        try {
          var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
            var thenableForFinishedState = chainThenableValue(
              returnValue,
              finishedState
            );
            dispatchSetStateInternal(
              fiber,
              queue,
              thenableForFinishedState,
              requestUpdateLane(fiber)
            );
          } else
            dispatchSetStateInternal(
              fiber,
              queue,
              finishedState,
              requestUpdateLane(fiber)
            );
        } catch (error) {
          dispatchSetStateInternal(
            fiber,
            queue,
            { then: function() {
            }, status: "rejected", reason: error },
            requestUpdateLane()
          );
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function noop$2() {
      }
      function startHostTransition(formFiber, pendingState, action, formData) {
        if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));
        var queue = ensureFormComponentIsStateful(formFiber).queue;
        startTransition(
          formFiber,
          queue,
          pendingState,
          sharedNotPendingObject,
          null === action ? noop$2 : function() {
            requestFormReset$1(formFiber);
            return action(formData);
          }
        );
      }
      function ensureFormComponentIsStateful(formFiber) {
        var existingStateHook = formFiber.memoizedState;
        if (null !== existingStateHook) return existingStateHook;
        existingStateHook = {
          memoizedState: sharedNotPendingObject,
          baseState: sharedNotPendingObject,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: sharedNotPendingObject
          },
          next: null
        };
        var initialResetState = {};
        existingStateHook.next = {
          memoizedState: initialResetState,
          baseState: initialResetState,
          baseQueue: null,
          queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: basicStateReducer,
            lastRenderedState: initialResetState
          },
          next: null
        };
        formFiber.memoizedState = existingStateHook;
        formFiber = formFiber.alternate;
        null !== formFiber && (formFiber.memoizedState = existingStateHook);
        return existingStateHook;
      }
      function requestFormReset$1(formFiber) {
        var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
        dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());
      }
      function useHostTransitionStatus() {
        return readContext(HostTransitionContext);
      }
      function updateId() {
        return updateWorkInProgressHook().memoizedState;
      }
      function updateRefresh() {
        return updateWorkInProgressHook().memoizedState;
      }
      function refreshCache(fiber) {
        for (var provider = fiber.return; null !== provider; ) {
          switch (provider.tag) {
            case 24:
            case 3:
              var lane = requestUpdateLane();
              fiber = createUpdate2(lane);
              var root$41 = enqueueUpdate(provider, fiber, lane);
              null !== root$41 && (scheduleUpdateOnFiber(root$41, provider, lane), entangleTransitions(root$41, provider, lane));
              provider = { cache: createCache3() };
              fiber.payload = provider;
              return;
          }
          provider = provider.return;
        }
      }
      function dispatchReducerAction(fiber, queue, action) {
        var lane = requestUpdateLane();
        action = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, action) : (action = enqueueConcurrentHookUpdate(fiber, queue, action, lane), null !== action && (scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane)));
      }
      function dispatchSetState(fiber, queue, action) {
        var lane = requestUpdateLane();
        dispatchSetStateInternal(fiber, queue, action, lane);
      }
      function dispatchSetStateInternal(fiber, queue, action, lane) {
        var update3 = {
          lane,
          revertLane: 0,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update3);
        else {
          var alternate = fiber.alternate;
          if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate))
            try {
              var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
              update3.hasEagerState = true;
              update3.eagerState = eagerState;
              if (objectIs(eagerState, currentState))
                return enqueueUpdate$1(fiber, queue, update3, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
            } catch (error) {
            } finally {
            }
          action = enqueueConcurrentHookUpdate(fiber, queue, update3, lane);
          if (null !== action)
            return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
        }
        return false;
      }
      function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
        action = {
          lane: 2,
          revertLane: requestTransitionLane(),
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));
        } else
          throwIfDuringRender = enqueueConcurrentHookUpdate(
            fiber,
            queue,
            action,
            2
          ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
      }
      function enqueueRenderPhaseUpdate(queue, update3) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        null === pending ? update3.next = update3 : (update3.next = pending.next, pending.next = update3);
        queue.pending = update3;
      }
      function entangleTransitionUpdate(root3, queue, lane) {
        if (0 !== (lane & 4194048)) {
          var queueLanes = queue.lanes;
          queueLanes &= root3.pendingLanes;
          lane |= queueLanes;
          queue.lanes = lane;
          markRootEntangled(root3, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        use,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        useHostTransitionStatus: throwInvalidHookError,
        useFormState: throwInvalidHookError,
        useActionState: throwInvalidHookError,
        useOptimistic: throwInvalidHookError,
        useMemoCache: throwInvalidHookError,
        useCacheRefresh: throwInvalidHookError
      };
      var HooksDispatcherOnMount = {
        readContext,
        use,
        useCallback: function(callback, deps) {
          mountWorkInProgressHook().memoizedState = [
            callback,
            void 0 === deps ? null : deps
          ];
          return callback;
        },
        useContext: readContext,
        useEffect: mountEffect,
        useImperativeHandle: function(ref, create, deps) {
          deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
          mountEffectImpl(
            4194308,
            4,
            imperativeHandleEffect.bind(null, create, ref),
            deps
          );
        },
        useLayoutEffect: function(create, deps) {
          return mountEffectImpl(4194308, 4, create, deps);
        },
        useInsertionEffect: function(create, deps) {
          mountEffectImpl(4, 2, create, deps);
        },
        useMemo: function(nextCreate, deps) {
          var hook = mountWorkInProgressHook();
          deps = void 0 === deps ? null : deps;
          var nextValue = nextCreate();
          if (shouldDoubleInvokeUserFnsInHooksDEV) {
            setIsStrictModeForDevtools(true);
            try {
              nextCreate();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          hook.memoizedState = [nextValue, deps];
          return nextValue;
        },
        useReducer: function(reducer, initialArg, init) {
          var hook = mountWorkInProgressHook();
          if (void 0 !== init) {
            var initialState = init(initialArg);
            if (shouldDoubleInvokeUserFnsInHooksDEV) {
              setIsStrictModeForDevtools(true);
              try {
                init(initialArg);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          } else initialState = initialArg;
          hook.memoizedState = hook.baseState = initialState;
          reducer = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: reducer,
            lastRenderedState: initialState
          };
          hook.queue = reducer;
          reducer = reducer.dispatch = dispatchReducerAction.bind(
            null,
            currentlyRenderingFiber,
            reducer
          );
          return [hook.memoizedState, reducer];
        },
        useRef: function(initialValue) {
          var hook = mountWorkInProgressHook();
          initialValue = { current: initialValue };
          return hook.memoizedState = initialValue;
        },
        useState: function(initialState) {
          initialState = mountStateImpl(initialState);
          var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
          queue.dispatch = dispatch;
          return [initialState.memoizedState, dispatch];
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = mountWorkInProgressHook();
          return mountDeferredValueImpl(hook, value, initialValue);
        },
        useTransition: function() {
          var stateHook = mountStateImpl(false);
          stateHook = startTransition.bind(
            null,
            currentlyRenderingFiber,
            stateHook.queue,
            true,
            false
          );
          mountWorkInProgressHook().memoizedState = stateHook;
          return [false, stateHook];
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
          var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
          if (isHydrating) {
            if (void 0 === getServerSnapshot)
              throw Error(formatProdErrorMessage(407));
            getServerSnapshot = getServerSnapshot();
          } else {
            getServerSnapshot = getSnapshot();
            if (null === workInProgressRoot)
              throw Error(formatProdErrorMessage(349));
            0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
          }
          hook.memoizedState = getServerSnapshot;
          var inst = { value: getServerSnapshot, getSnapshot };
          hook.queue = inst;
          mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [
            subscribe
          ]);
          fiber.flags |= 2048;
          pushSimpleEffect(
            9,
            createEffectInstance(),
            updateStoreInstance.bind(
              null,
              fiber,
              inst,
              getServerSnapshot,
              getSnapshot
            ),
            null
          );
          return getServerSnapshot;
        },
        useId: function() {
          var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
          if (isHydrating) {
            var JSCompiler_inline_result = treeContextOverflow;
            var idWithLeadingBit = treeContextId;
            JSCompiler_inline_result = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + JSCompiler_inline_result;
            identifierPrefix = "\xAB" + identifierPrefix + "R" + JSCompiler_inline_result;
            JSCompiler_inline_result = localIdCounter++;
            0 < JSCompiler_inline_result && (identifierPrefix += "H" + JSCompiler_inline_result.toString(32));
            identifierPrefix += "\xBB";
          } else
            JSCompiler_inline_result = globalClientIdCounter++, identifierPrefix = "\xAB" + identifierPrefix + "r" + JSCompiler_inline_result.toString(32) + "\xBB";
          return hook.memoizedState = identifierPrefix;
        },
        useHostTransitionStatus,
        useFormState: mountActionState,
        useActionState: mountActionState,
        useOptimistic: function(passthrough) {
          var hook = mountWorkInProgressHook();
          hook.memoizedState = hook.baseState = passthrough;
          var queue = {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: null,
            lastRenderedState: null
          };
          hook.queue = queue;
          hook = dispatchOptimisticSetState.bind(
            null,
            currentlyRenderingFiber,
            true,
            queue
          );
          queue.dispatch = hook;
          return [passthrough, hook];
        },
        useMemoCache,
        useCacheRefresh: function() {
          return mountWorkInProgressHook().memoizedState = refreshCache.bind(
            null,
            currentlyRenderingFiber
          );
        }
      };
      var HooksDispatcherOnUpdate = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: updateReducer,
        useRef: updateRef2,
        useState: function() {
          return updateReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = updateReducer(basicStateReducer)[0], start3 = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start3
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: updateActionState,
        useActionState: updateActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      var HooksDispatcherOnRerender = {
        readContext,
        use,
        useCallback: updateCallback,
        useContext: readContext,
        useEffect: updateEffect,
        useImperativeHandle: updateImperativeHandle,
        useInsertionEffect: updateInsertionEffect,
        useLayoutEffect: updateLayoutEffect,
        useMemo: updateMemo,
        useReducer: rerenderReducer,
        useRef: updateRef2,
        useState: function() {
          return rerenderReducer(basicStateReducer);
        },
        useDebugValue: mountDebugValue,
        useDeferredValue: function(value, initialValue) {
          var hook = updateWorkInProgressHook();
          return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
            hook,
            currentHook.memoizedState,
            value,
            initialValue
          );
        },
        useTransition: function() {
          var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start3 = updateWorkInProgressHook().memoizedState;
          return [
            "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
            start3
          ];
        },
        useSyncExternalStore: updateSyncExternalStore,
        useId: updateId,
        useHostTransitionStatus,
        useFormState: rerenderActionState,
        useActionState: rerenderActionState,
        useOptimistic: function(passthrough, reducer) {
          var hook = updateWorkInProgressHook();
          if (null !== currentHook)
            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
          hook.baseState = passthrough;
          return [passthrough, hook.queue.dispatch];
        },
        useMemoCache,
        useCacheRefresh: updateRefresh
      };
      var thenableState = null;
      var thenableIndexCounter = 0;
      function unwrapThenable(thenable) {
        var index2 = thenableIndexCounter;
        thenableIndexCounter += 1;
        null === thenableState && (thenableState = []);
        return trackUsedThenable(thenableState, thenable, index2);
      }
      function coerceRef(workInProgress2, element) {
        element = element.props.ref;
        workInProgress2.ref = void 0 !== element ? element : null;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
          throw Error(formatProdErrorMessage(525));
        returnFiber = Object.prototype.toString.call(newChild);
        throw Error(
          formatProdErrorMessage(
            31,
            "[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber
          )
        );
      }
      function resolveLazy(lazyType) {
        var init = lazyType._init;
        return init(lazyType._payload);
      }
      function createChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (shouldTrackSideEffects) {
            var deletions = returnFiber.deletions;
            null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) return null;
          for (; null !== currentFirstChild; )
            deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return null;
        }
        function mapRemainingChildren(currentFirstChild) {
          for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
            null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          fiber = createWorkInProgress(fiber, pendingProps);
          fiber.index = 0;
          fiber.sibling = null;
          return fiber;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects)
            return newFiber.flags |= 1048576, lastPlacedIndex;
          newIndex = newFiber.alternate;
          if (null !== newIndex)
            return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
          newFiber.flags |= 67108866;
          return lastPlacedIndex;
        }
        function placeSingleChild(newFiber) {
          shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
          return newFiber;
        }
        function updateTextNode(returnFiber, current, textContent, lanes) {
          if (null === current || 6 !== current.tag)
            return current = createFiberFromText(textContent, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, textContent);
          current.return = returnFiber;
          return current;
        }
        function updateElement(returnFiber, current, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE)
            return updateFragment(
              returnFiber,
              current,
              element.props.children,
              lanes,
              element.key
            );
          if (null !== current && (current.elementType === elementType || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type))
            return current = useFiber(current, element.props), coerceRef(current, element), current.return = returnFiber, current;
          current = createFiberFromTypeAndProps(
            element.type,
            element.key,
            element.props,
            null,
            returnFiber.mode,
            lanes
          );
          coerceRef(current, element);
          current.return = returnFiber;
          return current;
        }
        function updatePortal(returnFiber, current, portal, lanes) {
          if (null === current || 4 !== current.tag || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation)
            return current = createFiberFromPortal(portal, returnFiber.mode, lanes), current.return = returnFiber, current;
          current = useFiber(current, portal.children || []);
          current.return = returnFiber;
          return current;
        }
        function updateFragment(returnFiber, current, fragment, lanes, key) {
          if (null === current || 7 !== current.tag)
            return current = createFiberFromFragment(
              fragment,
              returnFiber.mode,
              lanes,
              key
            ), current.return = returnFiber, current;
          current = useFiber(current, fragment);
          current.return = returnFiber;
          return current;
        }
        function createChild(returnFiber, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return newChild = createFiberFromText(
              "" + newChild,
              returnFiber.mode,
              lanes
            ), newChild.return = returnFiber, newChild;
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return lanes = createFiberFromTypeAndProps(
                  newChild.type,
                  newChild.key,
                  newChild.props,
                  null,
                  returnFiber.mode,
                  lanes
                ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes;
              case REACT_PORTAL_TYPE:
                return newChild = createFiberFromPortal(
                  newChild,
                  returnFiber.mode,
                  lanes
                ), newChild.return = returnFiber, newChild;
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return createChild(returnFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return newChild = createFiberFromFragment(
                newChild,
                returnFiber.mode,
                lanes,
                null
              ), newChild.return = returnFiber, newChild;
            if ("function" === typeof newChild.then)
              return createChild(returnFiber, unwrapThenable(newChild), lanes);
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return createChild(
                returnFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = null !== oldFiber ? oldFiber.key : null;
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return newChild.key === key ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_PORTAL_TYPE:
                return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), updateSlot(returnFiber, oldFiber, newChild, lanes);
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return null !== key ? null : updateFragment(returnFiber, oldFiber, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateSlot(
                returnFiber,
                oldFiber,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateSlot(
                returnFiber,
                oldFiber,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
            return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updateElement(returnFiber, existingChildren, newChild, lanes);
              case REACT_PORTAL_TYPE:
                return existingChildren = existingChildren.get(
                  null === newChild.key ? newIdx : newChild.key
                ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
              case REACT_LAZY_TYPE:
                var init = newChild._init;
                newChild = init(newChild._payload);
                return updateFromMap(
                  existingChildren,
                  returnFiber,
                  newIdx,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild) || getIteratorFn(newChild))
              return existingChildren = existingChildren.get(newIdx) || null, updateFragment(returnFiber, existingChildren, newChild, lanes, null);
            if ("function" === typeof newChild.then)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return updateFromMap(
                existingChildren,
                returnFiber,
                newIdx,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return null;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(
              returnFiber,
              oldFiber,
              newChildren[newIdx],
              lanes
            );
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; newIdx < newChildren.length; newIdx++)
              oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (currentFirstChild = placeChild(
                oldFiber,
                currentFirstChild,
                newIdx
              ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
            nextOldFiber = updateFromMap(
              oldFiber,
              returnFiber,
              newIdx,
              newChildren[newIdx],
              lanes
            ), null !== nextOldFiber && (shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
              null === nextOldFiber.key ? newIdx : nextOldFiber.key
            ), currentFirstChild = placeChild(
              nextOldFiber,
              currentFirstChild,
              newIdx
            ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
          if (null == newChildren) throw Error(formatProdErrorMessage(151));
          for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
            oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (null === newFiber) {
              null === oldFiber && (oldFiber = nextOldFiber);
              break;
            }
            shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
            currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
            null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done)
            return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
          if (null === oldFiber) {
            for (; !step.done; newIdx++, step = newChildren.next())
              step = createChild(returnFiber, step.value, lanes), null !== step && (currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
            isHydrating && pushTreeFork(returnFiber, newIdx);
            return resultingFirstChild;
          }
          for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
            step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes), null !== step && (shouldTrackSideEffects && null !== step.alternate && oldFiber.delete(null === step.key ? newIdx : step.key), currentFirstChild = placeChild(step, currentFirstChild, newIdx), null === previousNewFiber ? resultingFirstChild = step : previousNewFiber.sibling = step, previousNewFiber = step);
          shouldTrackSideEffects && oldFiber.forEach(function(child) {
            return deleteChild(returnFiber, child);
          });
          isHydrating && pushTreeFork(returnFiber, newIdx);
          return resultingFirstChild;
        }
        function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
          "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (newChild = newChild.props.children);
          if ("object" === typeof newChild && null !== newChild) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                a: {
                  for (var key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key) {
                      key = newChild.type;
                      if (key === REACT_FRAGMENT_TYPE) {
                        if (7 === currentFirstChild.tag) {
                          deleteRemainingChildren(
                            returnFiber,
                            currentFirstChild.sibling
                          );
                          lanes = useFiber(
                            currentFirstChild,
                            newChild.props.children
                          );
                          lanes.return = returnFiber;
                          returnFiber = lanes;
                          break a;
                        }
                      } else if (currentFirstChild.elementType === key || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && resolveLazy(key) === currentFirstChild.type) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.props);
                        coerceRef(lanes, newChild);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      }
                      deleteRemainingChildren(returnFiber, currentFirstChild);
                      break;
                    } else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
                    newChild.props.children,
                    returnFiber.mode,
                    lanes,
                    newChild.key
                  ), lanes.return = returnFiber, returnFiber = lanes) : (lanes = createFiberFromTypeAndProps(
                    newChild.type,
                    newChild.key,
                    newChild.props,
                    null,
                    returnFiber.mode,
                    lanes
                  ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = lanes);
                }
                return placeSingleChild(returnFiber);
              case REACT_PORTAL_TYPE:
                a: {
                  for (key = newChild.key; null !== currentFirstChild; ) {
                    if (currentFirstChild.key === key)
                      if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === newChild.containerInfo && currentFirstChild.stateNode.implementation === newChild.implementation) {
                        deleteRemainingChildren(
                          returnFiber,
                          currentFirstChild.sibling
                        );
                        lanes = useFiber(currentFirstChild, newChild.children || []);
                        lanes.return = returnFiber;
                        returnFiber = lanes;
                        break a;
                      } else {
                        deleteRemainingChildren(returnFiber, currentFirstChild);
                        break;
                      }
                    else deleteChild(returnFiber, currentFirstChild);
                    currentFirstChild = currentFirstChild.sibling;
                  }
                  lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                  lanes.return = returnFiber;
                  returnFiber = lanes;
                }
                return placeSingleChild(returnFiber);
              case REACT_LAZY_TYPE:
                return key = newChild._init, newChild = key(newChild._payload), reconcileChildFibersImpl(
                  returnFiber,
                  currentFirstChild,
                  newChild,
                  lanes
                );
            }
            if (isArrayImpl(newChild))
              return reconcileChildrenArray(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            if (getIteratorFn(newChild)) {
              key = getIteratorFn(newChild);
              if ("function" !== typeof key) throw Error(formatProdErrorMessage(150));
              newChild = key.call(newChild);
              return reconcileChildrenIterator(
                returnFiber,
                currentFirstChild,
                newChild,
                lanes
              );
            }
            if ("function" === typeof newChild.then)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                unwrapThenable(newChild),
                lanes
              );
            if (newChild.$$typeof === REACT_CONTEXT_TYPE)
              return reconcileChildFibersImpl(
                returnFiber,
                currentFirstChild,
                readContextDuringReconciliation(returnFiber, newChild),
                lanes
              );
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          return "string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild ? (newChild = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling), lanes = useFiber(currentFirstChild, newChild), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(newChild, returnFiber.mode, lanes), lanes.return = returnFiber, returnFiber = lanes), placeSingleChild(returnFiber)) : deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return function(returnFiber, currentFirstChild, newChild, lanes) {
          try {
            thenableIndexCounter = 0;
            var firstChildFiber = reconcileChildFibersImpl(
              returnFiber,
              currentFirstChild,
              newChild,
              lanes
            );
            thenableState = null;
            return firstChildFiber;
          } catch (x) {
            if (x === SuspenseException || x === SuspenseActionException) throw x;
            var fiber = createFiberImplClass(29, x, null, returnFiber.mode);
            fiber.lanes = lanes;
            fiber.return = returnFiber;
            return fiber;
          } finally {
          }
        };
      }
      var reconcileChildFibers = createChildReconciler(true);
      var mountChildFibers = createChildReconciler(false);
      var suspenseHandlerStackCursor = createCursor(null);
      var shellBoundary = null;
      function pushPrimaryTreeSuspenseHandler(handler) {
        var current = handler.alternate;
        push(suspenseStackCursor, suspenseStackCursor.current & 1);
        push(suspenseHandlerStackCursor, handler);
        null === shellBoundary && (null === current || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current.memoizedState && (shellBoundary = handler));
      }
      function pushOffscreenSuspenseHandler(fiber) {
        if (22 === fiber.tag) {
          if (push(suspenseStackCursor, suspenseStackCursor.current), push(suspenseHandlerStackCursor, fiber), null === shellBoundary) {
            var current = fiber.alternate;
            null !== current && null !== current.memoizedState && (shellBoundary = fiber);
          }
        } else reuseSuspenseHandlerOnStack(fiber);
      }
      function reuseSuspenseHandlerOnStack() {
        push(suspenseStackCursor, suspenseStackCursor.current);
        push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);
      }
      function popSuspenseHandler(fiber) {
        pop(suspenseHandlerStackCursor);
        shellBoundary === fiber && (shellBoundary = null);
        pop(suspenseStackCursor);
      }
      var suspenseStackCursor = createCursor(0);
      function findFirstSuspended(row) {
        for (var node2 = row; null !== node2; ) {
          if (13 === node2.tag) {
            var state = node2.memoizedState;
            if (null !== state && (state = state.dehydrated, null === state || "$?" === state.data || isSuspenseInstanceFallback(state)))
              return node2;
          } else if (19 === node2.tag && void 0 !== node2.memoizedProps.revealOrder) {
            if (0 !== (node2.flags & 128)) return node2;
          } else if (null !== node2.child) {
            node2.child.return = node2;
            node2 = node2.child;
            continue;
          }
          if (node2 === row) break;
          for (; null === node2.sibling; ) {
            if (null === node2.return || node2.return === row) return null;
            node2 = node2.return;
          }
          node2.sibling.return = node2.return;
          node2 = node2.sibling;
        }
        return null;
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        ctor = workInProgress2.memoizedState;
        getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);
        getDerivedStateFromProps = null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps ? ctor : assign3({}, ctor, getDerivedStateFromProps);
        workInProgress2.memoizedState = getDerivedStateFromProps;
        0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = getDerivedStateFromProps);
      }
      var classComponentUpdater = {
        enqueueSetState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update3 = createUpdate2(lane);
          update3.payload = payload;
          void 0 !== callback && null !== callback && (update3.callback = callback);
          payload = enqueueUpdate(inst, update3, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueReplaceState: function(inst, payload, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update3 = createUpdate2(lane);
          update3.tag = 1;
          update3.payload = payload;
          void 0 !== callback && null !== callback && (update3.callback = callback);
          payload = enqueueUpdate(inst, update3, lane);
          null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
        },
        enqueueForceUpdate: function(inst, callback) {
          inst = inst._reactInternals;
          var lane = requestUpdateLane(), update3 = createUpdate2(lane);
          update3.tag = 2;
          void 0 !== callback && null !== callback && (update3.callback = callback);
          callback = enqueueUpdate(inst, update3, lane);
          null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        workInProgress2 = workInProgress2.stateNode;
        return "function" === typeof workInProgress2.shouldComponentUpdate ? workInProgress2.shouldComponentUpdate(newProps, newState, nextContext) : ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
      }
      function callComponentWillReceiveProps(workInProgress2, instance2, newProps, nextContext) {
        workInProgress2 = instance2.state;
        "function" === typeof instance2.componentWillReceiveProps && instance2.componentWillReceiveProps(newProps, nextContext);
        "function" === typeof instance2.UNSAFE_componentWillReceiveProps && instance2.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        instance2.state !== workInProgress2 && classComponentUpdater.enqueueReplaceState(instance2, instance2.state, null);
      }
      function resolveClassComponentProps(Component, baseProps) {
        var newProps = baseProps;
        if ("ref" in baseProps) {
          newProps = {};
          for (var propName in baseProps)
            "ref" !== propName && (newProps[propName] = baseProps[propName]);
        }
        if (Component = Component.defaultProps) {
          newProps === baseProps && (newProps = assign3({}, newProps));
          for (var propName$73 in Component)
            void 0 === newProps[propName$73] && (newProps[propName$73] = Component[propName$73]);
        }
        return newProps;
      }
      var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
            error
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error);
          return;
        }
        console.error(error);
      };
      function defaultOnUncaughtError(error) {
        reportGlobalError(error);
      }
      function defaultOnCaughtError(error) {
        console.error(error);
      }
      function defaultOnRecoverableError(error) {
        reportGlobalError(error);
      }
      function logUncaughtError(root3, errorInfo) {
        try {
          var onUncaughtError = root3.onUncaughtError;
          onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });
        } catch (e$74) {
          setTimeout(function() {
            throw e$74;
          });
        }
      }
      function logCaughtError(root3, boundary, errorInfo) {
        try {
          var onCaughtError = root3.onCaughtError;
          onCaughtError(errorInfo.value, {
            componentStack: errorInfo.stack,
            errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
          });
        } catch (e$75) {
          setTimeout(function() {
            throw e$75;
          });
        }
      }
      function createRootErrorUpdate(root3, errorInfo, lane) {
        lane = createUpdate2(lane);
        lane.tag = 3;
        lane.payload = { element: null };
        lane.callback = function() {
          logUncaughtError(root3, errorInfo);
        };
        return lane;
      }
      function createClassErrorUpdate(lane) {
        lane = createUpdate2(lane);
        lane.tag = 3;
        return lane;
      }
      function initializeClassErrorUpdate(update3, root3, fiber, errorInfo) {
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if ("function" === typeof getDerivedStateFromError) {
          var error = errorInfo.value;
          update3.payload = function() {
            return getDerivedStateFromError(error);
          };
          update3.callback = function() {
            logCaughtError(root3, fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        null !== inst && "function" === typeof inst.componentDidCatch && (update3.callback = function() {
          logCaughtError(root3, fiber, errorInfo);
          "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
          var stack = errorInfo.stack;
          this.componentDidCatch(errorInfo.value, {
            componentStack: null !== stack ? stack : ""
          });
        });
      }
      function throwException(root3, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= 32768;
        if (null !== value && "object" === typeof value && "function" === typeof value.then) {
          returnFiber = sourceFiber.alternate;
          null !== returnFiber && propagateParentContextChanges(
            returnFiber,
            sourceFiber,
            rootRenderLanes,
            true
          );
          sourceFiber = suspenseHandlerStackCursor.current;
          if (null !== sourceFiber) {
            switch (sourceFiber.tag) {
              case 13:
                return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && 0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 3), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root3, value, rootRenderLanes)), false;
              case 22:
                return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
                  transitions: null,
                  markerInstances: null,
                  retryQueue: /* @__PURE__ */ new Set([value])
                }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root3, value, rootRenderLanes)), false;
            }
            throw Error(formatProdErrorMessage(435, sourceFiber.tag));
          }
          attachPingListener(root3, value, rootRenderLanes);
          renderDidSuspendDelayIfPossible();
          return false;
        }
        if (isHydrating)
          return returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && (root3 = Error(formatProdErrorMessage(422), { cause: value }), queueHydrationError(createCapturedValueAtFiber(root3, sourceFiber)))) : (value !== HydrationMismatchException && (returnFiber = Error(formatProdErrorMessage(423), {
            cause: value
          }), queueHydrationError(
            createCapturedValueAtFiber(returnFiber, sourceFiber)
          )), root3 = root3.current.alternate, root3.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root3.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
            root3.stateNode,
            value,
            rootRenderLanes
          ), enqueueCapturedUpdate(root3, rootRenderLanes), 4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2)), false;
        var wrapperError = Error(formatProdErrorMessage(520), { cause: value });
        wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);
        null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [wrapperError] : workInProgressRootConcurrentErrors.push(wrapperError);
        4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);
        if (null === returnFiber) return true;
        value = createCapturedValueAtFiber(value, sourceFiber);
        sourceFiber = returnFiber;
        do {
          switch (sourceFiber.tag) {
            case 3:
              return sourceFiber.flags |= 65536, root3 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root3, root3 = createRootErrorUpdate(sourceFiber.stateNode, value, root3), enqueueCapturedUpdate(sourceFiber, root3), false;
            case 1:
              if (returnFiber = sourceFiber.type, wrapperError = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== wrapperError && "function" === typeof wrapperError.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError))))
                return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
                  rootRenderLanes,
                  root3,
                  sourceFiber,
                  value
                ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
          }
          sourceFiber = sourceFiber.return;
        } while (null !== sourceFiber);
        return false;
      }
      var SelectiveHydrationException = Error(formatProdErrorMessage(461));
      var didReceiveUpdate = false;
      function reconcileChildren(current, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = null === current ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
          workInProgress2,
          current.child,
          nextChildren,
          renderLanes2
        );
      }
      function updateForwardRef(current, workInProgress2, Component, nextProps, renderLanes2) {
        Component = Component.render;
        var ref = workInProgress2.ref;
        if ("ref" in nextProps) {
          var propsWithoutRef = {};
          for (var key in nextProps)
            "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
        } else propsWithoutRef = nextProps;
        prepareToReadContext(workInProgress2);
        nextProps = renderWithHooks(
          current,
          workInProgress2,
          Component,
          propsWithoutRef,
          ref,
          renderLanes2
        );
        key = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && key && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null === current) {
          var type = Component.type;
          if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
            return workInProgress2.tag = 15, workInProgress2.type = type, updateSimpleMemoComponent(
              current,
              workInProgress2,
              type,
              nextProps,
              renderLanes2
            );
          current = createFiberFromTypeAndProps(
            Component.type,
            null,
            nextProps,
            workInProgress2,
            workInProgress2.mode,
            renderLanes2
          );
          current.ref = workInProgress2.ref;
          current.return = workInProgress2;
          return workInProgress2.child = current;
        }
        type = current.child;
        if (!checkScheduledUpdateOrContext(current, renderLanes2)) {
          var prevProps = type.memoizedProps;
          Component = Component.compare;
          Component = null !== Component ? Component : shallowEqual;
          if (Component(prevProps, nextProps) && current.ref === workInProgress2.ref)
            return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        workInProgress2.flags |= 1;
        current = createWorkInProgress(type, nextProps);
        current.ref = workInProgress2.ref;
        current.return = workInProgress2;
        return workInProgress2.child = current;
      }
      function updateSimpleMemoComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        if (null !== current) {
          var prevProps = current.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress2.ref)
            if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current, renderLanes2))
              0 !== (current.flags & 131072) && (didReceiveUpdate = true);
            else
              return workInProgress2.lanes = current.lanes, bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        }
        return updateFunctionComponent(
          current,
          workInProgress2,
          Component,
          nextProps,
          renderLanes2
        );
      }
      function updateOffscreenComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current ? current.memoizedState : null;
        if ("hidden" === nextProps.mode) {
          if (0 !== (workInProgress2.flags & 128)) {
            nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
            if (null !== current) {
              nextChildren = workInProgress2.child = current.child;
              for (prevState = 0; null !== nextChildren; )
                prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
              workInProgress2.childLanes = prevState & ~nextProps;
            } else workInProgress2.childLanes = 0, workInProgress2.child = null;
            return deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              nextProps,
              renderLanes2
            );
          }
          if (0 !== (renderLanes2 & 536870912))
            workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current && pushTransition(
              workInProgress2,
              null !== prevState ? prevState.cachePool : null
            ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(), pushOffscreenSuspenseHandler(workInProgress2);
          else
            return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
              current,
              workInProgress2,
              null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
              renderLanes2
            );
        } else
          null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(), reuseSuspenseHandlerOnStack(workInProgress2));
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function deferHiddenOffscreenComponent(current, workInProgress2, nextBaseLanes, renderLanes2) {
        var JSCompiler_inline_result = peekCacheFromPool();
        JSCompiler_inline_result = null === JSCompiler_inline_result ? null : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };
        workInProgress2.memoizedState = {
          baseLanes: nextBaseLanes,
          cachePool: JSCompiler_inline_result
        };
        null !== current && pushTransition(workInProgress2, null);
        reuseHiddenContextOnStack();
        pushOffscreenSuspenseHandler(workInProgress2);
        null !== current && propagateParentContextChanges(current, workInProgress2, renderLanes2, true);
        return null;
      }
      function markRef(current, workInProgress2) {
        var ref = workInProgress2.ref;
        if (null === ref)
          null !== current && null !== current.ref && (workInProgress2.flags |= 4194816);
        else {
          if ("function" !== typeof ref && "object" !== typeof ref)
            throw Error(formatProdErrorMessage(284));
          if (null === current || current.ref !== ref)
            workInProgress2.flags |= 4194816;
        }
      }
      function updateFunctionComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        Component = renderWithHooks(
          current,
          workInProgress2,
          Component,
          nextProps,
          void 0,
          renderLanes2
        );
        nextProps = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, Component, renderLanes2);
        return workInProgress2.child;
      }
      function replayFunctionComponent(current, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
        prepareToReadContext(workInProgress2);
        workInProgress2.updateQueue = null;
        nextProps = renderWithHooksAgain(
          workInProgress2,
          Component,
          nextProps,
          secondArg
        );
        finishRenderingHooks(current);
        Component = checkDidRenderIdHook();
        if (null !== current && !didReceiveUpdate)
          return bailoutHooks(current, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
        isHydrating && Component && pushMaterializedTreeId(workInProgress2);
        workInProgress2.flags |= 1;
        reconcileChildren(current, workInProgress2, nextProps, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current, workInProgress2, Component, nextProps, renderLanes2) {
        prepareToReadContext(workInProgress2);
        if (null === workInProgress2.stateNode) {
          var context = emptyContextObject, contextType = Component.contextType;
          "object" === typeof contextType && null !== contextType && (context = readContext(contextType));
          context = new Component(nextProps, context);
          workInProgress2.memoizedState = null !== context.state && void 0 !== context.state ? context.state : null;
          context.updater = classComponentUpdater;
          workInProgress2.stateNode = context;
          context._reactInternals = workInProgress2;
          context = workInProgress2.stateNode;
          context.props = nextProps;
          context.state = workInProgress2.memoizedState;
          context.refs = {};
          initializeUpdateQueue(workInProgress2);
          contextType = Component.contextType;
          context.context = "object" === typeof contextType && null !== contextType ? readContext(contextType) : emptyContextObject;
          context.state = workInProgress2.memoizedState;
          contextType = Component.getDerivedStateFromProps;
          "function" === typeof contextType && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            contextType,
            nextProps
          ), context.state = workInProgress2.memoizedState);
          "function" === typeof Component.getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || (contextType = context.state, "function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount(), contextType !== context.state && classComponentUpdater.enqueueReplaceState(context, context.state, null), processUpdateQueue(workInProgress2, nextProps, context, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), context.state = workInProgress2.memoizedState);
          "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308);
          nextProps = true;
        } else if (null === current) {
          context = workInProgress2.stateNode;
          var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = resolveClassComponentProps(Component, unresolvedOldProps);
          context.props = oldProps;
          var oldContext = context.context, contextType$jscomp$0 = Component.contextType;
          contextType = emptyContextObject;
          "object" === typeof contextType$jscomp$0 && null !== contextType$jscomp$0 && (contextType = readContext(contextType$jscomp$0));
          var getDerivedStateFromProps = Component.getDerivedStateFromProps;
          contextType$jscomp$0 = "function" === typeof getDerivedStateFromProps || "function" === typeof context.getSnapshotBeforeUpdate;
          unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
          contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (unresolvedOldProps || oldContext !== contextType) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            contextType
          );
          hasForceUpdate = false;
          var oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          oldContext = workInProgress2.memoizedState;
          unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof getDerivedStateFromProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            getDerivedStateFromProps,
            nextProps
          ), oldContext = workInProgress2.memoizedState), (oldProps = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            oldProps,
            nextProps,
            oldState,
            oldContext,
            contextType
          )) ? (contextType$jscomp$0 || "function" !== typeof context.UNSAFE_componentWillMount && "function" !== typeof context.componentWillMount || ("function" === typeof context.componentWillMount && context.componentWillMount(), "function" === typeof context.UNSAFE_componentWillMount && context.UNSAFE_componentWillMount()), "function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308)) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), context.props = nextProps, context.state = oldContext, context.context = contextType, nextProps = oldProps) : ("function" === typeof context.componentDidMount && (workInProgress2.flags |= 4194308), nextProps = false);
        } else {
          context = workInProgress2.stateNode;
          cloneUpdateQueue(current, workInProgress2);
          contextType = workInProgress2.memoizedProps;
          contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);
          context.props = contextType$jscomp$0;
          getDerivedStateFromProps = workInProgress2.pendingProps;
          oldState = context.context;
          oldContext = Component.contextType;
          oldProps = emptyContextObject;
          "object" === typeof oldContext && null !== oldContext && (oldProps = readContext(oldContext));
          unresolvedOldProps = Component.getDerivedStateFromProps;
          (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof context.getSnapshotBeforeUpdate) || "function" !== typeof context.UNSAFE_componentWillReceiveProps && "function" !== typeof context.componentWillReceiveProps || (contextType !== getDerivedStateFromProps || oldState !== oldProps) && callComponentWillReceiveProps(
            workInProgress2,
            context,
            nextProps,
            oldProps
          );
          hasForceUpdate = false;
          oldState = workInProgress2.memoizedState;
          context.state = oldState;
          processUpdateQueue(workInProgress2, nextProps, context, renderLanes2);
          suspendIfUpdateReadFromEntangledAsyncAction();
          var newState = workInProgress2.memoizedState;
          contextType !== getDerivedStateFromProps || oldState !== newState || hasForceUpdate || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
            workInProgress2,
            Component,
            unresolvedOldProps,
            nextProps
          ), newState = workInProgress2.memoizedState), (contextType$jscomp$0 = hasForceUpdate || checkShouldComponentUpdate(
            workInProgress2,
            Component,
            contextType$jscomp$0,
            nextProps,
            oldState,
            newState,
            oldProps
          ) || null !== current && null !== current.dependencies && checkIfContextChanged(current.dependencies)) ? (oldContext || "function" !== typeof context.UNSAFE_componentWillUpdate && "function" !== typeof context.componentWillUpdate || ("function" === typeof context.componentWillUpdate && context.componentWillUpdate(nextProps, newState, oldProps), "function" === typeof context.UNSAFE_componentWillUpdate && context.UNSAFE_componentWillUpdate(
            nextProps,
            newState,
            oldProps
          )), "function" === typeof context.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof context.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), context.props = nextProps, context.state = newState, context.context = oldProps, nextProps = contextType$jscomp$0) : ("function" !== typeof context.componentDidUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof context.getSnapshotBeforeUpdate || contextType === current.memoizedProps && oldState === current.memoizedState || (workInProgress2.flags |= 1024), nextProps = false);
        }
        context = nextProps;
        markRef(current, workInProgress2);
        nextProps = 0 !== (workInProgress2.flags & 128);
        context || nextProps ? (context = workInProgress2.stateNode, Component = nextProps && "function" !== typeof Component.getDerivedStateFromError ? null : context.render(), workInProgress2.flags |= 1, null !== current && nextProps ? (workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          current.child,
          null,
          renderLanes2
        ), workInProgress2.child = reconcileChildFibers(
          workInProgress2,
          null,
          Component,
          renderLanes2
        )) : reconcileChildren(current, workInProgress2, Component, renderLanes2), workInProgress2.memoizedState = context.state, current = workInProgress2.child) : current = bailoutOnAlreadyFinishedWork(
          current,
          workInProgress2,
          renderLanes2
        );
        return current;
      }
      function mountHostRootWithoutHydrating(current, workInProgress2, nextChildren, renderLanes2) {
        resetHydrationState();
        workInProgress2.flags |= 256;
        reconcileChildren(current, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0,
        hydrationErrors: null
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
      }
      function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes2) {
        current = null !== current ? current.childLanes & ~renderLanes2 : 0;
        primaryTreeDidDefer && (current |= workInProgressDeferredLane);
        return current;
      }
      function updateSuspenseComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, showFallback = false, didSuspend = 0 !== (workInProgress2.flags & 128), JSCompiler_temp;
        (JSCompiler_temp = didSuspend) || (JSCompiler_temp = null !== current && null === current.memoizedState ? false : 0 !== (suspenseStackCursor.current & 2));
        JSCompiler_temp && (showFallback = true, workInProgress2.flags &= -129);
        JSCompiler_temp = 0 !== (workInProgress2.flags & 32);
        workInProgress2.flags &= -33;
        if (null === current) {
          if (isHydrating) {
            showFallback ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
            if (isHydrating) {
              var nextInstance = nextHydratableInstance, JSCompiler_temp$jscomp$0;
              if (JSCompiler_temp$jscomp$0 = nextInstance) {
                c: {
                  JSCompiler_temp$jscomp$0 = nextInstance;
                  for (nextInstance = rootOrSingletonContext; 8 !== JSCompiler_temp$jscomp$0.nodeType; ) {
                    if (!nextInstance) {
                      nextInstance = null;
                      break c;
                    }
                    JSCompiler_temp$jscomp$0 = getNextHydratable(
                      JSCompiler_temp$jscomp$0.nextSibling
                    );
                    if (null === JSCompiler_temp$jscomp$0) {
                      nextInstance = null;
                      break c;
                    }
                  }
                  nextInstance = JSCompiler_temp$jscomp$0;
                }
                null !== nextInstance ? (workInProgress2.memoizedState = {
                  dehydrated: nextInstance,
                  treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
                  retryLane: 536870912,
                  hydrationErrors: null
                }, JSCompiler_temp$jscomp$0 = createFiberImplClass(
                  18,
                  null,
                  null,
                  0
                ), JSCompiler_temp$jscomp$0.stateNode = nextInstance, JSCompiler_temp$jscomp$0.return = workInProgress2, workInProgress2.child = JSCompiler_temp$jscomp$0, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp$jscomp$0 = true) : JSCompiler_temp$jscomp$0 = false;
              }
              JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress2);
            }
            nextInstance = workInProgress2.memoizedState;
            if (null !== nextInstance && (nextInstance = nextInstance.dehydrated, null !== nextInstance))
              return isSuspenseInstanceFallback(nextInstance) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
            popSuspenseHandler(workInProgress2);
          }
          nextInstance = nextProps.children;
          nextProps = nextProps.fallback;
          if (showFallback)
            return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = workInProgress2.mode, nextInstance = mountWorkInProgressOffscreenFiber(
              { mode: "hidden", children: nextInstance },
              showFallback
            ), nextProps = createFiberFromFragment(
              nextProps,
              showFallback,
              renderLanes2,
              null
            ), nextInstance.return = workInProgress2, nextProps.return = workInProgress2, nextInstance.sibling = nextProps, workInProgress2.child = nextInstance, showFallback = workInProgress2.child, showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes2), showFallback.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
          pushPrimaryTreeSuspenseHandler(workInProgress2);
          return mountSuspensePrimaryChildren(workInProgress2, nextInstance);
        }
        JSCompiler_temp$jscomp$0 = current.memoizedState;
        if (null !== JSCompiler_temp$jscomp$0 && (nextInstance = JSCompiler_temp$jscomp$0.dehydrated, null !== nextInstance)) {
          if (didSuspend)
            workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, nextProps = mountWorkInProgressOffscreenFiber(
              { mode: "visible", children: nextProps.children },
              nextInstance
            ), showFallback = createFiberFromFragment(
              showFallback,
              nextInstance,
              renderLanes2,
              null
            ), showFallback.flags |= 2, nextProps.return = workInProgress2, showFallback.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, reconcileChildFibers(
              workInProgress2,
              current.child,
              null,
              renderLanes2
            ), nextProps = workInProgress2.child, nextProps.memoizedState = mountSuspenseOffscreenState(renderLanes2), nextProps.childLanes = getRemainingWorkInPrimaryTree(
              current,
              JSCompiler_temp,
              renderLanes2
            ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = showFallback);
          else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isSuspenseInstanceFallback(nextInstance)) {
            JSCompiler_temp = nextInstance.nextSibling && nextInstance.nextSibling.dataset;
            if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;
            JSCompiler_temp = digest;
            nextProps = Error(formatProdErrorMessage(419));
            nextProps.stack = "";
            nextProps.digest = JSCompiler_temp;
            queueHydrationError({ value: nextProps, source: null, stack: null });
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else if (didReceiveUpdate || propagateParentContextChanges(current, workInProgress2, renderLanes2, false), JSCompiler_temp = 0 !== (renderLanes2 & current.childLanes), didReceiveUpdate || JSCompiler_temp) {
            JSCompiler_temp = workInProgressRoot;
            if (null !== JSCompiler_temp && (nextProps = renderLanes2 & -renderLanes2, nextProps = 0 !== (nextProps & 42) ? 1 : getBumpedLaneForHydrationByLane(nextProps), nextProps = 0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes2)) ? 0 : nextProps, 0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane))
              throw JSCompiler_temp$jscomp$0.retryLane = nextProps, enqueueConcurrentRenderForLane(current, nextProps), scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps), SelectiveHydrationException;
            "$?" === nextInstance.data || renderDidSuspendDelayIfPossible();
            workInProgress2 = retrySuspenseComponentWithoutHydrating(
              current,
              workInProgress2,
              renderLanes2
            );
          } else
            "$?" === nextInstance.data ? (workInProgress2.flags |= 192, workInProgress2.child = current.child, workInProgress2 = null) : (current = JSCompiler_temp$jscomp$0.treeContext, nextHydratableInstance = getNextHydratable(
              nextInstance.nextSibling
            ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, rootOrSingletonContext = false, null !== current && (idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current.id, treeContextOverflow = current.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
              workInProgress2,
              nextProps.children
            ), workInProgress2.flags |= 4096);
          return workInProgress2;
        }
        if (showFallback)
          return reuseSuspenseHandlerOnStack(workInProgress2), showFallback = nextProps.fallback, nextInstance = workInProgress2.mode, JSCompiler_temp$jscomp$0 = current.child, digest = JSCompiler_temp$jscomp$0.sibling, nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {
            mode: "hidden",
            children: nextProps.children
          }), nextProps.subtreeFlags = JSCompiler_temp$jscomp$0.subtreeFlags & 65011712, null !== digest ? showFallback = createWorkInProgress(digest, showFallback) : (showFallback = createFiberFromFragment(
            showFallback,
            nextInstance,
            renderLanes2,
            null
          ), showFallback.flags |= 2), showFallback.return = workInProgress2, nextProps.return = workInProgress2, nextProps.sibling = showFallback, workInProgress2.child = nextProps, nextProps = showFallback, showFallback = workInProgress2.child, nextInstance = current.child.memoizedState, null === nextInstance ? nextInstance = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp$jscomp$0 = nextInstance.cachePool, null !== JSCompiler_temp$jscomp$0 ? (digest = CacheContext._currentValue, JSCompiler_temp$jscomp$0 = JSCompiler_temp$jscomp$0.parent !== digest ? { parent: digest, pool: digest } : JSCompiler_temp$jscomp$0) : JSCompiler_temp$jscomp$0 = getSuspendedCache(), nextInstance = {
            baseLanes: nextInstance.baseLanes | renderLanes2,
            cachePool: JSCompiler_temp$jscomp$0
          }), showFallback.memoizedState = nextInstance, showFallback.childLanes = getRemainingWorkInPrimaryTree(
            current,
            JSCompiler_temp,
            renderLanes2
          ), workInProgress2.memoizedState = SUSPENDED_MARKER, nextProps;
        pushPrimaryTreeSuspenseHandler(workInProgress2);
        renderLanes2 = current.child;
        current = renderLanes2.sibling;
        renderLanes2 = createWorkInProgress(renderLanes2, {
          mode: "visible",
          children: nextProps.children
        });
        renderLanes2.return = workInProgress2;
        renderLanes2.sibling = null;
        null !== current && (JSCompiler_temp = workInProgress2.deletions, null === JSCompiler_temp ? (workInProgress2.deletions = [current], workInProgress2.flags |= 16) : JSCompiler_temp.push(current));
        workInProgress2.child = renderLanes2;
        workInProgress2.memoizedState = null;
        return renderLanes2;
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
        primaryChildren = mountWorkInProgressOffscreenFiber(
          { mode: "visible", children: primaryChildren },
          workInProgress2.mode
        );
        primaryChildren.return = workInProgress2;
        return workInProgress2.child = primaryChildren;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
        offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);
        offscreenProps.lanes = 0;
        offscreenProps.stateNode = {
          _visibility: 1,
          _pendingMarkers: null,
          _retryCache: null,
          _transitions: null
        };
        return offscreenProps;
      }
      function retrySuspenseComponentWithoutHydrating(current, workInProgress2, renderLanes2) {
        reconcileChildFibers(workInProgress2, current.child, null, renderLanes2);
        current = mountSuspensePrimaryChildren(
          workInProgress2,
          workInProgress2.pendingProps.children
        );
        current.flags |= 2;
        workInProgress2.memoizedState = null;
        return current;
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes |= renderLanes2;
        var alternate = fiber.alternate;
        null !== alternate && (alternate.lanes |= renderLanes2);
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        null === renderState ? workInProgress2.memoizedState = {
          isBackwards,
          rendering: null,
          renderingStartTime: 0,
          last: lastContentRow,
          tail,
          tailMode
        } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
      }
      function updateSuspenseListComponent(current, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
        reconcileChildren(current, workInProgress2, nextProps.children, renderLanes2);
        nextProps = suspenseStackCursor.current;
        if (0 !== (nextProps & 2))
          nextProps = nextProps & 1 | 2, workInProgress2.flags |= 128;
        else {
          if (null !== current && 0 !== (current.flags & 128))
            a: for (current = workInProgress2.child; null !== current; ) {
              if (13 === current.tag)
                null !== current.memoizedState && scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (19 === current.tag)
                scheduleSuspenseWorkOnFiber(current, renderLanes2, workInProgress2);
              else if (null !== current.child) {
                current.child.return = current;
                current = current.child;
                continue;
              }
              if (current === workInProgress2) break a;
              for (; null === current.sibling; ) {
                if (null === current.return || current.return === workInProgress2)
                  break a;
                current = current.return;
              }
              current.sibling.return = current.return;
              current = current.sibling;
            }
          nextProps &= 1;
        }
        push(suspenseStackCursor, nextProps);
        switch (revealOrder) {
          case "forwards":
            renderLanes2 = workInProgress2.child;
            for (revealOrder = null; null !== renderLanes2; )
              current = renderLanes2.alternate, null !== current && null === findFirstSuspended(current) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
            renderLanes2 = revealOrder;
            null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
            initSuspenseListRenderState(
              workInProgress2,
              false,
              revealOrder,
              renderLanes2,
              tailMode
            );
            break;
          case "backwards":
            renderLanes2 = null;
            revealOrder = workInProgress2.child;
            for (workInProgress2.child = null; null !== revealOrder; ) {
              current = revealOrder.alternate;
              if (null !== current && null === findFirstSuspended(current)) {
                workInProgress2.child = revealOrder;
                break;
              }
              current = revealOrder.sibling;
              revealOrder.sibling = renderLanes2;
              renderLanes2 = revealOrder;
              revealOrder = current;
            }
            initSuspenseListRenderState(
              workInProgress2,
              true,
              renderLanes2,
              null,
              tailMode
            );
            break;
          case "together":
            initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
            break;
          default:
            workInProgress2.memoizedState = null;
        }
        return workInProgress2.child;
      }
      function bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2) {
        null !== current && (workInProgress2.dependencies = current.dependencies);
        workInProgressRootSkippedLanes |= workInProgress2.lanes;
        if (0 === (renderLanes2 & workInProgress2.childLanes))
          if (null !== current) {
            if (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), 0 === (renderLanes2 & workInProgress2.childLanes))
              return null;
          } else return null;
        if (null !== current && workInProgress2.child !== current.child)
          throw Error(formatProdErrorMessage(153));
        if (null !== workInProgress2.child) {
          current = workInProgress2.child;
          renderLanes2 = createWorkInProgress(current, current.pendingProps);
          workInProgress2.child = renderLanes2;
          for (renderLanes2.return = workInProgress2; null !== current.sibling; )
            current = current.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current, current.pendingProps), renderLanes2.return = workInProgress2;
          renderLanes2.sibling = null;
        }
        return workInProgress2.child;
      }
      function checkScheduledUpdateOrContext(current, renderLanes2) {
        if (0 !== (current.lanes & renderLanes2)) return true;
        current = current.dependencies;
        return null !== current && checkIfContextChanged(current) ? true : false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case 3:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
            resetHydrationState();
            break;
          case 27:
          case 5:
            pushHostContext(workInProgress2);
            break;
          case 4:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case 10:
            pushProvider(
              workInProgress2,
              workInProgress2.type,
              workInProgress2.memoizedProps.value
            );
            break;
          case 13:
            var state = workInProgress2.memoizedState;
            if (null !== state) {
              if (null !== state.dehydrated)
                return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
              if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
                return updateSuspenseComponent(current, workInProgress2, renderLanes2);
              pushPrimaryTreeSuspenseHandler(workInProgress2);
              current = bailoutOnAlreadyFinishedWork(
                current,
                workInProgress2,
                renderLanes2
              );
              return null !== current ? current.sibling : null;
            }
            pushPrimaryTreeSuspenseHandler(workInProgress2);
            break;
          case 19:
            var didSuspendBefore = 0 !== (current.flags & 128);
            state = 0 !== (renderLanes2 & workInProgress2.childLanes);
            state || (propagateParentContextChanges(
              current,
              workInProgress2,
              renderLanes2,
              false
            ), state = 0 !== (renderLanes2 & workInProgress2.childLanes));
            if (didSuspendBefore) {
              if (state)
                return updateSuspenseListComponent(
                  current,
                  workInProgress2,
                  renderLanes2
                );
              workInProgress2.flags |= 128;
            }
            didSuspendBefore = workInProgress2.memoizedState;
            null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
            push(suspenseStackCursor, suspenseStackCursor.current);
            if (state) break;
            else return null;
          case 22:
          case 23:
            return workInProgress2.lanes = 0, updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            pushProvider(workInProgress2, CacheContext, current.memoizedState.cache);
        }
        return bailoutOnAlreadyFinishedWork(current, workInProgress2, renderLanes2);
      }
      function beginWork(current, workInProgress2, renderLanes2) {
        if (null !== current)
          if (current.memoizedProps !== workInProgress2.pendingProps)
            didReceiveUpdate = true;
          else {
            if (!checkScheduledUpdateOrContext(current, renderLanes2) && 0 === (workInProgress2.flags & 128))
              return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
                current,
                workInProgress2,
                renderLanes2
              );
            didReceiveUpdate = 0 !== (current.flags & 131072) ? true : false;
          }
        else
          didReceiveUpdate = false, isHydrating && 0 !== (workInProgress2.flags & 1048576) && pushTreeId(workInProgress2, treeForkCount, workInProgress2.index);
        workInProgress2.lanes = 0;
        switch (workInProgress2.tag) {
          case 16:
            a: {
              current = workInProgress2.pendingProps;
              var lazyComponent = workInProgress2.elementType, init = lazyComponent._init;
              lazyComponent = init(lazyComponent._payload);
              workInProgress2.type = lazyComponent;
              if ("function" === typeof lazyComponent)
                shouldConstruct(lazyComponent) ? (current = resolveClassComponentProps(lazyComponent, current), workInProgress2.tag = 1, workInProgress2 = updateClassComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                )) : (workInProgress2.tag = 0, workInProgress2 = updateFunctionComponent(
                  null,
                  workInProgress2,
                  lazyComponent,
                  current,
                  renderLanes2
                ));
              else {
                if (void 0 !== lazyComponent && null !== lazyComponent) {
                  if (init = lazyComponent.$$typeof, init === REACT_FORWARD_REF_TYPE) {
                    workInProgress2.tag = 11;
                    workInProgress2 = updateForwardRef(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  } else if (init === REACT_MEMO_TYPE) {
                    workInProgress2.tag = 14;
                    workInProgress2 = updateMemoComponent(
                      null,
                      workInProgress2,
                      lazyComponent,
                      current,
                      renderLanes2
                    );
                    break a;
                  }
                }
                workInProgress2 = getComponentNameFromType(lazyComponent) || lazyComponent;
                throw Error(formatProdErrorMessage(306, workInProgress2, ""));
              }
            }
            return workInProgress2;
          case 0:
            return updateFunctionComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 1:
            return lazyComponent = workInProgress2.type, init = resolveClassComponentProps(
              lazyComponent,
              workInProgress2.pendingProps
            ), updateClassComponent(
              current,
              workInProgress2,
              lazyComponent,
              init,
              renderLanes2
            );
          case 3:
            a: {
              pushHostContainer(
                workInProgress2,
                workInProgress2.stateNode.containerInfo
              );
              if (null === current) throw Error(formatProdErrorMessage(387));
              lazyComponent = workInProgress2.pendingProps;
              var prevState = workInProgress2.memoizedState;
              init = prevState.element;
              cloneUpdateQueue(current, workInProgress2);
              processUpdateQueue(workInProgress2, lazyComponent, null, renderLanes2);
              var nextState = workInProgress2.memoizedState;
              lazyComponent = nextState.cache;
              pushProvider(workInProgress2, CacheContext, lazyComponent);
              lazyComponent !== prevState.cache && propagateContextChanges(
                workInProgress2,
                [CacheContext],
                renderLanes2,
                true
              );
              suspendIfUpdateReadFromEntangledAsyncAction();
              lazyComponent = nextState.element;
              if (prevState.isDehydrated)
                if (prevState = {
                  element: lazyComponent,
                  isDehydrated: false,
                  cache: nextState.cache
                }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  );
                  break a;
                } else if (lazyComponent !== init) {
                  init = createCapturedValueAtFiber(
                    Error(formatProdErrorMessage(424)),
                    workInProgress2
                  );
                  queueHydrationError(init);
                  workInProgress2 = mountHostRootWithoutHydrating(
                    current,
                    workInProgress2,
                    lazyComponent,
                    renderLanes2
                  );
                  break a;
                } else {
                  current = workInProgress2.stateNode.containerInfo;
                  switch (current.nodeType) {
                    case 9:
                      current = current.body;
                      break;
                    default:
                      current = "HTML" === current.nodeName ? current.ownerDocument.body : current;
                  }
                  nextHydratableInstance = getNextHydratable(current.firstChild);
                  hydrationParentFiber = workInProgress2;
                  isHydrating = true;
                  hydrationErrors = null;
                  rootOrSingletonContext = true;
                  renderLanes2 = mountChildFibers(
                    workInProgress2,
                    null,
                    lazyComponent,
                    renderLanes2
                  );
                  for (workInProgress2.child = renderLanes2; renderLanes2; )
                    renderLanes2.flags = renderLanes2.flags & -3 | 4096, renderLanes2 = renderLanes2.sibling;
                }
              else {
                resetHydrationState();
                if (lazyComponent === init) {
                  workInProgress2 = bailoutOnAlreadyFinishedWork(
                    current,
                    workInProgress2,
                    renderLanes2
                  );
                  break a;
                }
                reconcileChildren(
                  current,
                  workInProgress2,
                  lazyComponent,
                  renderLanes2
                );
              }
              workInProgress2 = workInProgress2.child;
            }
            return workInProgress2;
          case 26:
            return markRef(current, workInProgress2), null === current ? (renderLanes2 = getResource(
              workInProgress2.type,
              null,
              workInProgress2.pendingProps,
              null
            )) ? workInProgress2.memoizedState = renderLanes2 : isHydrating || (renderLanes2 = workInProgress2.type, current = workInProgress2.pendingProps, lazyComponent = getOwnerDocumentFromRootContainer(
              rootInstanceStackCursor.current
            ).createElement(renderLanes2), lazyComponent[internalInstanceKey] = workInProgress2, lazyComponent[internalPropsKey] = current, setInitialProperties(lazyComponent, renderLanes2, current), markNodeAsHoistable(lazyComponent), workInProgress2.stateNode = lazyComponent) : workInProgress2.memoizedState = getResource(
              workInProgress2.type,
              current.memoizedProps,
              workInProgress2.pendingProps,
              current.memoizedState
            ), null;
          case 27:
            return pushHostContext(workInProgress2), null === current && isHydrating && (lazyComponent = workInProgress2.stateNode = resolveSingletonInstance(
              workInProgress2.type,
              workInProgress2.pendingProps,
              rootInstanceStackCursor.current
            ), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, init = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = init, nextHydratableInstance = getNextHydratable(
              lazyComponent.firstChild
            )) : nextHydratableInstance = init), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), markRef(current, workInProgress2), null === current && (workInProgress2.flags |= 4194304), workInProgress2.child;
          case 5:
            if (null === current && isHydrating) {
              if (init = lazyComponent = nextHydratableInstance)
                lazyComponent = canHydrateInstance(
                  lazyComponent,
                  workInProgress2.type,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== lazyComponent ? (workInProgress2.stateNode = lazyComponent, hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
                  lazyComponent.firstChild
                ), rootOrSingletonContext = false, init = true) : init = false;
              init || throwOnHydrationMismatch(workInProgress2);
            }
            pushHostContext(workInProgress2);
            init = workInProgress2.type;
            prevState = workInProgress2.pendingProps;
            nextState = null !== current ? current.memoizedProps : null;
            lazyComponent = prevState.children;
            shouldSetTextContent(init, prevState) ? lazyComponent = null : null !== nextState && shouldSetTextContent(init, nextState) && (workInProgress2.flags |= 32);
            null !== workInProgress2.memoizedState && (init = renderWithHooks(
              current,
              workInProgress2,
              TransitionAwareHostComponent,
              null,
              null,
              renderLanes2
            ), HostTransitionContext._currentValue = init);
            markRef(current, workInProgress2);
            reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2);
            return workInProgress2.child;
          case 6:
            if (null === current && isHydrating) {
              if (current = renderLanes2 = nextHydratableInstance)
                renderLanes2 = canHydrateTextInstance(
                  renderLanes2,
                  workInProgress2.pendingProps,
                  rootOrSingletonContext
                ), null !== renderLanes2 ? (workInProgress2.stateNode = renderLanes2, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, current = true) : current = false;
              current || throwOnHydrationMismatch(workInProgress2);
            }
            return null;
          case 13:
            return updateSuspenseComponent(current, workInProgress2, renderLanes2);
          case 4:
            return pushHostContainer(
              workInProgress2,
              workInProgress2.stateNode.containerInfo
            ), lazyComponent = workInProgress2.pendingProps, null === current ? workInProgress2.child = reconcileChildFibers(
              workInProgress2,
              null,
              lazyComponent,
              renderLanes2
            ) : reconcileChildren(
              current,
              workInProgress2,
              lazyComponent,
              renderLanes2
            ), workInProgress2.child;
          case 11:
            return updateForwardRef(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 7:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps,
              renderLanes2
            ), workInProgress2.child;
          case 8:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 12:
            return reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 10:
            return lazyComponent = workInProgress2.pendingProps, pushProvider(workInProgress2, workInProgress2.type, lazyComponent.value), reconcileChildren(
              current,
              workInProgress2,
              lazyComponent.children,
              renderLanes2
            ), workInProgress2.child;
          case 9:
            return init = workInProgress2.type._context, lazyComponent = workInProgress2.pendingProps.children, prepareToReadContext(workInProgress2), init = readContext(init), lazyComponent = lazyComponent(init), workInProgress2.flags |= 1, reconcileChildren(current, workInProgress2, lazyComponent, renderLanes2), workInProgress2.child;
          case 14:
            return updateMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 15:
            return updateSimpleMemoComponent(
              current,
              workInProgress2,
              workInProgress2.type,
              workInProgress2.pendingProps,
              renderLanes2
            );
          case 19:
            return updateSuspenseListComponent(current, workInProgress2, renderLanes2);
          case 31:
            return lazyComponent = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, lazyComponent = {
              mode: lazyComponent.mode,
              children: lazyComponent.children
            }, null === current ? (renderLanes2 = mountWorkInProgressOffscreenFiber(
              lazyComponent,
              renderLanes2
            ), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2) : (renderLanes2 = createWorkInProgress(current.child, lazyComponent), renderLanes2.ref = workInProgress2.ref, workInProgress2.child = renderLanes2, renderLanes2.return = workInProgress2, workInProgress2 = renderLanes2), workInProgress2;
          case 22:
            return updateOffscreenComponent(current, workInProgress2, renderLanes2);
          case 24:
            return prepareToReadContext(workInProgress2), lazyComponent = readContext(CacheContext), null === current ? (init = peekCacheFromPool(), null === init && (init = workInProgressRoot, prevState = createCache3(), init.pooledCache = prevState, prevState.refCount++, null !== prevState && (init.pooledCacheLanes |= renderLanes2), init = prevState), workInProgress2.memoizedState = {
              parent: lazyComponent,
              cache: init
            }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, init)) : (0 !== (current.lanes & renderLanes2) && (cloneUpdateQueue(current, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), init = current.memoizedState, prevState = workInProgress2.memoizedState, init.parent !== lazyComponent ? (init = { parent: lazyComponent, cache: lazyComponent }, workInProgress2.memoizedState = init, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = init), pushProvider(workInProgress2, CacheContext, lazyComponent)) : (lazyComponent = prevState.cache, pushProvider(workInProgress2, CacheContext, lazyComponent), lazyComponent !== init.cache && propagateContextChanges(
              workInProgress2,
              [CacheContext],
              renderLanes2,
              true
            ))), reconcileChildren(
              current,
              workInProgress2,
              workInProgress2.pendingProps.children,
              renderLanes2
            ), workInProgress2.child;
          case 29:
            throw workInProgress2.pendingProps;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= 4;
      }
      function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
        if ("stylesheet" !== resource.type || 0 !== (resource.state.loading & 4))
          workInProgress2.flags &= -16777217;
        else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
          resource = suspenseHandlerStackCursor.current;
          if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
            throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
          workInProgress2.flags |= 8192;
        }
      }
      function scheduleRetryEffect(workInProgress2, retryQueue) {
        null !== retryQueue && (workInProgress2.flags |= 4);
        workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (!isHydrating)
          switch (renderState.tailMode) {
            case "hidden":
              hasRenderedATailFallback = renderState.tail;
              for (var lastTailNode = null; null !== hasRenderedATailFallback; )
                null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
              null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
              break;
            case "collapsed":
              lastTailNode = renderState.tail;
              for (var lastTailNode$113 = null; null !== lastTailNode; )
                null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode), lastTailNode = lastTailNode.sibling;
              null === lastTailNode$113 ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : lastTailNode$113.sibling = null;
          }
      }
      function bubbleProperties(completedWork) {
        var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
        if (didBailout)
          for (var child$114 = completedWork.child; null !== child$114; )
            newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags & 65011712, subtreeFlags |= child$114.flags & 65011712, child$114.return = completedWork, child$114 = child$114.sibling;
        else
          for (child$114 = completedWork.child; null !== child$114; )
            newChildLanes |= child$114.lanes | child$114.childLanes, subtreeFlags |= child$114.subtreeFlags, subtreeFlags |= child$114.flags, child$114.return = completedWork, child$114 = child$114.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeWork(current, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 31:
          case 16:
          case 15:
          case 0:
          case 11:
          case 7:
          case 8:
          case 12:
          case 9:
          case 14:
            return bubbleProperties(workInProgress2), null;
          case 1:
            return bubbleProperties(workInProgress2), null;
          case 3:
            renderLanes2 = workInProgress2.stateNode;
            newProps = null;
            null !== current && (newProps = current.memoizedState.cache);
            workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
            popProvider(CacheContext);
            popHostContainer();
            renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
            if (null === current || null === current.child)
              popHydrationState(workInProgress2) ? markUpdate(workInProgress2) : null === current || current.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
            bubbleProperties(workInProgress2);
            return null;
          case 26:
            return renderLanes2 = workInProgress2.memoizedState, null === current ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(workInProgress2, renderLanes2)) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
          case 27:
            popHostContext(workInProgress2);
            renderLanes2 = rootInstanceStackCursor.current;
            var type = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2, current) : (current = resolveSingletonInstance(type, newProps, renderLanes2), workInProgress2.stateNode = current, markUpdate(workInProgress2));
            }
            bubbleProperties(workInProgress2);
            return null;
          case 5:
            popHostContext(workInProgress2);
            renderLanes2 = workInProgress2.type;
            if (null !== current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if (!newProps) {
                if (null === workInProgress2.stateNode)
                  throw Error(formatProdErrorMessage(166));
                bubbleProperties(workInProgress2);
                return null;
              }
              current = contextStackCursor.current;
              if (popHydrationState(workInProgress2))
                prepareToHydrateHostInstance(workInProgress2, current);
              else {
                type = getOwnerDocumentFromRootContainer(
                  rootInstanceStackCursor.current
                );
                switch (current) {
                  case 1:
                    current = type.createElementNS(
                      "http://www.w3.org/2000/svg",
                      renderLanes2
                    );
                    break;
                  case 2:
                    current = type.createElementNS(
                      "http://www.w3.org/1998/Math/MathML",
                      renderLanes2
                    );
                    break;
                  default:
                    switch (renderLanes2) {
                      case "svg":
                        current = type.createElementNS(
                          "http://www.w3.org/2000/svg",
                          renderLanes2
                        );
                        break;
                      case "math":
                        current = type.createElementNS(
                          "http://www.w3.org/1998/Math/MathML",
                          renderLanes2
                        );
                        break;
                      case "script":
                        current = type.createElement("div");
                        current.innerHTML = "<script></script>";
                        current = current.removeChild(current.firstChild);
                        break;
                      case "select":
                        current = "string" === typeof newProps.is ? type.createElement("select", { is: newProps.is }) : type.createElement("select");
                        newProps.multiple ? current.multiple = true : newProps.size && (current.size = newProps.size);
                        break;
                      default:
                        current = "string" === typeof newProps.is ? type.createElement(renderLanes2, { is: newProps.is }) : type.createElement(renderLanes2);
                    }
                }
                current[internalInstanceKey] = workInProgress2;
                current[internalPropsKey] = newProps;
                a: for (type = workInProgress2.child; null !== type; ) {
                  if (5 === type.tag || 6 === type.tag)
                    current.appendChild(type.stateNode);
                  else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {
                    type.child.return = type;
                    type = type.child;
                    continue;
                  }
                  if (type === workInProgress2) break a;
                  for (; null === type.sibling; ) {
                    if (null === type.return || type.return === workInProgress2)
                      break a;
                    type = type.return;
                  }
                  type.sibling.return = type.return;
                  type = type.sibling;
                }
                workInProgress2.stateNode = current;
                a: switch (setInitialProperties(current, renderLanes2, newProps), renderLanes2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    current = !!newProps.autoFocus;
                    break a;
                  case "img":
                    current = true;
                    break a;
                  default:
                    current = false;
                }
                current && markUpdate(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            workInProgress2.flags &= -16777217;
            return null;
          case 6:
            if (current && null != workInProgress2.stateNode)
              current.memoizedProps !== newProps && markUpdate(workInProgress2);
            else {
              if ("string" !== typeof newProps && null === workInProgress2.stateNode)
                throw Error(formatProdErrorMessage(166));
              current = rootInstanceStackCursor.current;
              if (popHydrationState(workInProgress2)) {
                current = workInProgress2.stateNode;
                renderLanes2 = workInProgress2.memoizedProps;
                newProps = null;
                type = hydrationParentFiber;
                if (null !== type)
                  switch (type.tag) {
                    case 27:
                    case 5:
                      newProps = type.memoizedProps;
                  }
                current[internalInstanceKey] = workInProgress2;
                current = current.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current.nodeValue, renderLanes2) ? true : false;
                current || throwOnHydrationMismatch(workInProgress2);
              } else
                current = getOwnerDocumentFromRootContainer(current).createTextNode(
                  newProps
                ), current[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current;
            }
            bubbleProperties(workInProgress2);
            return null;
          case 13:
            newProps = workInProgress2.memoizedState;
            if (null === current || null !== current.memoizedState && null !== current.memoizedState.dehydrated) {
              type = popHydrationState(workInProgress2);
              if (null !== newProps && null !== newProps.dehydrated) {
                if (null === current) {
                  if (!type) throw Error(formatProdErrorMessage(318));
                  type = workInProgress2.memoizedState;
                  type = null !== type ? type.dehydrated : null;
                  if (!type) throw Error(formatProdErrorMessage(317));
                  type[internalInstanceKey] = workInProgress2;
                } else
                  resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4;
                bubbleProperties(workInProgress2);
                type = false;
              } else
                type = upgradeHydrationErrorsToRecoverable(), null !== current && null !== current.memoizedState && (current.memoizedState.hydrationErrors = type), type = true;
              if (!type) {
                if (workInProgress2.flags & 256)
                  return popSuspenseHandler(workInProgress2), workInProgress2;
                popSuspenseHandler(workInProgress2);
                return null;
              }
            }
            popSuspenseHandler(workInProgress2);
            if (0 !== (workInProgress2.flags & 128))
              return workInProgress2.lanes = renderLanes2, workInProgress2;
            renderLanes2 = null !== newProps;
            current = null !== current && null !== current.memoizedState;
            if (renderLanes2) {
              newProps = workInProgress2.child;
              type = null;
              null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (type = newProps.alternate.memoizedState.cachePool.pool);
              var cache$127 = null;
              null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (cache$127 = newProps.memoizedState.cachePool.pool);
              cache$127 !== type && (newProps.flags |= 2048);
            }
            renderLanes2 !== current && renderLanes2 && (workInProgress2.child.flags |= 8192);
            scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
            bubbleProperties(workInProgress2);
            return null;
          case 4:
            return popHostContainer(), null === current && listenToAllSupportedEvents(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
          case 10:
            return popProvider(workInProgress2.type), bubbleProperties(workInProgress2), null;
          case 19:
            pop(suspenseStackCursor);
            type = workInProgress2.memoizedState;
            if (null === type) return bubbleProperties(workInProgress2), null;
            newProps = 0 !== (workInProgress2.flags & 128);
            cache$127 = type.rendering;
            if (null === cache$127)
              if (newProps) cutOffTailIfNeeded(type, false);
              else {
                if (0 !== workInProgressRootExitStatus || null !== current && 0 !== (current.flags & 128))
                  for (current = workInProgress2.child; null !== current; ) {
                    cache$127 = findFirstSuspended(current);
                    if (null !== cache$127) {
                      workInProgress2.flags |= 128;
                      cutOffTailIfNeeded(type, false);
                      current = cache$127.updateQueue;
                      workInProgress2.updateQueue = current;
                      scheduleRetryEffect(workInProgress2, current);
                      workInProgress2.subtreeFlags = 0;
                      current = renderLanes2;
                      for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
                        resetWorkInProgress(renderLanes2, current), renderLanes2 = renderLanes2.sibling;
                      push(
                        suspenseStackCursor,
                        suspenseStackCursor.current & 1 | 2
                      );
                      return workInProgress2.child;
                    }
                    current = current.sibling;
                  }
                null !== type.tail && now() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
              }
            else {
              if (!newProps)
                if (current = findFirstSuspended(cache$127), null !== current) {
                  if (workInProgress2.flags |= 128, newProps = true, current = current.updateQueue, workInProgress2.updateQueue = current, scheduleRetryEffect(workInProgress2, current), cutOffTailIfNeeded(type, true), null === type.tail && "hidden" === type.tailMode && !cache$127.alternate && !isHydrating)
                    return bubbleProperties(workInProgress2), null;
                } else
                  2 * now() - type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(type, false), workInProgress2.lanes = 4194304);
              type.isBackwards ? (cache$127.sibling = workInProgress2.child, workInProgress2.child = cache$127) : (current = type.last, null !== current ? current.sibling = cache$127 : workInProgress2.child = cache$127, type.last = cache$127);
            }
            if (null !== type.tail)
              return workInProgress2 = type.tail, type.rendering = workInProgress2, type.tail = workInProgress2.sibling, type.renderingStartTime = now(), workInProgress2.sibling = null, current = suspenseStackCursor.current, push(suspenseStackCursor, newProps ? current & 1 | 2 : current & 1), workInProgress2;
            bubbleProperties(workInProgress2);
            return null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), newProps = null !== workInProgress2.memoizedState, null !== current ? null !== current.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (renderLanes2 = current.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current && pop(resumedCache), null;
          case 24:
            return renderLanes2 = null, null !== current && (renderLanes2 = current.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext), bubbleProperties(workInProgress2), null;
          case 25:
            return null;
          case 30:
            return null;
        }
        throw Error(formatProdErrorMessage(156, workInProgress2.tag));
      }
      function unwindWork(current, workInProgress2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case 1:
            return current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 3:
            return popProvider(CacheContext), popHostContainer(), current = workInProgress2.flags, 0 !== (current & 65536) && 0 === (current & 128) ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 26:
          case 27:
          case 5:
            return popHostContext(workInProgress2), null;
          case 13:
            popSuspenseHandler(workInProgress2);
            current = workInProgress2.memoizedState;
            if (null !== current && null !== current.dehydrated) {
              if (null === workInProgress2.alternate)
                throw Error(formatProdErrorMessage(340));
              resetHydrationState();
            }
            current = workInProgress2.flags;
            return current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 19:
            return pop(suspenseStackCursor), null;
          case 4:
            return popHostContainer(), null;
          case 10:
            return popProvider(workInProgress2.type), null;
          case 22:
          case 23:
            return popSuspenseHandler(workInProgress2), popHiddenContext(), null !== current && pop(resumedCache), current = workInProgress2.flags, current & 65536 ? (workInProgress2.flags = current & -65537 | 128, workInProgress2) : null;
          case 24:
            return popProvider(CacheContext), null;
          case 25:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current, interruptedWork) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case 3:
            popProvider(CacheContext);
            popHostContainer();
            break;
          case 26:
          case 27:
          case 5:
            popHostContext(interruptedWork);
            break;
          case 4:
            popHostContainer();
            break;
          case 13:
            popSuspenseHandler(interruptedWork);
            break;
          case 19:
            pop(suspenseStackCursor);
            break;
          case 10:
            popProvider(interruptedWork.type);
            break;
          case 22:
          case 23:
            popSuspenseHandler(interruptedWork);
            popHiddenContext();
            null !== current && pop(resumedCache);
            break;
          case 24:
            popProvider(CacheContext);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        try {
          var updateQueue2 = finishedWork.updateQueue, lastEffect = null !== updateQueue2 ? updateQueue2.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue2 = firstEffect;
            do {
              if ((updateQueue2.tag & flags) === flags) {
                lastEffect = void 0;
                var create = updateQueue2.create, inst = updateQueue2.inst;
                lastEffect = create();
                inst.destroy = lastEffect;
              }
              updateQueue2 = updateQueue2.next;
            } while (updateQueue2 !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor$jscomp$0) {
        try {
          var updateQueue2 = finishedWork.updateQueue, lastEffect = null !== updateQueue2 ? updateQueue2.lastEffect : null;
          if (null !== lastEffect) {
            var firstEffect = lastEffect.next;
            updateQueue2 = firstEffect;
            do {
              if ((updateQueue2.tag & flags) === flags) {
                var inst = updateQueue2.inst, destroy = inst.destroy;
                if (void 0 !== destroy) {
                  inst.destroy = void 0;
                  lastEffect = finishedWork;
                  var nearestMountedAncestor = nearestMountedAncestor$jscomp$0, destroy_ = destroy;
                  try {
                    destroy_();
                  } catch (error) {
                    captureCommitPhaseError(
                      lastEffect,
                      nearestMountedAncestor,
                      error
                    );
                  }
                }
              }
              updateQueue2 = updateQueue2.next;
            } while (updateQueue2 !== firstEffect);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitClassCallbacks(finishedWork) {
        var updateQueue2 = finishedWork.updateQueue;
        if (null !== updateQueue2) {
          var instance2 = finishedWork.stateNode;
          try {
            commitCallbacks(updateQueue2, instance2);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
        }
      }
      function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance2) {
        instance2.props = resolveClassComponentProps(
          current.type,
          current.memoizedProps
        );
        instance2.state = current.memoizedState;
        try {
          instance2.componentWillUnmount();
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyAttachRef(current, nearestMountedAncestor) {
        try {
          var ref = current.ref;
          if (null !== ref) {
            switch (current.tag) {
              case 26:
              case 27:
              case 5:
                var instanceToUse = current.stateNode;
                break;
              case 30:
                instanceToUse = current.stateNode;
                break;
              default:
                instanceToUse = current.stateNode;
            }
            "function" === typeof ref ? current.refCleanup = ref(instanceToUse) : ref.current = instanceToUse;
          }
        } catch (error) {
          captureCommitPhaseError(current, nearestMountedAncestor, error);
        }
      }
      function safelyDetachRef(current, nearestMountedAncestor) {
        var ref = current.ref, refCleanup = current.refCleanup;
        if (null !== ref)
          if ("function" === typeof refCleanup)
            try {
              refCleanup();
            } catch (error) {
              captureCommitPhaseError(current, nearestMountedAncestor, error);
            } finally {
              current.refCleanup = null, current = current.alternate, null != current && (current.refCleanup = null);
            }
          else if ("function" === typeof ref)
            try {
              ref(null);
            } catch (error$143) {
              captureCommitPhaseError(current, nearestMountedAncestor, error$143);
            }
          else ref.current = null;
      }
      function commitHostMount(finishedWork) {
        var type = finishedWork.type, props = finishedWork.memoizedProps, instance2 = finishedWork.stateNode;
        try {
          a: switch (type) {
            case "button":
            case "input":
            case "select":
            case "textarea":
              props.autoFocus && instance2.focus();
              break a;
            case "img":
              props.src ? instance2.src = props.src : props.srcSet && (instance2.srcset = props.srcSet);
          }
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function commitHostUpdate(finishedWork, newProps, oldProps) {
        try {
          var domElement = finishedWork.stateNode;
          updateProperties(domElement, finishedWork.type, oldProps, newProps);
          domElement[internalPropsKey] = newProps;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      function isHostParent(fiber) {
        return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
      }
      function getHostSibling(fiber) {
        a: for (; ; ) {
          for (; null === fiber.sibling; ) {
            if (null === fiber.return || isHostParent(fiber.return)) return null;
            fiber = fiber.return;
          }
          fiber.sibling.return = fiber.return;
          for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
            if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
            if (fiber.flags & 2) continue a;
            if (null === fiber.child || 4 === fiber.tag) continue a;
            else fiber.child.return = fiber, fiber = fiber.child;
          }
          if (!(fiber.flags & 2)) return fiber.stateNode;
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node2, before, parent) {
        var tag = node2.tag;
        if (5 === tag || 6 === tag)
          node2 = node2.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node2, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node2), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
        else if (4 !== tag && (27 === tag && isSingletonScope(node2.type) && (parent = node2.stateNode, before = null), node2 = node2.child, null !== node2))
          for (insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling; null !== node2; )
            insertOrAppendPlacementNodeIntoContainer(node2, before, parent), node2 = node2.sibling;
      }
      function insertOrAppendPlacementNode(node2, before, parent) {
        var tag = node2.tag;
        if (5 === tag || 6 === tag)
          node2 = node2.stateNode, before ? parent.insertBefore(node2, before) : parent.appendChild(node2);
        else if (4 !== tag && (27 === tag && isSingletonScope(node2.type) && (parent = node2.stateNode), node2 = node2.child, null !== node2))
          for (insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling; null !== node2; )
            insertOrAppendPlacementNode(node2, before, parent), node2 = node2.sibling;
      }
      function commitHostSingletonAcquisition(finishedWork) {
        var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
        try {
          for (var type = finishedWork.type, attributes = singleton.attributes; attributes.length; )
            singleton.removeAttributeNode(attributes[0]);
          setInitialProperties(singleton, type, props);
          singleton[internalInstanceKey] = finishedWork;
          singleton[internalPropsKey] = props;
        } catch (error) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error);
        }
      }
      var offscreenSubtreeIsHidden = false;
      var offscreenSubtreeWasHidden = false;
      var needsFormReset = false;
      var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
      var nextEffect = null;
      function commitBeforeMutationEffects(root3, firstChild) {
        root3 = root3.containerInfo;
        eventsEnabled = _enabled;
        root3 = getActiveElementDeep(root3);
        if (hasSelectionCapabilities(root3)) {
          if ("selectionStart" in root3)
            var JSCompiler_temp = {
              start: root3.selectionStart,
              end: root3.selectionEnd
            };
          else
            a: {
              JSCompiler_temp = (JSCompiler_temp = root3.ownerDocument) && JSCompiler_temp.defaultView || window;
              var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
              if (selection && 0 !== selection.rangeCount) {
                JSCompiler_temp = selection.anchorNode;
                var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
                selection = selection.focusOffset;
                try {
                  JSCompiler_temp.nodeType, focusNode.nodeType;
                } catch (e$20) {
                  JSCompiler_temp = null;
                  break a;
                }
                var length2 = 0, start3 = -1, end2 = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node2 = root3, parentNode = null;
                b: for (; ; ) {
                  for (var next2; ; ) {
                    node2 !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node2.nodeType || (start3 = length2 + anchorOffset);
                    node2 !== focusNode || 0 !== selection && 3 !== node2.nodeType || (end2 = length2 + selection);
                    3 === node2.nodeType && (length2 += node2.nodeValue.length);
                    if (null === (next2 = node2.firstChild)) break;
                    parentNode = node2;
                    node2 = next2;
                  }
                  for (; ; ) {
                    if (node2 === root3) break b;
                    parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start3 = length2);
                    parentNode === focusNode && ++indexWithinFocus === selection && (end2 = length2);
                    if (null !== (next2 = node2.nextSibling)) break;
                    node2 = parentNode;
                    parentNode = node2.parentNode;
                  }
                  node2 = next2;
                }
                JSCompiler_temp = -1 === start3 || -1 === end2 ? null : { start: start3, end: end2 };
              } else JSCompiler_temp = null;
            }
          JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
        } else JSCompiler_temp = null;
        selectionInformation = { focusedElem: root3, selectionRange: JSCompiler_temp };
        _enabled = false;
        for (nextEffect = firstChild; null !== nextEffect; )
          if (firstChild = nextEffect, root3 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root3)
            root3.return = firstChild, nextEffect = root3;
          else
            for (; null !== nextEffect; ) {
              firstChild = nextEffect;
              focusNode = firstChild.alternate;
              root3 = firstChild.flags;
              switch (firstChild.tag) {
                case 0:
                  break;
                case 11:
                case 15:
                  break;
                case 1:
                  if (0 !== (root3 & 1024) && null !== focusNode) {
                    root3 = void 0;
                    JSCompiler_temp = firstChild;
                    anchorOffset = focusNode.memoizedProps;
                    focusNode = focusNode.memoizedState;
                    selection = JSCompiler_temp.stateNode;
                    try {
                      var resolvedPrevProps = resolveClassComponentProps(
                        JSCompiler_temp.type,
                        anchorOffset,
                        JSCompiler_temp.elementType === JSCompiler_temp.type
                      );
                      root3 = selection.getSnapshotBeforeUpdate(
                        resolvedPrevProps,
                        focusNode
                      );
                      selection.__reactInternalSnapshotBeforeUpdate = root3;
                    } catch (error) {
                      captureCommitPhaseError(
                        JSCompiler_temp,
                        JSCompiler_temp.return,
                        error
                      );
                    }
                  }
                  break;
                case 3:
                  if (0 !== (root3 & 1024)) {
                    if (root3 = firstChild.stateNode.containerInfo, JSCompiler_temp = root3.nodeType, 9 === JSCompiler_temp)
                      clearContainerSparingly(root3);
                    else if (1 === JSCompiler_temp)
                      switch (root3.nodeName) {
                        case "HEAD":
                        case "HTML":
                        case "BODY":
                          clearContainerSparingly(root3);
                          break;
                        default:
                          root3.textContent = "";
                      }
                  }
                  break;
                case 5:
                case 26:
                case 27:
                case 6:
                case 4:
                case 17:
                  break;
                default:
                  if (0 !== (root3 & 1024)) throw Error(formatProdErrorMessage(163));
              }
              root3 = firstChild.sibling;
              if (null !== root3) {
                root3.return = firstChild.return;
                nextEffect = root3;
                break;
              }
              nextEffect = firstChild.return;
            }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitHookEffectListMount(5, finishedWork);
            break;
          case 1:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 4)
              if (finishedRoot = finishedWork.stateNode, null === current)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error);
                }
              else {
                var prevProps = resolveClassComponentProps(
                  finishedWork.type,
                  current.memoizedProps
                );
                current = current.memoizedState;
                try {
                  finishedRoot.componentDidUpdate(
                    prevProps,
                    current,
                    finishedRoot.__reactInternalSnapshotBeforeUpdate
                  );
                } catch (error$142) {
                  captureCommitPhaseError(
                    finishedWork,
                    finishedWork.return,
                    error$142
                  );
                }
              }
            flags & 64 && commitClassCallbacks(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            if (flags & 64 && (finishedRoot = finishedWork.updateQueue, null !== finishedRoot)) {
              current = null;
              if (null !== finishedWork.child)
                switch (finishedWork.child.tag) {
                  case 27:
                  case 5:
                    current = finishedWork.child.stateNode;
                    break;
                  case 1:
                    current = finishedWork.child.stateNode;
                }
              try {
                commitCallbacks(finishedRoot, current);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 27:
            null === current && flags & 4 && commitHostSingletonAcquisition(finishedWork);
          case 26:
          case 5:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            null === current && flags & 4 && commitHostMount(finishedWork);
            flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
            break;
          case 12:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            break;
          case 13:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
            flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
              null,
              finishedWork
            ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
            break;
          case 22:
            flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
            if (!flags) {
              current = null !== current && null !== current.memoizedState || offscreenSubtreeWasHidden;
              prevProps = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = flags;
              (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                0 !== (finishedWork.subtreeFlags & 8772)
              ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
              offscreenSubtreeIsHidden = prevProps;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            }
            break;
          case 30:
            break;
          default:
            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
        }
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
        fiber.child = null;
        fiber.deletions = null;
        fiber.sibling = null;
        5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
        fiber.stateNode = null;
        fiber.return = null;
        fiber.dependencies = null;
        fiber.memoizedProps = null;
        fiber.memoizedState = null;
        fiber.pendingProps = null;
        fiber.stateNode = null;
        fiber.updateQueue = null;
      }
      var hostParent = null;
      var hostParentIsContainer = false;
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        for (parent = parent.child; null !== parent; )
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent), parent = parent.sibling;
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
          try {
            injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
          } catch (err) {
          }
        switch (deletedFiber.tag) {
          case 26:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
            break;
          case 27:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            releaseSingletonInstance(deletedFiber.stateNode);
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 5:
            offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
          case 6:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            if (null !== hostParent)
              if (hostParentIsContainer)
                try {
                  (9 === hostParent.nodeType ? hostParent.body : "HTML" === hostParent.nodeName ? hostParent.ownerDocument.body : hostParent).removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
              else
                try {
                  hostParent.removeChild(deletedFiber.stateNode);
                } catch (error) {
                  captureCommitPhaseError(
                    deletedFiber,
                    nearestMountedAncestor,
                    error
                  );
                }
            break;
          case 18:
            null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
              9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
              deletedFiber.stateNode
            ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
            break;
          case 4:
            prevHostParent = hostParent;
            prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo;
            hostParentIsContainer = true;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            hostParent = prevHostParent;
            hostParentIsContainer = prevHostParentIsContainer;
            break;
          case 0:
          case 11:
          case 14:
          case 15:
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);
            offscreenSubtreeWasHidden || commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 1:
            offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
              deletedFiber,
              nearestMountedAncestor,
              prevHostParent
            ));
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 21:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            break;
          case 22:
            offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
            offscreenSubtreeWasHidden = prevHostParent;
            break;
          default:
            recursivelyTraverseDeletionEffects(
              finishedRoot,
              nearestMountedAncestor,
              deletedFiber
            );
        }
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
          try {
            retryIfBlockedOn(finishedRoot);
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
      }
      function getRetryCache(finishedWork) {
        switch (finishedWork.tag) {
          case 13:
          case 19:
            var retryCache = finishedWork.stateNode;
            null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
            return retryCache;
          case 22:
            return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
          default:
            throw Error(formatProdErrorMessage(435, finishedWork.tag));
        }
      }
      function attachSuspenseRetryListeners(finishedWork, wakeables) {
        var retryCache = getRetryCache(finishedWork);
        wakeables.forEach(function(wakeable) {
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          retryCache.has(wakeable) || (retryCache.add(wakeable), wakeable.then(retry, retry));
        });
      }
      function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
        var deletions = parentFiber.deletions;
        if (null !== deletions)
          for (var i = 0; i < deletions.length; i++) {
            var childToDelete = deletions[i], root3 = root$jscomp$0, returnFiber = parentFiber, parent = returnFiber;
            a: for (; null !== parent; ) {
              switch (parent.tag) {
                case 27:
                  if (isSingletonScope(parent.type)) {
                    hostParent = parent.stateNode;
                    hostParentIsContainer = false;
                    break a;
                  }
                  break;
                case 5:
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break a;
                case 3:
                case 4:
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break a;
              }
              parent = parent.return;
            }
            if (null === hostParent) throw Error(formatProdErrorMessage(160));
            commitDeletionEffectsOnFiber(root3, returnFiber, childToDelete);
            hostParent = null;
            hostParentIsContainer = false;
            root3 = childToDelete.alternate;
            null !== root3 && (root3.return = null);
            childToDelete.return = null;
          }
        if (parentFiber.subtreeFlags & 13878)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
      }
      var currentHoistableRoot = null;
      function commitMutationEffectsOnFiber(finishedWork, root3) {
        var current = finishedWork.alternate, flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (commitHookEffectListUnmount(3, finishedWork, finishedWork.return), commitHookEffectListMount(3, finishedWork), commitHookEffectListUnmount(5, finishedWork, finishedWork.return));
            break;
          case 1:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current ? flags : current.concat(flags))));
            break;
          case 26:
            var hoistableRoot = currentHoistableRoot;
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (flags & 4) {
              var currentResource = null !== current ? current.memoizedState : null;
              flags = finishedWork.memoizedState;
              if (null === current)
                if (null === flags)
                  if (null === finishedWork.stateNode) {
                    a: {
                      flags = finishedWork.type;
                      current = finishedWork.memoizedProps;
                      hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
                      b: switch (flags) {
                        case "title":
                          currentResource = hoistableRoot.getElementsByTagName("title")[0];
                          if (!currentResource || currentResource[internalHoistableMarker] || currentResource[internalInstanceKey] || "http://www.w3.org/2000/svg" === currentResource.namespaceURI || currentResource.hasAttribute("itemprop"))
                            currentResource = hoistableRoot.createElement(flags), hoistableRoot.head.insertBefore(
                              currentResource,
                              hoistableRoot.querySelector("head > title")
                            );
                          setInitialProperties(currentResource, flags, current);
                          currentResource[internalInstanceKey] = finishedWork;
                          markNodeAsHoistable(currentResource);
                          flags = currentResource;
                          break a;
                        case "link":
                          var maybeNodes = getHydratableHoistableCache(
                            "link",
                            "href",
                            hoistableRoot
                          ).get(flags + (current.href || ""));
                          if (maybeNodes) {
                            for (var i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("href") === (null == current.href || "" === current.href ? null : current.href) && currentResource.getAttribute("rel") === (null == current.rel ? null : current.rel) && currentResource.getAttribute("title") === (null == current.title ? null : current.title) && currentResource.getAttribute("crossorigin") === (null == current.crossOrigin ? null : current.crossOrigin)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        case "meta":
                          if (maybeNodes = getHydratableHoistableCache(
                            "meta",
                            "content",
                            hoistableRoot
                          ).get(flags + (current.content || ""))) {
                            for (i = 0; i < maybeNodes.length; i++)
                              if (currentResource = maybeNodes[i], currentResource.getAttribute("content") === (null == current.content ? null : "" + current.content) && currentResource.getAttribute("name") === (null == current.name ? null : current.name) && currentResource.getAttribute("property") === (null == current.property ? null : current.property) && currentResource.getAttribute("http-equiv") === (null == current.httpEquiv ? null : current.httpEquiv) && currentResource.getAttribute("charset") === (null == current.charSet ? null : current.charSet)) {
                                maybeNodes.splice(i, 1);
                                break b;
                              }
                          }
                          currentResource = hoistableRoot.createElement(flags);
                          setInitialProperties(currentResource, flags, current);
                          hoistableRoot.head.appendChild(currentResource);
                          break;
                        default:
                          throw Error(formatProdErrorMessage(468, flags));
                      }
                      currentResource[internalInstanceKey] = finishedWork;
                      markNodeAsHoistable(currentResource);
                      flags = currentResource;
                    }
                    finishedWork.stateNode = flags;
                  } else
                    mountHoistable(
                      hoistableRoot,
                      finishedWork.type,
                      finishedWork.stateNode
                    );
                else
                  finishedWork.stateNode = acquireResource(
                    hoistableRoot,
                    flags,
                    finishedWork.memoizedProps
                  );
              else
                currentResource !== flags ? (null === currentResource ? null !== current.stateNode && (current = current.stateNode, current.parentNode.removeChild(current)) : currentResource.count--, null === flags ? mountHoistable(
                  hoistableRoot,
                  finishedWork.type,
                  finishedWork.stateNode
                ) : acquireResource(
                  hoistableRoot,
                  flags,
                  finishedWork.memoizedProps
                )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
                  finishedWork,
                  finishedWork.memoizedProps,
                  current.memoizedProps
                );
            }
            break;
          case 27:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            null !== current && flags & 4 && commitHostUpdate(
              finishedWork,
              finishedWork.memoizedProps,
              current.memoizedProps
            );
            break;
          case 5:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 512 && (offscreenSubtreeWasHidden || null === current || safelyDetachRef(current, current.return));
            if (finishedWork.flags & 32) {
              hoistableRoot = finishedWork.stateNode;
              try {
                setTextContent(hoistableRoot, "");
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            flags & 4 && null != finishedWork.stateNode && (hoistableRoot = finishedWork.memoizedProps, commitHostUpdate(
              finishedWork,
              hoistableRoot,
              null !== current ? current.memoizedProps : hoistableRoot
            ));
            flags & 1024 && (needsFormReset = true);
            break;
          case 6:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & 4) {
              if (null === finishedWork.stateNode)
                throw Error(formatProdErrorMessage(162));
              flags = finishedWork.memoizedProps;
              current = finishedWork.stateNode;
              try {
                current.nodeValue = flags;
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            }
            break;
          case 3:
            tagCaches = null;
            hoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(root3.containerInfo);
            recursivelyTraverseMutationEffects(root3, finishedWork);
            currentHoistableRoot = hoistableRoot;
            commitReconciliationEffects(finishedWork);
            if (flags & 4 && null !== current && current.memoizedState.isDehydrated)
              try {
                retryIfBlockedOn(root3.containerInfo);
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
            break;
          case 4:
            flags = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(
              finishedWork.stateNode.containerInfo
            );
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            currentHoistableRoot = flags;
            break;
          case 12:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            break;
          case 13:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current && null !== current.memoizedState) && (globalMostRecentFallbackTime = now());
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 22:
            hoistableRoot = null !== finishedWork.memoizedState;
            var wasHidden = null !== current && null !== current.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
            recursivelyTraverseMutationEffects(root3, finishedWork);
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
            commitReconciliationEffects(finishedWork);
            if (flags & 8192)
              a: for (root3 = finishedWork.stateNode, root3._visibility = hoistableRoot ? root3._visibility & -2 : root3._visibility | 1, hoistableRoot && (null === current || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current = null, root3 = finishedWork; ; ) {
                if (5 === root3.tag || 26 === root3.tag) {
                  if (null === current) {
                    wasHidden = current = root3;
                    try {
                      if (currentResource = wasHidden.stateNode, hoistableRoot)
                        maybeNodes = currentResource.style, "function" === typeof maybeNodes.setProperty ? maybeNodes.setProperty("display", "none", "important") : maybeNodes.display = "none";
                      else {
                        i = wasHidden.stateNode;
                        var styleProp = wasHidden.memoizedProps.style, display = void 0 !== styleProp && null !== styleProp && styleProp.hasOwnProperty("display") ? styleProp.display : null;
                        i.style.display = null == display || "boolean" === typeof display ? "" : ("" + display).trim();
                      }
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if (6 === root3.tag) {
                  if (null === current) {
                    wasHidden = root3;
                    try {
                      wasHidden.stateNode.nodeValue = hoistableRoot ? "" : wasHidden.memoizedProps;
                    } catch (error) {
                      captureCommitPhaseError(wasHidden, wasHidden.return, error);
                    }
                  }
                } else if ((22 !== root3.tag && 23 !== root3.tag || null === root3.memoizedState || root3 === finishedWork) && null !== root3.child) {
                  root3.child.return = root3;
                  root3 = root3.child;
                  continue;
                }
                if (root3 === finishedWork) break a;
                for (; null === root3.sibling; ) {
                  if (null === root3.return || root3.return === finishedWork) break a;
                  current === root3 && (current = null);
                  root3 = root3.return;
                }
                current === root3 && (current = null);
                root3.sibling.return = root3.return;
                root3 = root3.sibling;
              }
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current = flags.retryQueue, null !== current && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current))));
            break;
          case 19:
            recursivelyTraverseMutationEffects(root3, finishedWork);
            commitReconciliationEffects(finishedWork);
            flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
            break;
          case 30:
            break;
          case 21:
            break;
          default:
            recursivelyTraverseMutationEffects(root3, finishedWork), commitReconciliationEffects(finishedWork);
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & 2) {
          try {
            for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
              if (isHostParent(parentFiber)) {
                hostParentFiber = parentFiber;
                break;
              }
              parentFiber = parentFiber.return;
            }
            if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));
            switch (hostParentFiber.tag) {
              case 27:
                var parent = hostParentFiber.stateNode, before = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before, parent);
                break;
              case 5:
                var parent$144 = hostParentFiber.stateNode;
                hostParentFiber.flags & 32 && (setTextContent(parent$144, ""), hostParentFiber.flags &= -33);
                var before$145 = getHostSibling(finishedWork);
                insertOrAppendPlacementNode(finishedWork, before$145, parent$144);
                break;
              case 3:
              case 4:
                var parent$146 = hostParentFiber.stateNode.containerInfo, before$147 = getHostSibling(finishedWork);
                insertOrAppendPlacementNodeIntoContainer(
                  finishedWork,
                  before$147,
                  parent$146
                );
                break;
              default:
                throw Error(formatProdErrorMessage(161));
            }
          } catch (error) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error);
          }
          finishedWork.flags &= -3;
        }
        flags & 4096 && (finishedWork.flags &= -4097);
      }
      function recursivelyResetForms(parentFiber) {
        if (parentFiber.subtreeFlags & 1024)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var fiber = parentFiber;
            recursivelyResetForms(fiber);
            5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
            parentFiber = parentFiber.sibling;
          }
      }
      function recursivelyTraverseLayoutEffects(root3, parentFiber) {
        if (parentFiber.subtreeFlags & 8772)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitLayoutEffectOnFiber(root3, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
      }
      function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedWork = parentFiber;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
              commitHookEffectListUnmount(4, finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 1:
              safelyDetachRef(finishedWork, finishedWork.return);
              var instance2 = finishedWork.stateNode;
              "function" === typeof instance2.componentWillUnmount && safelyCallComponentWillUnmount(
                finishedWork,
                finishedWork.return,
                instance2
              );
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 27:
              releaseSingletonInstance(finishedWork.stateNode);
            case 26:
            case 5:
              safelyDetachRef(finishedWork, finishedWork.return);
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            case 30:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
              break;
            default:
              recursivelyTraverseDisappearLayoutEffects(finishedWork);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseReappearLayoutEffects(finishedRoot$jscomp$0, parentFiber, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var current = parentFiber.alternate, finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(4, finishedWork);
              break;
            case 1:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              current = finishedWork;
              finishedRoot = current.stateNode;
              if ("function" === typeof finishedRoot.componentDidMount)
                try {
                  finishedRoot.componentDidMount();
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              current = finishedWork;
              finishedRoot = current.updateQueue;
              if (null !== finishedRoot) {
                var instance2 = current.stateNode;
                try {
                  var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;
                  if (null !== hiddenCallbacks)
                    for (finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0; finishedRoot < hiddenCallbacks.length; finishedRoot++)
                      callCallback(hiddenCallbacks[finishedRoot], instance2);
                } catch (error) {
                  captureCommitPhaseError(current, current.return, error);
                }
              }
              includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 27:
              commitHostSingletonAcquisition(finishedWork);
            case 26:
            case 5:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && null === current && flags & 4 && commitHostMount(finishedWork);
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 12:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              break;
            case 13:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            case 22:
              null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
              safelyAttachRef(finishedWork, finishedWork.return);
              break;
            case 30:
              break;
            default:
              recursivelyTraverseReappearLayoutEffects(
                finishedRoot,
                finishedWork,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitOffscreenPassiveMountEffects(current, finishedWork) {
        var previousCache = null;
        null !== current && null !== current.memoizedState && null !== current.memoizedState.cachePool && (previousCache = current.memoizedState.cachePool.pool);
        current = null;
        null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current = finishedWork.memoizedState.cachePool.pool);
        current !== previousCache && (null != current && current.refCount++, null != previousCache && releaseCache(previousCache));
      }
      function commitCachePassiveMountEffect(current, finishedWork) {
        current = null;
        null !== finishedWork.alternate && (current = finishedWork.alternate.memoizedState.cache);
        finishedWork = finishedWork.memoizedState.cache;
        finishedWork !== current && (finishedWork.refCount++, null != current && releaseCache(current));
      }
      function recursivelyTraversePassiveMountEffects(root3, parentFiber, committedLanes, committedTransitions) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveMountOnFiber(
              root3,
              parentFiber,
              committedLanes,
              committedTransitions
            ), parentFiber = parentFiber.sibling;
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitHookEffectListMount(9, finishedWork);
            break;
          case 1:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 3:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && (finishedRoot = null, null !== finishedWork.alternate && (finishedRoot = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== finishedRoot && (finishedWork.refCount++, null != finishedRoot && releaseCache(finishedRoot)));
            break;
          case 12:
            if (flags & 2048) {
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
              finishedRoot = finishedWork.stateNode;
              try {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, id = _finishedWork$memoize2.id, onPostCommit = _finishedWork$memoize2.onPostCommit;
                "function" === typeof onPostCommit && onPostCommit(
                  id,
                  null === finishedWork.alternate ? "mount" : "update",
                  finishedRoot.passiveEffectDuration,
                  -0
                );
              } catch (error) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error);
              }
            } else
              recursivelyTraversePassiveMountEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions
              );
            break;
          case 13:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            break;
          case 23:
            break;
          case 22:
            _finishedWork$memoize2 = finishedWork.stateNode;
            id = finishedWork.alternate;
            null !== finishedWork.memoizedState ? _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork) : _finishedWork$memoize2._visibility & 2 ? recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            ) : (_finishedWork$memoize2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions,
              0 !== (finishedWork.subtreeFlags & 10256)
            ));
            flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);
            break;
          case 24:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
            flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
            break;
          default:
            recursivelyTraversePassiveMountEffects(
              finishedRoot,
              finishedWork,
              committedLanes,
              committedTransitions
            );
        }
      }
      function recursivelyTraverseReconnectPassiveEffects(finishedRoot$jscomp$0, parentFiber, committedLanes$jscomp$0, committedTransitions$jscomp$0, includeWorkInProgressEffects) {
        includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, committedLanes = committedLanes$jscomp$0, committedTransitions = committedTransitions$jscomp$0, flags = finishedWork.flags;
          switch (finishedWork.tag) {
            case 0:
            case 11:
            case 15:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              commitHookEffectListMount(8, finishedWork);
              break;
            case 23:
              break;
            case 22:
              var instance2 = finishedWork.stateNode;
              null !== finishedWork.memoizedState ? instance2._visibility & 2 ? recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ) : recursivelyTraverseAtomicPassiveEffects(
                finishedRoot,
                finishedWork
              ) : (instance2._visibility |= 2, recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              ));
              includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
                finishedWork.alternate,
                finishedWork
              );
              break;
            case 24:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
              includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
              break;
            default:
              recursivelyTraverseReconnectPassiveEffects(
                finishedRoot,
                finishedWork,
                committedLanes,
                committedTransitions,
                includeWorkInProgressEffects
              );
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; ) {
            var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
            switch (finishedWork.tag) {
              case 22:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitOffscreenPassiveMountEffects(
                  finishedWork.alternate,
                  finishedWork
                );
                break;
              case 24:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
                flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
                break;
              default:
                recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);
            }
            parentFiber = parentFiber.sibling;
          }
      }
      var suspenseyCommitFlag = 8192;
      function recursivelyAccumulateSuspenseyCommit(parentFiber) {
        if (parentFiber.subtreeFlags & suspenseyCommitFlag)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function accumulateSuspenseyCommitOnFiber(fiber) {
        switch (fiber.tag) {
          case 26:
            recursivelyAccumulateSuspenseyCommit(fiber);
            fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
              currentHoistableRoot,
              fiber.memoizedState,
              fiber.memoizedProps
            );
            break;
          case 5:
            recursivelyAccumulateSuspenseyCommit(fiber);
            break;
          case 3:
          case 4:
            var previousHoistableRoot = currentHoistableRoot;
            currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);
            recursivelyAccumulateSuspenseyCommit(fiber);
            currentHoistableRoot = previousHoistableRoot;
            break;
          case 22:
            null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
            break;
          default:
            recursivelyAccumulateSuspenseyCommit(fiber);
        }
      }
      function detachAlternateSiblings(parentFiber) {
        var previousFiber = parentFiber.alternate;
        if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
          previousFiber.child = null;
          do
            previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
          while (null !== parentFiber);
        }
      }
      function recursivelyTraversePassiveUnmountEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        if (parentFiber.subtreeFlags & 10256)
          for (parentFiber = parentFiber.child; null !== parentFiber; )
            commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case 0:
          case 11:
          case 15:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            finishedWork.flags & 2048 && commitHookEffectListUnmount(9, finishedWork, finishedWork.return);
            break;
          case 3:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 12:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          case 22:
            var instance2 = finishedWork.stateNode;
            null !== finishedWork.memoizedState && instance2._visibility & 2 && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (instance2._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
            break;
          default:
            recursivelyTraversePassiveUnmountEffects(finishedWork);
        }
      }
      function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
        var deletions = parentFiber.deletions;
        if (0 !== (parentFiber.flags & 16)) {
          if (null !== deletions)
            for (var i = 0; i < deletions.length; i++) {
              var childToDelete = deletions[i];
              nextEffect = childToDelete;
              commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
                childToDelete,
                parentFiber
              );
            }
          detachAlternateSiblings(parentFiber);
        }
        for (parentFiber = parentFiber.child; null !== parentFiber; ) {
          deletions = parentFiber;
          switch (deletions.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, deletions, deletions.return);
              recursivelyTraverseDisconnectPassiveEffects(deletions);
              break;
            case 22:
              i = deletions.stateNode;
              i._visibility & 2 && (i._visibility &= -3, recursivelyTraverseDisconnectPassiveEffects(deletions));
              break;
            default:
              recursivelyTraverseDisconnectPassiveEffects(deletions);
          }
          parentFiber = parentFiber.sibling;
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        for (; null !== nextEffect; ) {
          var fiber = nextEffect;
          switch (fiber.tag) {
            case 0:
            case 11:
            case 15:
              commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);
              break;
            case 23:
            case 22:
              if (null !== fiber.memoizedState && null !== fiber.memoizedState.cachePool) {
                var cache = fiber.memoizedState.cachePool.pool;
                null != cache && cache.refCount++;
              }
              break;
            case 24:
              releaseCache(fiber.memoizedState.cache);
          }
          cache = fiber.child;
          if (null !== cache) cache.return = fiber, nextEffect = cache;
          else
            a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
              cache = nextEffect;
              var sibling = cache.sibling, returnFiber = cache.return;
              detachFiberAfterEffects(cache);
              if (cache === fiber) {
                nextEffect = null;
                break a;
              }
              if (null !== sibling) {
                sibling.return = returnFiber;
                nextEffect = sibling;
                break a;
              }
              nextEffect = returnFiber;
            }
        }
      }
      var DefaultAsyncDispatcher = {
        getCacheForType: function(resourceType) {
          var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
          void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
          return cacheForType;
        }
      };
      var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
      var executionContext = 0;
      var workInProgressRoot = null;
      var workInProgress = null;
      var workInProgressRootRenderLanes = 0;
      var workInProgressSuspendedReason = 0;
      var workInProgressThrownValue = null;
      var workInProgressRootDidSkipSuspendedSiblings = false;
      var workInProgressRootIsPrerendering = false;
      var workInProgressRootDidAttachPingListener = false;
      var entangledRenderLanes = 0;
      var workInProgressRootExitStatus = 0;
      var workInProgressRootSkippedLanes = 0;
      var workInProgressRootInterleavedUpdatedLanes = 0;
      var workInProgressRootPingedLanes = 0;
      var workInProgressDeferredLane = 0;
      var workInProgressSuspendedRetryLanes = 0;
      var workInProgressRootConcurrentErrors = null;
      var workInProgressRootRecoverableErrors = null;
      var workInProgressRootDidIncludeRecursiveRenderUpdate = false;
      var globalMostRecentFallbackTime = 0;
      var workInProgressRootRenderTargetTime = Infinity;
      var workInProgressTransitions = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var pendingEffectsStatus = 0;
      var pendingEffectsRoot = null;
      var pendingFinishedWork = null;
      var pendingEffectsLanes = 0;
      var pendingEffectsRemainingLanes = 0;
      var pendingPassiveTransitions = null;
      var pendingRecoverableErrors = null;
      var nestedUpdateCount = 0;
      var rootWithNestedUpdates = null;
      function requestUpdateLane() {
        if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)
          return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
        if (null !== ReactSharedInternals.T) {
          var actionScopeLane = currentEntangledLane;
          return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();
        }
        return resolveUpdatePriority();
      }
      function requestDeferredLane() {
        0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
        var suspenseHandler = suspenseHandlerStackCursor.current;
        null !== suspenseHandler && (suspenseHandler.flags |= 32);
        return workInProgressDeferredLane;
      }
      function scheduleUpdateOnFiber(root3, fiber, lane) {
        if (root3 === workInProgressRoot && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
          prepareFreshStack(root3, 0), markRootSuspended(
            root3,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          );
        markRootUpdated$1(root3, lane);
        if (0 === (executionContext & 2) || root3 !== workInProgressRoot)
          root3 === workInProgressRoot && (0 === (executionContext & 2) && (workInProgressRootInterleavedUpdatedLanes |= lane), 4 === workInProgressRootExitStatus && markRootSuspended(
            root3,
            workInProgressRootRenderLanes,
            workInProgressDeferredLane,
            false
          )), ensureRootIsScheduled(root3);
      }
      function performWorkOnRoot(root$jscomp$0, lanes, forceSync) {
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root$jscomp$0.expiredLanes) || checkIfRootIsPrerendering(root$jscomp$0, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root$jscomp$0, lanes) : renderRootSync(root$jscomp$0, lanes, true), renderWasConcurrent = shouldTimeSlice;
        do {
          if (0 === exitStatus) {
            workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root$jscomp$0, lanes, 0, false);
            break;
          } else {
            forceSync = root$jscomp$0.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
              exitStatus = renderRootSync(root$jscomp$0, lanes, false);
              renderWasConcurrent = false;
              continue;
            }
            if (2 === exitStatus) {
              renderWasConcurrent = lanes;
              if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)
                var JSCompiler_inline_result = 0;
              else
                JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913, JSCompiler_inline_result = 0 !== JSCompiler_inline_result ? JSCompiler_inline_result : JSCompiler_inline_result & 536870912 ? 536870912 : 0;
              if (0 !== JSCompiler_inline_result) {
                lanes = JSCompiler_inline_result;
                a: {
                  var root3 = root$jscomp$0;
                  exitStatus = workInProgressRootConcurrentErrors;
                  var wasRootDehydrated = root3.current.memoizedState.isDehydrated;
                  wasRootDehydrated && (prepareFreshStack(root3, JSCompiler_inline_result).flags |= 256);
                  JSCompiler_inline_result = renderRootSync(
                    root3,
                    JSCompiler_inline_result,
                    false
                  );
                  if (2 !== JSCompiler_inline_result) {
                    if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
                      root3.errorRecoveryDisabledLanes |= renderWasConcurrent;
                      workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
                      exitStatus = 4;
                      break a;
                    }
                    renderWasConcurrent = workInProgressRootRecoverableErrors;
                    workInProgressRootRecoverableErrors = exitStatus;
                    null !== renderWasConcurrent && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = renderWasConcurrent : workInProgressRootRecoverableErrors.push.apply(
                      workInProgressRootRecoverableErrors,
                      renderWasConcurrent
                    ));
                  }
                  exitStatus = JSCompiler_inline_result;
                }
                renderWasConcurrent = false;
                if (2 !== exitStatus) continue;
              }
            }
            if (1 === exitStatus) {
              prepareFreshStack(root$jscomp$0, 0);
              markRootSuspended(root$jscomp$0, lanes, 0, true);
              break;
            }
            a: {
              shouldTimeSlice = root$jscomp$0;
              renderWasConcurrent = exitStatus;
              switch (renderWasConcurrent) {
                case 0:
                case 1:
                  throw Error(formatProdErrorMessage(345));
                case 4:
                  if ((lanes & 4194048) !== lanes) break;
                case 6:
                  markRootSuspended(
                    shouldTimeSlice,
                    lanes,
                    workInProgressDeferredLane,
                    !workInProgressRootDidSkipSuspendedSiblings
                  );
                  break a;
                case 2:
                  workInProgressRootRecoverableErrors = null;
                  break;
                case 3:
                case 5:
                  break;
                default:
                  throw Error(formatProdErrorMessage(329));
              }
              if ((lanes & 62914560) === lanes && (exitStatus = globalMostRecentFallbackTime + 300 - now(), 10 < exitStatus)) {
                markRootSuspended(
                  shouldTimeSlice,
                  lanes,
                  workInProgressDeferredLane,
                  !workInProgressRootDidSkipSuspendedSiblings
                );
                if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
                shouldTimeSlice.timeoutHandle = scheduleTimeout(
                  commitRootWhenReady.bind(
                    null,
                    shouldTimeSlice,
                    forceSync,
                    workInProgressRootRecoverableErrors,
                    workInProgressTransitions,
                    workInProgressRootDidIncludeRecursiveRenderUpdate,
                    lanes,
                    workInProgressDeferredLane,
                    workInProgressRootInterleavedUpdatedLanes,
                    workInProgressSuspendedRetryLanes,
                    workInProgressRootDidSkipSuspendedSiblings,
                    renderWasConcurrent,
                    2,
                    -0,
                    0
                  ),
                  exitStatus
                );
                break a;
              }
              commitRootWhenReady(
                shouldTimeSlice,
                forceSync,
                workInProgressRootRecoverableErrors,
                workInProgressTransitions,
                workInProgressRootDidIncludeRecursiveRenderUpdate,
                lanes,
                workInProgressDeferredLane,
                workInProgressRootInterleavedUpdatedLanes,
                workInProgressSuspendedRetryLanes,
                workInProgressRootDidSkipSuspendedSiblings,
                renderWasConcurrent,
                0,
                -0,
                0
              );
            }
          }
          break;
        } while (1);
        ensureRootIsScheduled(root$jscomp$0);
      }
      function commitRootWhenReady(root3, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
        root3.timeoutHandle = -1;
        suspendedCommitReason = finishedWork.subtreeFlags;
        if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
          if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop6 }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
            root3.cancelPendingCommit = suspendedCommitReason(
              commitRoot.bind(
                null,
                root3,
                finishedWork,
                lanes,
                recoverableErrors,
                transitions,
                didIncludeRenderPhaseUpdate,
                spawnedLane,
                updatedLanes,
                suspendedRetryLanes,
                exitStatus,
                1,
                completedRenderStartTime,
                completedRenderEndTime
              )
            );
            markRootSuspended(root3, lanes, spawnedLane, !didSkipSuspendedSiblings);
            return;
          }
        }
        commitRoot(
          root3,
          finishedWork,
          lanes,
          recoverableErrors,
          transitions,
          didIncludeRenderPhaseUpdate,
          spawnedLane,
          updatedLanes,
          suspendedRetryLanes
        );
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        for (var node2 = finishedWork; ; ) {
          var tag = node2.tag;
          if ((0 === tag || 11 === tag || 15 === tag) && node2.flags & 16384 && (tag = node2.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
            for (var i = 0; i < tag.length; i++) {
              var check = tag[i], getSnapshot = check.getSnapshot;
              check = check.value;
              try {
                if (!objectIs(getSnapshot(), check)) return false;
              } catch (error) {
                return false;
              }
            }
          tag = node2.child;
          if (node2.subtreeFlags & 16384 && null !== tag)
            tag.return = node2, node2 = tag;
          else {
            if (node2 === finishedWork) break;
            for (; null === node2.sibling; ) {
              if (null === node2.return || node2.return === finishedWork) return true;
              node2 = node2.return;
            }
            node2.sibling.return = node2.return;
            node2 = node2.sibling;
          }
        }
        return true;
      }
      function markRootSuspended(root3, suspendedLanes, spawnedLane, didAttemptEntireTree) {
        suspendedLanes &= ~workInProgressRootPingedLanes;
        suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
        root3.suspendedLanes |= suspendedLanes;
        root3.pingedLanes &= ~suspendedLanes;
        didAttemptEntireTree && (root3.warmLanes |= suspendedLanes);
        didAttemptEntireTree = root3.expirationTimes;
        for (var lanes = suspendedLanes; 0 < lanes; ) {
          var index$4 = 31 - clz32(lanes), lane = 1 << index$4;
          didAttemptEntireTree[index$4] = -1;
          lanes &= ~lane;
        }
        0 !== spawnedLane && markSpawnedDeferredLane(root3, spawnedLane, suspendedLanes);
      }
      function flushSyncWork$1() {
        return 0 === (executionContext & 6) ? (flushSyncWorkAcrossRoots_impl(0, false), false) : true;
      }
      function resetWorkInProgressStack() {
        if (null !== workInProgress) {
          if (0 === workInProgressSuspendedReason)
            var interruptedWork = workInProgress.return;
          else
            interruptedWork = workInProgress, lastContextDependency = currentlyRenderingFiber$1 = null, resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
          for (; null !== interruptedWork; )
            unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
          workInProgress = null;
        }
      }
      function prepareFreshStack(root3, lanes) {
        var timeoutHandle = root3.timeoutHandle;
        -1 !== timeoutHandle && (root3.timeoutHandle = -1, cancelTimeout(timeoutHandle));
        timeoutHandle = root3.cancelPendingCommit;
        null !== timeoutHandle && (root3.cancelPendingCommit = null, timeoutHandle());
        resetWorkInProgressStack();
        workInProgressRoot = root3;
        workInProgress = timeoutHandle = createWorkInProgress(root3.current, null);
        workInProgressRootRenderLanes = lanes;
        workInProgressSuspendedReason = 0;
        workInProgressThrownValue = null;
        workInProgressRootDidSkipSuspendedSiblings = false;
        workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root3, lanes);
        workInProgressRootDidAttachPingListener = false;
        workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = workInProgressRootExitStatus = 0;
        workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
        workInProgressRootDidIncludeRecursiveRenderUpdate = false;
        0 !== (lanes & 8) && (lanes |= lanes & 32);
        var allEntangledLanes = root3.entangledLanes;
        if (0 !== allEntangledLanes)
          for (root3 = root3.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
            var index$2 = 31 - clz32(allEntangledLanes), lane = 1 << index$2;
            lanes |= root3[index$2];
            allEntangledLanes &= ~lane;
          }
        entangledRenderLanes = lanes;
        finishQueueingConcurrentUpdates();
        return timeoutHandle;
      }
      function handleThrow(root3, thrownValue) {
        currentlyRenderingFiber = null;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 3) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = 4) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? 8 : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? 6 : 1;
        workInProgressThrownValue = thrownValue;
        null === workInProgress && (workInProgressRootExitStatus = 1, logUncaughtError(
          root3,
          createCapturedValueAtFiber(thrownValue, root3.current)
        ));
      }
      function pushDispatcher() {
        var prevDispatcher = ReactSharedInternals.H;
        ReactSharedInternals.H = ContextOnlyDispatcher;
        return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
      }
      function pushAsyncDispatcher() {
        var prevAsyncDispatcher = ReactSharedInternals.A;
        ReactSharedInternals.A = DefaultAsyncDispatcher;
        return prevAsyncDispatcher;
      }
      function renderDidSuspendDelayIfPossible() {
        workInProgressRootExitStatus = 4;
        workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
        0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
          workInProgressRoot,
          workInProgressRootRenderLanes,
          workInProgressDeferredLane,
          false
        );
      }
      function renderRootSync(root3, lanes, shouldYieldForPrerendering) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        if (workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes)
          workInProgressTransitions = null, prepareFreshStack(root3, lanes);
        lanes = false;
        var exitStatus = workInProgressRootExitStatus;
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
              switch (workInProgressSuspendedReason) {
                case 8:
                  resetWorkInProgressStack();
                  exitStatus = 6;
                  break a;
                case 3:
                case 2:
                case 9:
                case 6:
                  null === suspenseHandlerStackCursor.current && (lanes = true);
                  var reason = workInProgressSuspendedReason;
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
                  if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
                    exitStatus = 0;
                    break a;
                  }
                  break;
                default:
                  reason = workInProgressSuspendedReason, workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, reason);
              }
            }
            workLoopSync();
            exitStatus = workInProgressRootExitStatus;
            break;
          } catch (thrownValue$167) {
            handleThrow(root3, thrownValue$167);
          }
        while (1);
        lanes && root3.shellSuspendCounter++;
        lastContextDependency = currentlyRenderingFiber$1 = null;
        executionContext = prevExecutionContext;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
        return exitStatus;
      }
      function workLoopSync() {
        for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
      }
      function renderRootConcurrent(root3, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= 2;
        var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
        workInProgressRoot !== root3 || workInProgressRootRenderLanes !== lanes ? (workInProgressTransitions = null, workInProgressRootRenderTargetTime = now() + 500, prepareFreshStack(root3, lanes)) : workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
          root3,
          lanes
        );
        a: do
          try {
            if (0 !== workInProgressSuspendedReason && null !== workInProgress) {
              lanes = workInProgress;
              var thrownValue = workInProgressThrownValue;
              b: switch (workInProgressSuspendedReason) {
                case 1:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, lanes, thrownValue, 1);
                  break;
                case 2:
                case 9:
                  if (isThenableResolved(thrownValue)) {
                    workInProgressSuspendedReason = 0;
                    workInProgressThrownValue = null;
                    replaySuspendedUnitOfWork(lanes);
                    break;
                  }
                  lanes = function() {
                    2 !== workInProgressSuspendedReason && 9 !== workInProgressSuspendedReason || workInProgressRoot !== root3 || (workInProgressSuspendedReason = 7);
                    ensureRootIsScheduled(root3);
                  };
                  thrownValue.then(lanes, lanes);
                  break a;
                case 3:
                  workInProgressSuspendedReason = 7;
                  break a;
                case 4:
                  workInProgressSuspendedReason = 5;
                  break a;
                case 7:
                  isThenableResolved(thrownValue) ? (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = 0, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root3, lanes, thrownValue, 7));
                  break;
                case 5:
                  var resource = null;
                  switch (workInProgress.tag) {
                    case 26:
                      resource = workInProgress.memoizedState;
                    case 5:
                    case 27:
                      var hostFiber = workInProgress;
                      if (resource ? preloadResource(resource) : 1) {
                        workInProgressSuspendedReason = 0;
                        workInProgressThrownValue = null;
                        var sibling = hostFiber.sibling;
                        if (null !== sibling) workInProgress = sibling;
                        else {
                          var returnFiber = hostFiber.return;
                          null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
                        }
                        break b;
                      }
                  }
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, lanes, thrownValue, 5);
                  break;
                case 6:
                  workInProgressSuspendedReason = 0;
                  workInProgressThrownValue = null;
                  throwAndUnwindWorkLoop(root3, lanes, thrownValue, 6);
                  break;
                case 8:
                  resetWorkInProgressStack();
                  workInProgressRootExitStatus = 6;
                  break a;
                default:
                  throw Error(formatProdErrorMessage(462));
              }
            }
            workLoopConcurrentByScheduler();
            break;
          } catch (thrownValue$169) {
            handleThrow(root3, thrownValue$169);
          }
        while (1);
        lastContextDependency = currentlyRenderingFiber$1 = null;
        ReactSharedInternals.H = prevDispatcher;
        ReactSharedInternals.A = prevAsyncDispatcher;
        executionContext = prevExecutionContext;
        if (null !== workInProgress) return 0;
        workInProgressRoot = null;
        workInProgressRootRenderLanes = 0;
        finishQueueingConcurrentUpdates();
        return workInProgressRootExitStatus;
      }
      function workLoopConcurrentByScheduler() {
        for (; null !== workInProgress && !shouldYield(); )
          performUnitOfWork(workInProgress);
      }
      function performUnitOfWork(unitOfWork) {
        var next2 = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next2 ? completeUnitOfWork(unitOfWork) : workInProgress = next2;
      }
      function replaySuspendedUnitOfWork(unitOfWork) {
        var next2 = unitOfWork;
        var current = next2.alternate;
        switch (next2.tag) {
          case 15:
          case 0:
            next2 = replayFunctionComponent(
              current,
              next2,
              next2.pendingProps,
              next2.type,
              void 0,
              workInProgressRootRenderLanes
            );
            break;
          case 11:
            next2 = replayFunctionComponent(
              current,
              next2,
              next2.pendingProps,
              next2.type.render,
              next2.ref,
              workInProgressRootRenderLanes
            );
            break;
          case 5:
            resetHooksOnUnwind(next2);
          default:
            unwindInterruptedWork(current, next2), next2 = workInProgress = resetWorkInProgress(next2, entangledRenderLanes), next2 = beginWork(current, next2, entangledRenderLanes);
        }
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        null === next2 ? completeUnitOfWork(unitOfWork) : workInProgress = next2;
      }
      function throwAndUnwindWorkLoop(root3, unitOfWork, thrownValue, suspendedReason) {
        lastContextDependency = currentlyRenderingFiber$1 = null;
        resetHooksOnUnwind(unitOfWork);
        thenableState = null;
        thenableIndexCounter = 0;
        var returnFiber = unitOfWork.return;
        try {
          if (throwException(
            root3,
            returnFiber,
            unitOfWork,
            thrownValue,
            workInProgressRootRenderLanes
          )) {
            workInProgressRootExitStatus = 1;
            logUncaughtError(
              root3,
              createCapturedValueAtFiber(thrownValue, root3.current)
            );
            workInProgress = null;
            return;
          }
        } catch (error) {
          if (null !== returnFiber) throw workInProgress = returnFiber, error;
          workInProgressRootExitStatus = 1;
          logUncaughtError(
            root3,
            createCapturedValueAtFiber(thrownValue, root3.current)
          );
          workInProgress = null;
          return;
        }
        if (unitOfWork.flags & 32768) {
          if (isHydrating || 1 === suspendedReason) root3 = true;
          else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
            root3 = false;
          else if (workInProgressRootDidSkipSuspendedSiblings = root3 = true, 2 === suspendedReason || 9 === suspendedReason || 3 === suspendedReason || 6 === suspendedReason)
            suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
          unwindUnitOfWork(unitOfWork, root3);
        } else completeUnitOfWork(unitOfWork);
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          if (0 !== (completedWork.flags & 32768)) {
            unwindUnitOfWork(
              completedWork,
              workInProgressRootDidSkipSuspendedSiblings
            );
            return;
          }
          unitOfWork = completedWork.return;
          var next2 = completeWork(
            completedWork.alternate,
            completedWork,
            entangledRenderLanes
          );
          if (null !== next2) {
            workInProgress = next2;
            return;
          }
          completedWork = completedWork.sibling;
          if (null !== completedWork) {
            workInProgress = completedWork;
            return;
          }
          workInProgress = completedWork = unitOfWork;
        } while (null !== completedWork);
        0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);
      }
      function unwindUnitOfWork(unitOfWork, skipSiblings) {
        do {
          var next2 = unwindWork(unitOfWork.alternate, unitOfWork);
          if (null !== next2) {
            next2.flags &= 32767;
            workInProgress = next2;
            return;
          }
          next2 = unitOfWork.return;
          null !== next2 && (next2.flags |= 32768, next2.subtreeFlags = 0, next2.deletions = null);
          if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
            workInProgress = unitOfWork;
            return;
          }
          workInProgress = unitOfWork = next2;
        } while (null !== unitOfWork);
        workInProgressRootExitStatus = 6;
        workInProgress = null;
      }
      function commitRoot(root3, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
        root3.cancelPendingCommit = null;
        do
          flushPendingEffects();
        while (0 !== pendingEffectsStatus);
        if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));
        if (null !== finishedWork) {
          if (finishedWork === root3.current) throw Error(formatProdErrorMessage(177));
          didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
          didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
          markRootFinished(
            root3,
            lanes,
            didIncludeRenderPhaseUpdate,
            spawnedLane,
            updatedLanes,
            suspendedRetryLanes
          );
          root3 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
          pendingFinishedWork = finishedWork;
          pendingEffectsRoot = root3;
          pendingEffectsLanes = lanes;
          pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
          pendingPassiveTransitions = transitions;
          pendingRecoverableErrors = recoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root3.callbackNode = null, root3.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
            flushPassiveEffects(true);
            return null;
          })) : (root3.callbackNode = null, root3.callbackPriority = 0);
          recoverableErrors = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
            recoverableErrors = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            transitions = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            spawnedLane = executionContext;
            executionContext |= 4;
            try {
              commitBeforeMutationEffects(root3, finishedWork, lanes);
            } finally {
              executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
            }
          }
          pendingEffectsStatus = 1;
          flushMutationEffects();
          flushLayoutEffects();
          flushSpawnedWork();
        }
      }
      function flushMutationEffects() {
        if (1 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
          if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
            rootMutationHasEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitMutationEffectsOnFiber(finishedWork, root3);
              var priorSelectionInformation = selectionInformation, curFocusedElem = getActiveElementDeep(root3.containerInfo), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
              if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
                priorFocusedElem.ownerDocument.documentElement,
                priorFocusedElem
              )) {
                if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
                  var start3 = priorSelectionRange.start, end2 = priorSelectionRange.end;
                  void 0 === end2 && (end2 = start3);
                  if ("selectionStart" in priorFocusedElem)
                    priorFocusedElem.selectionStart = start3, priorFocusedElem.selectionEnd = Math.min(
                      end2,
                      priorFocusedElem.value.length
                    );
                  else {
                    var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
                    if (win.getSelection) {
                      var selection = win.getSelection(), length2 = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(priorSelectionRange.start, length2), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length2);
                      !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
                      var startMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        start$jscomp$0
                      ), endMarker = getNodeForCharacterOffset(
                        priorFocusedElem,
                        end$jscomp$0
                      );
                      if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
                        var range2 = doc.createRange();
                        range2.setStart(startMarker.node, startMarker.offset);
                        selection.removeAllRanges();
                        start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range2), selection.extend(endMarker.node, endMarker.offset)) : (range2.setEnd(endMarker.node, endMarker.offset), selection.addRange(range2));
                      }
                    }
                  }
                }
                doc = [];
                for (selection = priorFocusedElem; selection = selection.parentNode; )
                  1 === selection.nodeType && doc.push({
                    element: selection,
                    left: selection.scrollLeft,
                    top: selection.scrollTop
                  });
                "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
                for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
                  var info = doc[priorFocusedElem];
                  info.element.scrollLeft = info.left;
                  info.element.scrollTop = info.top;
                }
              }
              _enabled = !!eventsEnabled;
              selectionInformation = eventsEnabled = null;
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
            }
          }
          root3.current = finishedWork;
          pendingEffectsStatus = 2;
        }
      }
      function flushLayoutEffects() {
        if (2 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
          if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
            rootHasLayoutEffect = ReactSharedInternals.T;
            ReactSharedInternals.T = null;
            var previousPriority = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            var prevExecutionContext = executionContext;
            executionContext |= 4;
            try {
              commitLayoutEffectOnFiber(root3, finishedWork.alternate, finishedWork);
            } finally {
              executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
            }
          }
          pendingEffectsStatus = 3;
        }
      }
      function flushSpawnedWork() {
        if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {
          pendingEffectsStatus = 0;
          requestPaint();
          var root3 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors;
          0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? pendingEffectsStatus = 5 : (pendingEffectsStatus = 0, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root3, root3.pendingLanes));
          var remainingLanes = root3.pendingLanes;
          0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
          lanesToEventPriority(lanes);
          finishedWork = finishedWork.stateNode;
          if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
            try {
              injectedHook.onCommitFiberRoot(
                rendererID,
                finishedWork,
                void 0,
                128 === (finishedWork.current.flags & 128)
              );
            } catch (err) {
            }
          if (null !== recoverableErrors) {
            finishedWork = ReactSharedInternals.T;
            remainingLanes = ReactDOMSharedInternals.p;
            ReactDOMSharedInternals.p = 2;
            ReactSharedInternals.T = null;
            try {
              for (var onRecoverableError = root3.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
                var recoverableError = recoverableErrors[i];
                onRecoverableError(recoverableError.value, {
                  componentStack: recoverableError.stack
                });
              }
            } finally {
              ReactSharedInternals.T = finishedWork, ReactDOMSharedInternals.p = remainingLanes;
            }
          }
          0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
          ensureRootIsScheduled(root3);
          remainingLanes = root3.pendingLanes;
          0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? root3 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root3) : nestedUpdateCount = 0;
          flushSyncWorkAcrossRoots_impl(0, false);
        }
      }
      function releaseRootPooledCache(root3, remainingLanes) {
        0 === (root3.pooledCacheLanes &= remainingLanes) && (remainingLanes = root3.pooledCache, null != remainingLanes && (root3.pooledCache = null, releaseCache(remainingLanes)));
      }
      function flushPendingEffects(wasDelayedCommit) {
        flushMutationEffects();
        flushLayoutEffects();
        flushSpawnedWork();
        return flushPassiveEffects(wasDelayedCommit);
      }
      function flushPassiveEffects() {
        if (5 !== pendingEffectsStatus) return false;
        var root3 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
        pendingEffectsRemainingLanes = 0;
        var renderPriority = lanesToEventPriority(pendingEffectsLanes), prevTransition = ReactSharedInternals.T, previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;
          ReactSharedInternals.T = null;
          renderPriority = pendingPassiveTransitions;
          pendingPassiveTransitions = null;
          var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
          pendingEffectsStatus = 0;
          pendingFinishedWork = pendingEffectsRoot = null;
          pendingEffectsLanes = 0;
          if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));
          var prevExecutionContext = executionContext;
          executionContext |= 4;
          commitPassiveUnmountOnFiber(root$jscomp$0.current);
          commitPassiveMountOnFiber(
            root$jscomp$0,
            root$jscomp$0.current,
            lanes,
            renderPriority
          );
          executionContext = prevExecutionContext;
          flushSyncWorkAcrossRoots_impl(0, false);
          if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
            try {
              injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
            } catch (err) {
            }
          return true;
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, releaseRootPooledCache(root3, remainingLanes);
        }
      }
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
        sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
        sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
        rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
        null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
        if (3 === sourceFiber.tag)
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
        else
          for (; null !== nearestMountedAncestor; ) {
            if (3 === nearestMountedAncestor.tag) {
              captureCommitPhaseErrorOnRoot(
                nearestMountedAncestor,
                sourceFiber,
                error
              );
              break;
            } else if (1 === nearestMountedAncestor.tag) {
              var instance2 = nearestMountedAncestor.stateNode;
              if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance2.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance2))) {
                sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
                error = createClassErrorUpdate(2);
                instance2 = enqueueUpdate(nearestMountedAncestor, error, 2);
                null !== instance2 && (initializeClassErrorUpdate(
                  error,
                  instance2,
                  nearestMountedAncestor,
                  sourceFiber
                ), markRootUpdated$1(instance2, 2), ensureRootIsScheduled(instance2));
                break;
              }
            }
            nearestMountedAncestor = nearestMountedAncestor.return;
          }
      }
      function attachPingListener(root3, wakeable, lanes) {
        var pingCache = root3.pingCache;
        if (null === pingCache) {
          pingCache = root3.pingCache = new PossiblyWeakMap();
          var threadIDs = /* @__PURE__ */ new Set();
          pingCache.set(wakeable, threadIDs);
        } else
          threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
        threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), root3 = pingSuspendedRoot.bind(null, root3, wakeable, lanes), wakeable.then(root3, root3));
      }
      function pingSuspendedRoot(root3, wakeable, pingedLanes) {
        var pingCache = root3.pingCache;
        null !== pingCache && pingCache.delete(wakeable);
        root3.pingedLanes |= root3.suspendedLanes & pingedLanes;
        root3.warmLanes &= ~pingedLanes;
        workInProgressRoot === root3 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (4 === workInProgressRootExitStatus || 3 === workInProgressRootExitStatus && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && 300 > now() - globalMostRecentFallbackTime ? 0 === (executionContext & 2) && prepareFreshStack(root3, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
        ensureRootIsScheduled(root3);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        0 === retryLane && (retryLane = claimNextRetryLane());
        boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
        null !== suspenseState && (retryLane = suspenseState.retryLane);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = 0;
        switch (boundaryFiber.tag) {
          case 13:
            var retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            null !== suspenseState && (retryLane = suspenseState.retryLane);
            break;
          case 19:
            retryCache = boundaryFiber.stateNode;
            break;
          case 22:
            retryCache = boundaryFiber.stateNode._retryCache;
            break;
          default:
            throw Error(formatProdErrorMessage(314));
        }
        null !== retryCache && retryCache.delete(wakeable);
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function scheduleCallback$1(priorityLevel, callback) {
        return scheduleCallback$3(priorityLevel, callback);
      }
      var firstScheduledRoot = null;
      var lastScheduledRoot = null;
      var didScheduleMicrotask = false;
      var mightHavePendingSyncWork = false;
      var isFlushingWork = false;
      var currentEventTransitionLane = 0;
      function ensureRootIsScheduled(root3) {
        root3 !== lastScheduledRoot && null === root3.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root3 : lastScheduledRoot = lastScheduledRoot.next = root3);
        mightHavePendingSyncWork = true;
        didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
      }
      function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
        if (!isFlushingWork && mightHavePendingSyncWork) {
          isFlushingWork = true;
          do {
            var didPerformSomeWork = false;
            for (var root$174 = firstScheduledRoot; null !== root$174; ) {
              if (!onlyLegacy)
                if (0 !== syncTransitionLanes) {
                  var pendingLanes = root$174.pendingLanes;
                  if (0 === pendingLanes) var JSCompiler_inline_result = 0;
                  else {
                    var suspendedLanes = root$174.suspendedLanes, pingedLanes = root$174.pingedLanes;
                    JSCompiler_inline_result = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
                    JSCompiler_inline_result &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
                    JSCompiler_inline_result = JSCompiler_inline_result & 201326741 ? JSCompiler_inline_result & 201326741 | 1 : JSCompiler_inline_result ? JSCompiler_inline_result | 2 : 0;
                  }
                  0 !== JSCompiler_inline_result && (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
                } else
                  JSCompiler_inline_result = workInProgressRootRenderLanes, JSCompiler_inline_result = getNextLanes(
                    root$174,
                    root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,
                    null !== root$174.cancelPendingCommit || -1 !== root$174.timeoutHandle
                  ), 0 === (JSCompiler_inline_result & 3) || checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) || (didPerformSomeWork = true, performSyncWorkOnRoot(root$174, JSCompiler_inline_result));
              root$174 = root$174.next;
            }
          } while (didPerformSomeWork);
          isFlushingWork = false;
        }
      }
      function processRootScheduleInImmediateTask() {
        processRootScheduleInMicrotask();
      }
      function processRootScheduleInMicrotask() {
        mightHavePendingSyncWork = didScheduleMicrotask = false;
        var syncTransitionLanes = 0;
        0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
        for (var currentTime = now(), prev2 = null, root3 = firstScheduledRoot; null !== root3; ) {
          var next2 = root3.next, nextLanes = scheduleTaskForRootDuringMicrotask(root3, currentTime);
          if (0 === nextLanes)
            root3.next = null, null === prev2 ? firstScheduledRoot = next2 : prev2.next = next2, null === next2 && (lastScheduledRoot = prev2);
          else if (prev2 = root3, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
            mightHavePendingSyncWork = true;
          root3 = next2;
        }
        flushSyncWorkAcrossRoots_impl(syncTransitionLanes, false);
      }
      function scheduleTaskForRootDuringMicrotask(root3, currentTime) {
        for (var suspendedLanes = root3.suspendedLanes, pingedLanes = root3.pingedLanes, expirationTimes = root3.expirationTimes, lanes = root3.pendingLanes & -62914561; 0 < lanes; ) {
          var index$3 = 31 - clz32(lanes), lane = 1 << index$3, expirationTime = expirationTimes[index$3];
          if (-1 === expirationTime) {
            if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
              expirationTimes[index$3] = computeExpirationTime(lane, currentTime);
          } else expirationTime <= currentTime && (root3.expiredLanes |= lane);
          lanes &= ~lane;
        }
        currentTime = workInProgressRoot;
        suspendedLanes = workInProgressRootRenderLanes;
        suspendedLanes = getNextLanes(
          root3,
          root3 === currentTime ? suspendedLanes : 0,
          null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
        );
        pingedLanes = root3.callbackNode;
        if (0 === suspendedLanes || root3 === currentTime && (2 === workInProgressSuspendedReason || 9 === workInProgressSuspendedReason) || null !== root3.cancelPendingCommit)
          return null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes), root3.callbackNode = null, root3.callbackPriority = 0;
        if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root3, suspendedLanes)) {
          currentTime = suspendedLanes & -suspendedLanes;
          if (currentTime === root3.callbackPriority) return currentTime;
          null !== pingedLanes && cancelCallback$1(pingedLanes);
          switch (lanesToEventPriority(suspendedLanes)) {
            case 2:
            case 8:
              suspendedLanes = UserBlockingPriority;
              break;
            case 32:
              suspendedLanes = NormalPriority$1;
              break;
            case 268435456:
              suspendedLanes = IdlePriority;
              break;
            default:
              suspendedLanes = NormalPriority$1;
          }
          pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root3);
          suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
          root3.callbackPriority = currentTime;
          root3.callbackNode = suspendedLanes;
          return currentTime;
        }
        null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);
        root3.callbackPriority = 2;
        root3.callbackNode = null;
        return 2;
      }
      function performWorkOnRootViaSchedulerTask(root3, didTimeout) {
        if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)
          return root3.callbackNode = null, root3.callbackPriority = 0, null;
        var originalCallbackNode = root3.callbackNode;
        if (flushPendingEffects(true) && root3.callbackNode !== originalCallbackNode)
          return null;
        var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
        workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
          root3,
          root3 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
          null !== root3.cancelPendingCommit || -1 !== root3.timeoutHandle
        );
        if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
        performWorkOnRoot(root3, workInProgressRootRenderLanes$jscomp$0, didTimeout);
        scheduleTaskForRootDuringMicrotask(root3, now());
        return null != root3.callbackNode && root3.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root3) : null;
      }
      function performSyncWorkOnRoot(root3, lanes) {
        if (flushPendingEffects()) return null;
        performWorkOnRoot(root3, lanes, true);
      }
      function scheduleImmediateRootScheduleTask() {
        scheduleMicrotask(function() {
          0 !== (executionContext & 6) ? scheduleCallback$3(
            ImmediatePriority,
            processRootScheduleInImmediateTask
          ) : processRootScheduleInMicrotask();
        });
      }
      function requestTransitionLane() {
        0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
        return currentEventTransitionLane;
      }
      function coerceFormActionProp(actionProp) {
        return null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp ? null : "function" === typeof actionProp ? actionProp : sanitizeURL("" + actionProp);
      }
      function createFormDataWithSubmitter(form, submitter) {
        var temp = submitter.ownerDocument.createElement("input");
        temp.name = submitter.name;
        temp.value = submitter.value;
        form.id && temp.setAttribute("form", form.id);
        submitter.parentNode.insertBefore(temp, submitter);
        form = new FormData(form);
        temp.parentNode.removeChild(temp);
        return form;
      }
      function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
        if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
          var action = coerceFormActionProp(
            (nativeEventTarget[internalPropsKey] || null).action
          ), submitter = nativeEvent.submitter;
          submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
          var event = new SyntheticEvent(
            "action",
            "action",
            null,
            nativeEvent,
            nativeEventTarget
          );
          dispatchQueue.push({
            event,
            listeners: [
              {
                instance: null,
                listener: function() {
                  if (nativeEvent.defaultPrevented) {
                    if (0 !== currentEventTransitionLane) {
                      var formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget);
                      startHostTransition(
                        maybeTargetInst,
                        {
                          pending: true,
                          data: formData,
                          method: nativeEventTarget.method,
                          action
                        },
                        null,
                        formData
                      );
                    }
                  } else
                    "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(nativeEventTarget, submitter) : new FormData(nativeEventTarget), startHostTransition(
                      maybeTargetInst,
                      {
                        pending: true,
                        data: formData,
                        method: nativeEventTarget.method,
                        action
                      },
                      action,
                      formData
                    ));
                },
                currentTarget: nativeEventTarget
              }
            ]
          });
        }
      }
      for (i$jscomp$inline_1528 = 0; i$jscomp$inline_1528 < simpleEventPluginEvents.length; i$jscomp$inline_1528++) {
        eventName$jscomp$inline_1529 = simpleEventPluginEvents[i$jscomp$inline_1528], domEventName$jscomp$inline_1530 = eventName$jscomp$inline_1529.toLowerCase(), capitalizedEvent$jscomp$inline_1531 = eventName$jscomp$inline_1529[0].toUpperCase() + eventName$jscomp$inline_1529.slice(1);
        registerSimpleEvent(
          domEventName$jscomp$inline_1530,
          "on" + capitalizedEvent$jscomp$inline_1531
        );
      }
      var eventName$jscomp$inline_1529;
      var domEventName$jscomp$inline_1530;
      var capitalizedEvent$jscomp$inline_1531;
      var i$jscomp$inline_1528;
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
      registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
      registerSimpleEvent(ANIMATION_START, "onAnimationStart");
      registerSimpleEvent("dblclick", "onDoubleClick");
      registerSimpleEvent("focusin", "onFocus");
      registerSimpleEvent("focusout", "onBlur");
      registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
      registerSimpleEvent(TRANSITION_START, "onTransitionStart");
      registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
      registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
      registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
      registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
      registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      registerTwoPhaseEvent(
        "onChange",
        "change click focusin focusout input keydown keyup selectionchange".split(" ")
      );
      registerTwoPhaseEvent(
        "onSelect",
        "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
          " "
        )
      );
      registerTwoPhaseEvent("onBeforeInput", [
        "compositionend",
        "keypress",
        "textInput",
        "paste"
      ]);
      registerTwoPhaseEvent(
        "onCompositionEnd",
        "compositionend focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionStart",
        "compositionstart focusout keydown keypress keyup mousedown".split(" ")
      );
      registerTwoPhaseEvent(
        "onCompositionUpdate",
        "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
      );
      var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
        " "
      );
      var nonDelegatedEvents = new Set(
        "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
      );
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        eventSystemFlags = 0 !== (eventSystemFlags & 4);
        for (var i = 0; i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event;
          _dispatchQueue$i = _dispatchQueue$i.listeners;
          a: {
            var previousInstance = void 0;
            if (eventSystemFlags)
              for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
                var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance2 = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance2 !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance2;
              }
            else
              for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
                _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
                instance2 = _dispatchListeners$i.instance;
                currentTarget = _dispatchListeners$i.currentTarget;
                _dispatchListeners$i = _dispatchListeners$i.listener;
                if (instance2 !== previousInstance && event.isPropagationStopped())
                  break a;
                previousInstance = _dispatchListeners$i;
                event.currentTarget = currentTarget;
                try {
                  previousInstance(event);
                } catch (error) {
                  reportGlobalError(error);
                }
                event.currentTarget = null;
                previousInstance = instance2;
              }
          }
        }
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        var JSCompiler_inline_result = targetElement[internalEventHandlersKey];
        void 0 === JSCompiler_inline_result && (JSCompiler_inline_result = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
        var listenerSetKey = domEventName + "__bubble";
        JSCompiler_inline_result.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), JSCompiler_inline_result.add(listenerSetKey));
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        var eventSystemFlags = 0;
        isCapturePhaseListener && (eventSystemFlags |= 4);
        addTrappedEventListener(
          target,
          domEventName,
          eventSystemFlags,
          isCapturePhaseListener
        );
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
          });
          var ownerDocument3 = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
          null === ownerDocument3 || ownerDocument3[listeningMarker] || (ownerDocument3[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument3));
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
        switch (getEventPriority(domEventName)) {
          case 2:
            var listenerWrapper = dispatchDiscreteEvent;
            break;
          case 8:
            listenerWrapper = dispatchContinuousEvent;
            break;
          default:
            listenerWrapper = dispatchEvent;
        }
        eventSystemFlags = listenerWrapper.bind(
          null,
          domEventName,
          eventSystemFlags,
          targetContainer
        );
        listenerWrapper = void 0;
        !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
        isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          capture: true,
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
          passive: listenerWrapper
        }) : targetContainer.addEventListener(domEventName, eventSystemFlags, false);
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
        var ancestorInst = targetInst$jscomp$0;
        if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
          a: for (; ; ) {
            if (null === targetInst$jscomp$0) return;
            var nodeTag = targetInst$jscomp$0.tag;
            if (3 === nodeTag || 4 === nodeTag) {
              var container2 = targetInst$jscomp$0.stateNode.containerInfo;
              if (container2 === targetContainer) break;
              if (4 === nodeTag)
                for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
                  var grandTag = nodeTag.tag;
                  if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
                    return;
                  nodeTag = nodeTag.return;
                }
              for (; null !== container2; ) {
                nodeTag = getClosestInstanceFromNode(container2);
                if (null === nodeTag) return;
                grandTag = nodeTag.tag;
                if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
                  targetInst$jscomp$0 = ancestorInst = nodeTag;
                  continue a;
                }
                container2 = container2.parentNode;
              }
            }
            targetInst$jscomp$0 = targetInst$jscomp$0.return;
          }
        batchedUpdates$1(function() {
          var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
          a: {
            var reactName = topLevelEventsToReactNames.get(domEventName);
            if (void 0 !== reactName) {
              var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
              switch (domEventName) {
                case "keypress":
                  if (0 === getEventCharCode(nativeEvent)) break a;
                case "keydown":
                case "keyup":
                  SyntheticEventCtor = SyntheticKeyboardEvent;
                  break;
                case "focusin":
                  reactEventType = "focus";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "focusout":
                  reactEventType = "blur";
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "beforeblur":
                case "afterblur":
                  SyntheticEventCtor = SyntheticFocusEvent;
                  break;
                case "click":
                  if (2 === nativeEvent.button) break a;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                  SyntheticEventCtor = SyntheticMouseEvent;
                  break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                  SyntheticEventCtor = SyntheticDragEvent;
                  break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                  SyntheticEventCtor = SyntheticTouchEvent;
                  break;
                case ANIMATION_END:
                case ANIMATION_ITERATION:
                case ANIMATION_START:
                  SyntheticEventCtor = SyntheticAnimationEvent;
                  break;
                case TRANSITION_END:
                  SyntheticEventCtor = SyntheticTransitionEvent;
                  break;
                case "scroll":
                case "scrollend":
                  SyntheticEventCtor = SyntheticUIEvent;
                  break;
                case "wheel":
                  SyntheticEventCtor = SyntheticWheelEvent;
                  break;
                case "copy":
                case "cut":
                case "paste":
                  SyntheticEventCtor = SyntheticClipboardEvent;
                  break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                  SyntheticEventCtor = SyntheticPointerEvent;
                  break;
                case "toggle":
                case "beforetoggle":
                  SyntheticEventCtor = SyntheticToggleEvent;
              }
              var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
              inCapturePhase = [];
              for (var instance2 = targetInst, lastHostComponent; null !== instance2; ) {
                var _instance = instance2;
                lastHostComponent = _instance.stateNode;
                _instance = _instance.tag;
                5 !== _instance && 26 !== _instance && 27 !== _instance || null === lastHostComponent || null === reactEventName || (_instance = getListener(instance2, reactEventName), null != _instance && inCapturePhase.push(
                  createDispatchListener(instance2, _instance, lastHostComponent)
                ));
                if (accumulateTargetOnly) break;
                instance2 = instance2.return;
              }
              0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
                reactName,
                reactEventType,
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));
            }
          }
          if (0 === (eventSystemFlags & 7)) {
            a: {
              reactName = "mouseover" === domEventName || "pointerover" === domEventName;
              SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
              if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
                break a;
              if (SyntheticEventCtor || reactName) {
                reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
                if (SyntheticEventCtor) {
                  if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
                    reactEventType = null;
                } else SyntheticEventCtor = null, reactEventType = targetInst;
                if (SyntheticEventCtor !== reactEventType) {
                  inCapturePhase = SyntheticMouseEvent;
                  _instance = "onMouseLeave";
                  reactEventName = "onMouseEnter";
                  instance2 = "mouse";
                  if ("pointerout" === domEventName || "pointerover" === domEventName)
                    inCapturePhase = SyntheticPointerEvent, _instance = "onPointerLeave", reactEventName = "onPointerEnter", instance2 = "pointer";
                  accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
                  lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
                  reactName = new inCapturePhase(
                    _instance,
                    instance2 + "leave",
                    SyntheticEventCtor,
                    nativeEvent,
                    nativeEventTarget
                  );
                  reactName.target = accumulateTargetOnly;
                  reactName.relatedTarget = lastHostComponent;
                  _instance = null;
                  getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
                    reactEventName,
                    instance2 + "enter",
                    reactEventType,
                    nativeEvent,
                    nativeEventTarget
                  ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance = inCapturePhase);
                  accumulateTargetOnly = _instance;
                  if (SyntheticEventCtor && reactEventType)
                    b: {
                      inCapturePhase = SyntheticEventCtor;
                      reactEventName = reactEventType;
                      instance2 = 0;
                      for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
                        instance2++;
                      lastHostComponent = 0;
                      for (_instance = reactEventName; _instance; _instance = getParent(_instance))
                        lastHostComponent++;
                      for (; 0 < instance2 - lastHostComponent; )
                        inCapturePhase = getParent(inCapturePhase), instance2--;
                      for (; 0 < lastHostComponent - instance2; )
                        reactEventName = getParent(reactEventName), lastHostComponent--;
                      for (; instance2--; ) {
                        if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
                          break b;
                        inCapturePhase = getParent(inCapturePhase);
                        reactEventName = getParent(reactEventName);
                      }
                      inCapturePhase = null;
                    }
                  else inCapturePhase = null;
                  null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    reactName,
                    SyntheticEventCtor,
                    inCapturePhase,
                    false
                  );
                  null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
                    dispatchQueue,
                    accumulateTargetOnly,
                    reactEventType,
                    inCapturePhase,
                    true
                  );
                }
              }
            }
            a: {
              reactName = targetInst ? getNodeFromInstance(targetInst) : window;
              SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
              if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
                var getTargetInstFunc = getTargetInstForChangeEvent;
              else if (isTextInputElement(reactName))
                if (isInputEventSupported)
                  getTargetInstFunc = getTargetInstForInputOrChangeEvent;
                else {
                  getTargetInstFunc = getTargetInstForInputEventPolyfill;
                  var handleEventFunc = handleEventsForInputEventPolyfill;
                }
              else
                SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
              if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
                createAndAccumulateChangeEvent(
                  dispatchQueue,
                  getTargetInstFunc,
                  nativeEvent,
                  nativeEventTarget
                );
                break a;
              }
              handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
              "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
            }
            handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
            switch (domEventName) {
              case "focusin":
                if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
                  activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
                break;
              case "focusout":
                lastSelection = activeElementInst = activeElement = null;
                break;
              case "mousedown":
                mouseDown = true;
                break;
              case "contextmenu":
              case "mouseup":
              case "dragend":
                mouseDown = false;
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
                break;
              case "selectionchange":
                if (skipSelectionChangeEvent) break;
              case "keydown":
              case "keyup":
                constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            }
            var fallbackData;
            if (canUseCompositionEvent)
              b: {
                switch (domEventName) {
                  case "compositionstart":
                    var eventType = "onCompositionStart";
                    break b;
                  case "compositionend":
                    eventType = "onCompositionEnd";
                    break b;
                  case "compositionupdate":
                    eventType = "onCompositionUpdate";
                    break b;
                }
                eventType = void 0;
              }
            else
              isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && 229 === nativeEvent.keyCode && (eventType = "onCompositionStart");
            eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root2 = nativeEventTarget, startText = "value" in root2 ? root2.value : root2.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
              eventType,
              domEventName,
              null,
              nativeEvent,
              nativeEventTarget
            ), dispatchQueue.push({ event: eventType, listeners: handleEventFunc }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
            if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
              eventType = accumulateTwoPhaseListeners(targetInst, "onBeforeInput"), 0 < eventType.length && (handleEventFunc = new SyntheticCompositionEvent(
                "onBeforeInput",
                "beforeinput",
                null,
                nativeEvent,
                nativeEventTarget
              ), dispatchQueue.push({
                event: handleEventFunc,
                listeners: eventType
              }), handleEventFunc.data = fallbackData);
            extractEvents$1(
              dispatchQueue,
              domEventName,
              targetInst,
              nativeEvent,
              nativeEventTarget
            );
          }
          processDispatchQueue(dispatchQueue, eventSystemFlags);
        });
      }
      function createDispatchListener(instance2, listener, currentTarget) {
        return {
          instance: instance2,
          listener,
          currentTarget
        };
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
          var _instance2 = targetFiber, stateNode = _instance2.stateNode;
          _instance2 = _instance2.tag;
          5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === stateNode || (_instance2 = getListener(targetFiber, captureName), null != _instance2 && listeners.unshift(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ), _instance2 = getListener(targetFiber, reactName), null != _instance2 && listeners.push(
            createDispatchListener(targetFiber, _instance2, stateNode)
          ));
          if (3 === targetFiber.tag) return listeners;
          targetFiber = targetFiber.return;
        }
        return [];
      }
      function getParent(inst) {
        if (null === inst) return null;
        do
          inst = inst.return;
        while (inst && 5 !== inst.tag && 27 !== inst.tag);
        return inst ? inst : null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common2, inCapturePhase) {
        for (var registrationName = event._reactName, listeners = []; null !== target && target !== common2; ) {
          var _instance3 = target, alternate = _instance3.alternate, stateNode = _instance3.stateNode;
          _instance3 = _instance3.tag;
          if (null !== alternate && alternate === common2) break;
          5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
            createDispatchListener(target, stateNode, alternate)
          )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
            createDispatchListener(target, stateNode, alternate)
          )));
          target = target.return;
        }
        0 !== listeners.length && dispatchQueue.push({ event, listeners });
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText) {
        clientText = normalizeMarkupForTextOrAttribute(clientText);
        return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
      }
      function noop$1() {
      }
      function setProp(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "children":
            "string" === typeof value ? "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && "body" !== tag && setTextContent(domElement, "" + value);
            break;
          case "className":
            setValueForKnownAttribute(domElement, "class", value);
            break;
          case "tabIndex":
            setValueForKnownAttribute(domElement, "tabindex", value);
            break;
          case "dir":
          case "role":
          case "viewBox":
          case "width":
          case "height":
            setValueForKnownAttribute(domElement, key, value);
            break;
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "data":
            if ("object" !== tag) {
              setValueForKnownAttribute(domElement, "data", value);
              break;
            }
          case "src":
          case "href":
            if ("" === value && ("a" !== tag || "href" !== key)) {
              domElement.removeAttribute(key);
              break;
            }
            if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "action":
          case "formAction":
            if ("function" === typeof value) {
              domElement.setAttribute(
                key,
                "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
              );
              break;
            } else
              "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
                domElement,
                tag,
                "formEncType",
                props.formEncType,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formMethod",
                props.formMethod,
                props,
                null
              ), setProp(
                domElement,
                tag,
                "formTarget",
                props.formTarget,
                props,
                null
              )) : (setProp(domElement, tag, "encType", props.encType, props, null), setProp(domElement, tag, "method", props.method, props, null), setProp(domElement, tag, "target", props.target, props, null)));
            if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
              domElement.removeAttribute(key);
              break;
            }
            value = sanitizeURL("" + value);
            domElement.setAttribute(key, value);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "multiple":
            domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "muted":
            domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "defaultValue":
          case "defaultChecked":
          case "innerHTML":
          case "ref":
            break;
          case "autoFocus":
            break;
          case "xlinkHref":
            if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
              domElement.removeAttribute("xlink:href");
              break;
            }
            key = sanitizeURL("" + value);
            domElement.setAttributeNS(
              "http://www.w3.org/1999/xlink",
              "xlink:href",
              key
            );
            break;
          case "contentEditable":
          case "spellCheck":
          case "draggable":
          case "value":
          case "autoReverse":
          case "externalResourcesRequired":
          case "focusable":
          case "preserveAlpha":
            null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "" + value) : domElement.removeAttribute(key);
            break;
          case "inert":
          case "allowFullScreen":
          case "async":
          case "autoPlay":
          case "controls":
          case "default":
          case "defer":
          case "disabled":
          case "disablePictureInPicture":
          case "disableRemotePlayback":
          case "formNoValidate":
          case "hidden":
          case "loop":
          case "noModule":
          case "noValidate":
          case "open":
          case "playsInline":
          case "readOnly":
          case "required":
          case "reversed":
          case "scoped":
          case "seamless":
          case "itemScope":
            value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
            break;
          case "capture":
          case "download":
            true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "cols":
          case "rows":
          case "size":
          case "span":
            null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? domElement.setAttribute(key, value) : domElement.removeAttribute(key);
            break;
          case "rowSpan":
          case "start":
            null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : domElement.setAttribute(key, value);
            break;
          case "popover":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            setValueForAttribute(domElement, "popover", value);
            break;
          case "xlinkActuate":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:actuate",
              value
            );
            break;
          case "xlinkArcrole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:arcrole",
              value
            );
            break;
          case "xlinkRole":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:role",
              value
            );
            break;
          case "xlinkShow":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:show",
              value
            );
            break;
          case "xlinkTitle":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:title",
              value
            );
            break;
          case "xlinkType":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/1999/xlink",
              "xlink:type",
              value
            );
            break;
          case "xmlBase":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:base",
              value
            );
            break;
          case "xmlLang":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:lang",
              value
            );
            break;
          case "xmlSpace":
            setValueForNamespacedAttribute(
              domElement,
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              value
            );
            break;
          case "is":
            setValueForAttribute(domElement, "is", value);
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1])
              key = aliases2.get(key) || key, setValueForAttribute(domElement, key, value);
        }
      }
      function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
        switch (key) {
          case "style":
            setValueForStyles(domElement, value, prevValue);
            break;
          case "dangerouslySetInnerHTML":
            if (null != value) {
              if ("object" !== typeof value || !("__html" in value))
                throw Error(formatProdErrorMessage(61));
              key = value.__html;
              if (null != key) {
                if (null != props.children) throw Error(formatProdErrorMessage(60));
                domElement.innerHTML = key;
              }
            }
            break;
          case "children":
            "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
            break;
          case "onScroll":
            null != value && listenToNonDelegatedEvent("scroll", domElement);
            break;
          case "onScrollEnd":
            null != value && listenToNonDelegatedEvent("scrollend", domElement);
            break;
          case "onClick":
            null != value && (domElement.onclick = noop$1);
            break;
          case "suppressContentEditableWarning":
          case "suppressHydrationWarning":
          case "innerHTML":
          case "ref":
            break;
          case "innerText":
          case "textContent":
            break;
          default:
            if (!registrationNameDependencies.hasOwnProperty(key))
              a: {
                if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
                  "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
                  domElement.addEventListener(tag, value, props);
                  break a;
                }
                key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
              }
        }
      }
      function setInitialProperties(domElement, tag, props) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "img":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            var hasSrc = false, hasSrcSet = false, propKey;
            for (propKey in props)
              if (props.hasOwnProperty(propKey)) {
                var propValue = props[propKey];
                if (null != propValue)
                  switch (propKey) {
                    case "src":
                      hasSrc = true;
                      break;
                    case "srcSet":
                      hasSrcSet = true;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      throw Error(formatProdErrorMessage(137, tag));
                    default:
                      setProp(domElement, tag, propKey, propValue, props, null);
                  }
              }
            hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
            hasSrc && setProp(domElement, tag, "src", props.src, props, null);
            return;
          case "input":
            listenToNonDelegatedEvent("invalid", domElement);
            var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
            for (hasSrc in props)
              if (props.hasOwnProperty(hasSrc)) {
                var propValue$188 = props[hasSrc];
                if (null != propValue$188)
                  switch (hasSrc) {
                    case "name":
                      hasSrcSet = propValue$188;
                      break;
                    case "type":
                      propValue = propValue$188;
                      break;
                    case "checked":
                      checked = propValue$188;
                      break;
                    case "defaultChecked":
                      defaultChecked = propValue$188;
                      break;
                    case "value":
                      propKey = propValue$188;
                      break;
                    case "defaultValue":
                      defaultValue = propValue$188;
                      break;
                    case "children":
                    case "dangerouslySetInnerHTML":
                      if (null != propValue$188)
                        throw Error(formatProdErrorMessage(137, tag));
                      break;
                    default:
                      setProp(domElement, tag, hasSrc, propValue$188, props, null);
                  }
              }
            initInput(
              domElement,
              propKey,
              defaultValue,
              checked,
              defaultChecked,
              propValue,
              hasSrcSet,
              false
            );
            track(domElement);
            return;
          case "select":
            listenToNonDelegatedEvent("invalid", domElement);
            hasSrc = propValue = propKey = null;
            for (hasSrcSet in props)
              if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
                switch (hasSrcSet) {
                  case "value":
                    propKey = defaultValue;
                    break;
                  case "defaultValue":
                    propValue = defaultValue;
                    break;
                  case "multiple":
                    hasSrc = defaultValue;
                  default:
                    setProp(domElement, tag, hasSrcSet, defaultValue, props, null);
                }
            tag = propKey;
            props = propValue;
            domElement.multiple = !!hasSrc;
            null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
            return;
          case "textarea":
            listenToNonDelegatedEvent("invalid", domElement);
            propKey = hasSrcSet = hasSrc = null;
            for (propValue in props)
              if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
                switch (propValue) {
                  case "value":
                    hasSrc = defaultValue;
                    break;
                  case "defaultValue":
                    hasSrcSet = defaultValue;
                    break;
                  case "children":
                    propKey = defaultValue;
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != defaultValue) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    setProp(domElement, tag, propValue, defaultValue, props, null);
                }
            initTextarea(domElement, hasSrc, hasSrcSet, propKey);
            track(domElement);
            return;
          case "option":
            for (checked in props)
              if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
                switch (checked) {
                  case "selected":
                    domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
                    break;
                  default:
                    setProp(domElement, tag, checked, hasSrc, props, null);
                }
            return;
          case "dialog":
            listenToNonDelegatedEvent("beforetoggle", domElement);
            listenToNonDelegatedEvent("toggle", domElement);
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
              listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
            break;
          case "image":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "embed":
          case "source":
          case "link":
            listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          case "area":
          case "base":
          case "br":
          case "col":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "track":
          case "wbr":
          case "menuitem":
            for (defaultChecked in props)
              if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
                switch (defaultChecked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    throw Error(formatProdErrorMessage(137, tag));
                  default:
                    setProp(domElement, tag, defaultChecked, hasSrc, props, null);
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (propValue$188 in props)
                props.hasOwnProperty(propValue$188) && (hasSrc = props[propValue$188], void 0 !== hasSrc && setPropOnCustomElement(
                  domElement,
                  tag,
                  propValue$188,
                  hasSrc,
                  props,
                  void 0
                ));
              return;
            }
        }
        for (defaultValue in props)
          props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
      }
      function updateProperties(domElement, tag, lastProps, nextProps) {
        switch (tag) {
          case "div":
          case "span":
          case "svg":
          case "path":
          case "a":
          case "g":
          case "p":
          case "li":
            break;
          case "input":
            var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
            for (propKey in lastProps) {
              var lastProp = lastProps[propKey];
              if (lastProps.hasOwnProperty(propKey) && null != lastProp)
                switch (propKey) {
                  case "checked":
                    break;
                  case "value":
                    break;
                  case "defaultValue":
                    lastDefaultValue = lastProp;
                  default:
                    nextProps.hasOwnProperty(propKey) || setProp(domElement, tag, propKey, null, nextProps, lastProp);
                }
            }
            for (var propKey$205 in nextProps) {
              var propKey = nextProps[propKey$205];
              lastProp = lastProps[propKey$205];
              if (nextProps.hasOwnProperty(propKey$205) && (null != propKey || null != lastProp))
                switch (propKey$205) {
                  case "type":
                    type = propKey;
                    break;
                  case "name":
                    name = propKey;
                    break;
                  case "checked":
                    checked = propKey;
                    break;
                  case "defaultChecked":
                    defaultChecked = propKey;
                    break;
                  case "value":
                    value = propKey;
                    break;
                  case "defaultValue":
                    defaultValue = propKey;
                    break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    propKey !== lastProp && setProp(
                      domElement,
                      tag,
                      propKey$205,
                      propKey,
                      nextProps,
                      lastProp
                    );
                }
            }
            updateInput(
              domElement,
              value,
              defaultValue,
              lastDefaultValue,
              checked,
              defaultChecked,
              type,
              name
            );
            return;
          case "select":
            propKey = value = defaultValue = propKey$205 = null;
            for (type in lastProps)
              if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
                switch (type) {
                  case "value":
                    break;
                  case "multiple":
                    propKey = lastDefaultValue;
                  default:
                    nextProps.hasOwnProperty(type) || setProp(
                      domElement,
                      tag,
                      type,
                      null,
                      nextProps,
                      lastDefaultValue
                    );
                }
            for (name in nextProps)
              if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
                switch (name) {
                  case "value":
                    propKey$205 = type;
                    break;
                  case "defaultValue":
                    defaultValue = type;
                    break;
                  case "multiple":
                    value = type;
                  default:
                    type !== lastDefaultValue && setProp(
                      domElement,
                      tag,
                      name,
                      type,
                      nextProps,
                      lastDefaultValue
                    );
                }
            tag = defaultValue;
            lastProps = value;
            nextProps = propKey;
            null != propKey$205 ? updateOptions(domElement, !!lastProps, propKey$205, false) : !!nextProps !== !!lastProps && (null != tag ? updateOptions(domElement, !!lastProps, tag, true) : updateOptions(domElement, !!lastProps, lastProps ? [] : "", false));
            return;
          case "textarea":
            propKey = propKey$205 = null;
            for (defaultValue in lastProps)
              if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
                switch (defaultValue) {
                  case "value":
                    break;
                  case "children":
                    break;
                  default:
                    setProp(domElement, tag, defaultValue, null, nextProps, name);
                }
            for (value in nextProps)
              if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
                switch (value) {
                  case "value":
                    propKey$205 = name;
                    break;
                  case "defaultValue":
                    propKey = name;
                    break;
                  case "children":
                    break;
                  case "dangerouslySetInnerHTML":
                    if (null != name) throw Error(formatProdErrorMessage(91));
                    break;
                  default:
                    name !== type && setProp(domElement, tag, value, name, nextProps, type);
                }
            updateTextarea(domElement, propKey$205, propKey);
            return;
          case "option":
            for (var propKey$221 in lastProps)
              if (propKey$205 = lastProps[propKey$221], lastProps.hasOwnProperty(propKey$221) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$221))
                switch (propKey$221) {
                  case "selected":
                    domElement.selected = false;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      propKey$221,
                      null,
                      nextProps,
                      propKey$205
                    );
                }
            for (lastDefaultValue in nextProps)
              if (propKey$205 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
                switch (lastDefaultValue) {
                  case "selected":
                    domElement.selected = propKey$205 && "function" !== typeof propKey$205 && "symbol" !== typeof propKey$205;
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      lastDefaultValue,
                      propKey$205,
                      nextProps,
                      propKey
                    );
                }
            return;
          case "img":
          case "link":
          case "area":
          case "base":
          case "br":
          case "col":
          case "embed":
          case "hr":
          case "keygen":
          case "meta":
          case "param":
          case "source":
          case "track":
          case "wbr":
          case "menuitem":
            for (var propKey$226 in lastProps)
              propKey$205 = lastProps[propKey$226], lastProps.hasOwnProperty(propKey$226) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$226) && setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);
            for (checked in nextProps)
              if (propKey$205 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && propKey$205 !== propKey && (null != propKey$205 || null != propKey))
                switch (checked) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                    if (null != propKey$205)
                      throw Error(formatProdErrorMessage(137, tag));
                    break;
                  default:
                    setProp(
                      domElement,
                      tag,
                      checked,
                      propKey$205,
                      nextProps,
                      propKey
                    );
                }
            return;
          default:
            if (isCustomElement(tag)) {
              for (var propKey$231 in lastProps)
                propKey$205 = lastProps[propKey$231], lastProps.hasOwnProperty(propKey$231) && void 0 !== propKey$205 && !nextProps.hasOwnProperty(propKey$231) && setPropOnCustomElement(
                  domElement,
                  tag,
                  propKey$231,
                  void 0,
                  nextProps,
                  propKey$205
                );
              for (defaultChecked in nextProps)
                propKey$205 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || propKey$205 === propKey || void 0 === propKey$205 && void 0 === propKey || setPropOnCustomElement(
                  domElement,
                  tag,
                  defaultChecked,
                  propKey$205,
                  nextProps,
                  propKey
                );
              return;
            }
        }
        for (var propKey$236 in lastProps)
          propKey$205 = lastProps[propKey$236], lastProps.hasOwnProperty(propKey$236) && null != propKey$205 && !nextProps.hasOwnProperty(propKey$236) && setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);
        for (lastProp in nextProps)
          propKey$205 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || propKey$205 === propKey || null == propKey$205 && null == propKey || setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);
      }
      var eventsEnabled = null;
      var selectionInformation = null;
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function getOwnHostContext(namespaceURI) {
        switch (namespaceURI) {
          case "http://www.w3.org/2000/svg":
            return 1;
          case "http://www.w3.org/1998/Math/MathML":
            return 2;
          default:
            return 0;
        }
      }
      function getChildHostContextProd(parentNamespace, type) {
        if (0 === parentNamespace)
          switch (type) {
            case "svg":
              return 1;
            case "math":
              return 2;
            default:
              return 0;
          }
        return 1 === parentNamespace && "foreignObject" === type ? 0 : parentNamespace;
      }
      function shouldSetTextContent(type, props) {
        return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
      }
      var currentPopstateTransitionEvent = null;
      function shouldAttemptEagerTransition() {
        var event = window.event;
        if (event && "popstate" === event.type) {
          if (event === currentPopstateTransitionEvent) return false;
          currentPopstateTransitionEvent = event;
          return true;
        }
        currentPopstateTransitionEvent = null;
        return false;
      }
      var scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0;
      var cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0;
      var localPromise = "function" === typeof Promise ? Promise : void 0;
      var scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error) {
        setTimeout(function() {
          throw error;
        });
      }
      function isSingletonScope(type) {
        return "head" === type;
      }
      function clearSuspenseBoundary(parentInstance, suspenseInstance) {
        var node2 = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
        do {
          var nextNode = node2.nextSibling;
          parentInstance.removeChild(node2);
          if (nextNode && 8 === nextNode.nodeType)
            if (node2 = nextNode.data, "/$" === node2) {
              if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
                node2 = possiblePreambleContribution;
                var ownerDocument3 = parentInstance.ownerDocument;
                node2 & 1 && releaseSingletonInstance(ownerDocument3.documentElement);
                node2 & 2 && releaseSingletonInstance(ownerDocument3.body);
                if (node2 & 4)
                  for (node2 = ownerDocument3.head, releaseSingletonInstance(node2), ownerDocument3 = node2.firstChild; ownerDocument3; ) {
                    var nextNode$jscomp$0 = ownerDocument3.nextSibling, nodeName = ownerDocument3.nodeName;
                    ownerDocument3[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument3.rel.toLowerCase() || node2.removeChild(ownerDocument3);
                    ownerDocument3 = nextNode$jscomp$0;
                  }
              }
              if (0 === depth) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(suspenseInstance);
                return;
              }
              depth--;
            } else
              "$" === node2 || "$?" === node2 || "$!" === node2 ? depth++ : possiblePreambleContribution = node2.charCodeAt(0) - 48;
          else possiblePreambleContribution = 0;
          node2 = nextNode;
        } while (node2);
        retryIfBlockedOn(suspenseInstance);
      }
      function clearContainerSparingly(container2) {
        var nextNode = container2.firstChild;
        nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
        for (; nextNode; ) {
          var node2 = nextNode;
          nextNode = nextNode.nextSibling;
          switch (node2.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
              clearContainerSparingly(node2);
              detachDeletedInstance(node2);
              continue;
            case "SCRIPT":
            case "STYLE":
              continue;
            case "LINK":
              if ("stylesheet" === node2.rel.toLowerCase()) continue;
          }
          container2.removeChild(node2);
        }
      }
      function canHydrateInstance(instance2, type, props, inRootOrSingleton) {
        for (; 1 === instance2.nodeType; ) {
          var anyProps = props;
          if (instance2.nodeName.toLowerCase() !== type.toLowerCase()) {
            if (!inRootOrSingleton && ("INPUT" !== instance2.nodeName || "hidden" !== instance2.type))
              break;
          } else if (!inRootOrSingleton)
            if ("input" === type && "hidden" === instance2.type) {
              var name = null == anyProps.name ? null : "" + anyProps.name;
              if ("hidden" === anyProps.type && instance2.getAttribute("name") === name)
                return instance2;
            } else return instance2;
          else if (!instance2[internalHoistableMarker])
            switch (type) {
              case "meta":
                if (!instance2.hasAttribute("itemprop")) break;
                return instance2;
              case "link":
                name = instance2.getAttribute("rel");
                if ("stylesheet" === name && instance2.hasAttribute("data-precedence"))
                  break;
                else if (name !== anyProps.rel || instance2.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance2.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance2.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
                  break;
                return instance2;
              case "style":
                if (instance2.hasAttribute("data-precedence")) break;
                return instance2;
              case "script":
                name = instance2.getAttribute("src");
                if ((name !== (null == anyProps.src ? null : anyProps.src) || instance2.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance2.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance2.hasAttribute("async") && !instance2.hasAttribute("itemprop"))
                  break;
                return instance2;
              default:
                return instance2;
            }
          instance2 = getNextHydratable(instance2.nextSibling);
          if (null === instance2) break;
        }
        return null;
      }
      function canHydrateTextInstance(instance2, text, inRootOrSingleton) {
        if ("" === text) return null;
        for (; 3 !== instance2.nodeType; ) {
          if ((1 !== instance2.nodeType || "INPUT" !== instance2.nodeName || "hidden" !== instance2.type) && !inRootOrSingleton)
            return null;
          instance2 = getNextHydratable(instance2.nextSibling);
          if (null === instance2) return null;
        }
        return instance2;
      }
      function isSuspenseInstanceFallback(instance2) {
        return "$!" === instance2.data || "$?" === instance2.data && "complete" === instance2.ownerDocument.readyState;
      }
      function registerSuspenseInstanceRetry(instance2, callback) {
        var ownerDocument3 = instance2.ownerDocument;
        if ("$?" !== instance2.data || "complete" === ownerDocument3.readyState)
          callback();
        else {
          var listener = function() {
            callback();
            ownerDocument3.removeEventListener("DOMContentLoaded", listener);
          };
          ownerDocument3.addEventListener("DOMContentLoaded", listener);
          instance2._reactRetry = listener;
        }
      }
      function getNextHydratable(node2) {
        for (; null != node2; node2 = node2.nextSibling) {
          var nodeType = node2.nodeType;
          if (1 === nodeType || 3 === nodeType) break;
          if (8 === nodeType) {
            nodeType = node2.data;
            if ("$" === nodeType || "$!" === nodeType || "$?" === nodeType || "F!" === nodeType || "F" === nodeType)
              break;
            if ("/$" === nodeType) return null;
          }
        }
        return node2;
      }
      var previousHydratableOnEnteringScopedSingleton = null;
      function getParentSuspenseInstance(targetInstance) {
        targetInstance = targetInstance.previousSibling;
        for (var depth = 0; targetInstance; ) {
          if (8 === targetInstance.nodeType) {
            var data = targetInstance.data;
            if ("$" === data || "$!" === data || "$?" === data) {
              if (0 === depth) return targetInstance;
              depth--;
            } else "/$" === data && depth++;
          }
          targetInstance = targetInstance.previousSibling;
        }
        return null;
      }
      function resolveSingletonInstance(type, props, rootContainerInstance) {
        props = getOwnerDocumentFromRootContainer(rootContainerInstance);
        switch (type) {
          case "html":
            type = props.documentElement;
            if (!type) throw Error(formatProdErrorMessage(452));
            return type;
          case "head":
            type = props.head;
            if (!type) throw Error(formatProdErrorMessage(453));
            return type;
          case "body":
            type = props.body;
            if (!type) throw Error(formatProdErrorMessage(454));
            return type;
          default:
            throw Error(formatProdErrorMessage(451));
        }
      }
      function releaseSingletonInstance(instance2) {
        for (var attributes = instance2.attributes; attributes.length; )
          instance2.removeAttributeNode(attributes[0]);
        detachDeletedInstance(instance2);
      }
      var preloadPropsMap = /* @__PURE__ */ new Map();
      var preconnectsSet = /* @__PURE__ */ new Set();
      function getHoistableRoot(container2) {
        return "function" === typeof container2.getRootNode ? container2.getRootNode() : 9 === container2.nodeType ? container2 : container2.ownerDocument;
      }
      var previousDispatcher = ReactDOMSharedInternals.d;
      ReactDOMSharedInternals.d = {
        f: flushSyncWork,
        r: requestFormReset,
        D: prefetchDNS,
        C: preconnect,
        L: preload,
        m: preloadModule,
        X: preinitScript,
        S: preinitStyle,
        M: preinitModuleScript
      };
      function flushSyncWork() {
        var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
        return previousWasRendering || wasRendering;
      }
      function requestFormReset(form) {
        var formInst = getInstanceFromNode(form);
        null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
      }
      var globalDocument = "undefined" === typeof document ? null : document;
      function preconnectAs(rel, href, crossOrigin) {
        var ownerDocument3 = globalDocument;
        if (ownerDocument3 && "string" === typeof href && href) {
          var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
          limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
          "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
          preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument3.querySelector(limitedEscapedHref) && (href = ownerDocument3.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument3.head.appendChild(href)));
        }
      }
      function prefetchDNS(href) {
        previousDispatcher.D(href);
        preconnectAs("dns-prefetch", href, null);
      }
      function preconnect(href, crossOrigin) {
        previousDispatcher.C(href, crossOrigin);
        preconnectAs("preconnect", href, crossOrigin);
      }
      function preload(href, as, options2) {
        previousDispatcher.L(href, as, options2);
        var ownerDocument3 = globalDocument;
        if (ownerDocument3 && href && as) {
          var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
          "image" === as ? options2 && options2.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSrcSet
          ) + '"]', "string" === typeof options2.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
            options2.imageSizes
          ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
          var key = preloadSelector;
          switch (as) {
            case "style":
              key = getStyleKey(href);
              break;
            case "script":
              key = getScriptKey(href);
          }
          preloadPropsMap.has(key) || (href = assign3(
            {
              rel: "preload",
              href: "image" === as && options2 && options2.imageSrcSet ? void 0 : href,
              as
            },
            options2
          ), preloadPropsMap.set(key, href), null !== ownerDocument3.querySelector(preloadSelector) || "style" === as && ownerDocument3.querySelector(getStylesheetSelectorFromKey(key)) || "script" === as && ownerDocument3.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument3.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument3.head.appendChild(as)));
        }
      }
      function preloadModule(href, options2) {
        previousDispatcher.m(href, options2);
        var ownerDocument3 = globalDocument;
        if (ownerDocument3 && href) {
          var as = options2 && "string" === typeof options2.as ? options2.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
          switch (as) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              key = getScriptKey(href);
          }
          if (!preloadPropsMap.has(key) && (href = assign3({ rel: "modulepreload", href }, options2), preloadPropsMap.set(key, href), null === ownerDocument3.querySelector(preloadSelector))) {
            switch (as) {
              case "audioworklet":
              case "paintworklet":
              case "serviceworker":
              case "sharedworker":
              case "worker":
              case "script":
                if (ownerDocument3.querySelector(getScriptSelectorFromKey(key)))
                  return;
            }
            as = ownerDocument3.createElement("link");
            setInitialProperties(as, "link", href);
            markNodeAsHoistable(as);
            ownerDocument3.head.appendChild(as);
          }
        }
      }
      function preinitStyle(href, precedence, options2) {
        previousDispatcher.S(href, precedence, options2);
        var ownerDocument3 = globalDocument;
        if (ownerDocument3 && href) {
          var styles2 = getResourcesFromRoot(ownerDocument3).hoistableStyles, key = getStyleKey(href);
          precedence = precedence || "default";
          var resource = styles2.get(key);
          if (!resource) {
            var state = { loading: 0, preload: null };
            if (resource = ownerDocument3.querySelector(
              getStylesheetSelectorFromKey(key)
            ))
              state.loading = 5;
            else {
              href = assign3(
                { rel: "stylesheet", href, "data-precedence": precedence },
                options2
              );
              (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options2);
              var link = resource = ownerDocument3.createElement("link");
              markNodeAsHoistable(link);
              setInitialProperties(link, "link", href);
              link._p = new Promise(function(resolve, reject) {
                link.onload = resolve;
                link.onerror = reject;
              });
              link.addEventListener("load", function() {
                state.loading |= 1;
              });
              link.addEventListener("error", function() {
                state.loading |= 2;
              });
              state.loading |= 4;
              insertStylesheet(resource, precedence, ownerDocument3);
            }
            resource = {
              type: "stylesheet",
              instance: resource,
              count: 1,
              state
            };
            styles2.set(key, resource);
          }
        }
      }
      function preinitScript(src, options2) {
        previousDispatcher.X(src, options2);
        var ownerDocument3 = globalDocument;
        if (ownerDocument3 && src) {
          var scripts = getResourcesFromRoot(ownerDocument3).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument3.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign3({ src, async: true }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument3.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument3.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function preinitModuleScript(src, options2) {
        previousDispatcher.M(src, options2);
        var ownerDocument3 = globalDocument;
        if (ownerDocument3 && src) {
          var scripts = getResourcesFromRoot(ownerDocument3).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
          resource || (resource = ownerDocument3.querySelector(getScriptSelectorFromKey(key)), resource || (src = assign3({ src, async: true, type: "module" }, options2), (options2 = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options2), resource = ownerDocument3.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument3.head.appendChild(resource)), resource = {
            type: "script",
            instance: resource,
            count: 1,
            state: null
          }, scripts.set(key, resource));
        }
      }
      function getResource(type, currentProps, pendingProps, currentResource) {
        var JSCompiler_inline_result = (JSCompiler_inline_result = rootInstanceStackCursor.current) ? getHoistableRoot(JSCompiler_inline_result) : null;
        if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));
        switch (type) {
          case "meta":
          case "title":
            return null;
          case "style":
            return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (currentProps = getStyleKey(pendingProps.href), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableStyles, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "style",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          case "link":
            if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
              type = getStyleKey(pendingProps.href);
              var styles$244 = getResourcesFromRoot(
                JSCompiler_inline_result
              ).hoistableStyles, resource$245 = styles$244.get(type);
              resource$245 || (JSCompiler_inline_result = JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result, resource$245 = {
                type: "stylesheet",
                instance: null,
                count: 0,
                state: { loading: 0, preload: null }
              }, styles$244.set(type, resource$245), (styles$244 = JSCompiler_inline_result.querySelector(
                getStylesheetSelectorFromKey(type)
              )) && !styles$244._p && (resource$245.instance = styles$244, resource$245.state.loading = 5), preloadPropsMap.has(type) || (pendingProps = {
                rel: "preload",
                as: "style",
                href: pendingProps.href,
                crossOrigin: pendingProps.crossOrigin,
                integrity: pendingProps.integrity,
                media: pendingProps.media,
                hrefLang: pendingProps.hrefLang,
                referrerPolicy: pendingProps.referrerPolicy
              }, preloadPropsMap.set(type, pendingProps), styles$244 || preloadStylesheet(
                JSCompiler_inline_result,
                type,
                pendingProps,
                resource$245.state
              )));
              if (currentProps && null === currentResource)
                throw Error(formatProdErrorMessage(528, ""));
              return resource$245;
            }
            if (currentProps && null !== currentResource)
              throw Error(formatProdErrorMessage(529, ""));
            return null;
          case "script":
            return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (currentProps = getScriptKey(pendingProps), pendingProps = getResourcesFromRoot(
              JSCompiler_inline_result
            ).hoistableScripts, currentResource = pendingProps.get(currentProps), currentResource || (currentResource = {
              type: "script",
              instance: null,
              count: 0,
              state: null
            }, pendingProps.set(currentProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
          default:
            throw Error(formatProdErrorMessage(444, type));
        }
      }
      function getStyleKey(href) {
        return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
      }
      function getStylesheetSelectorFromKey(key) {
        return 'link[rel="stylesheet"][' + key + "]";
      }
      function stylesheetPropsFromRawProps(rawProps) {
        return assign3({}, rawProps, {
          "data-precedence": rawProps.precedence,
          precedence: null
        });
      }
      function preloadStylesheet(ownerDocument3, key, preloadProps, state) {
        ownerDocument3.querySelector('link[rel="preload"][as="style"][' + key + "]") ? state.loading = 1 : (key = ownerDocument3.createElement("link"), state.preload = key, key.addEventListener("load", function() {
          return state.loading |= 1;
        }), key.addEventListener("error", function() {
          return state.loading |= 2;
        }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument3.head.appendChild(key));
      }
      function getScriptKey(src) {
        return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
      }
      function getScriptSelectorFromKey(key) {
        return "script[async]" + key;
      }
      function acquireResource(hoistableRoot, resource, props) {
        resource.count++;
        if (null === resource.instance)
          switch (resource.type) {
            case "style":
              var instance2 = hoistableRoot.querySelector(
                'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
              );
              if (instance2)
                return resource.instance = instance2, markNodeAsHoistable(instance2), instance2;
              var styleProps = assign3({}, props, {
                "data-href": props.href,
                "data-precedence": props.precedence,
                href: null,
                precedence: null
              });
              instance2 = (hoistableRoot.ownerDocument || hoistableRoot).createElement(
                "style"
              );
              markNodeAsHoistable(instance2);
              setInitialProperties(instance2, "style", styleProps);
              insertStylesheet(instance2, props.precedence, hoistableRoot);
              return resource.instance = instance2;
            case "stylesheet":
              styleProps = getStyleKey(props.href);
              var instance$250 = hoistableRoot.querySelector(
                getStylesheetSelectorFromKey(styleProps)
              );
              if (instance$250)
                return resource.state.loading |= 4, resource.instance = instance$250, markNodeAsHoistable(instance$250), instance$250;
              instance2 = stylesheetPropsFromRawProps(props);
              (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance2, styleProps);
              instance$250 = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
              markNodeAsHoistable(instance$250);
              var linkInstance = instance$250;
              linkInstance._p = new Promise(function(resolve, reject) {
                linkInstance.onload = resolve;
                linkInstance.onerror = reject;
              });
              setInitialProperties(instance$250, "link", instance2);
              resource.state.loading |= 4;
              insertStylesheet(instance$250, props.precedence, hoistableRoot);
              return resource.instance = instance$250;
            case "script":
              instance$250 = getScriptKey(props.src);
              if (styleProps = hoistableRoot.querySelector(
                getScriptSelectorFromKey(instance$250)
              ))
                return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
              instance2 = props;
              if (styleProps = preloadPropsMap.get(instance$250))
                instance2 = assign3({}, props), adoptPreloadPropsForScript(instance2, styleProps);
              hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
              styleProps = hoistableRoot.createElement("script");
              markNodeAsHoistable(styleProps);
              setInitialProperties(styleProps, "link", instance2);
              hoistableRoot.head.appendChild(styleProps);
              return resource.instance = styleProps;
            case "void":
              return null;
            default:
              throw Error(formatProdErrorMessage(443, resource.type));
          }
        else
          "stylesheet" === resource.type && 0 === (resource.state.loading & 4) && (instance2 = resource.instance, resource.state.loading |= 4, insertStylesheet(instance2, props.precedence, hoistableRoot));
        return resource.instance;
      }
      function insertStylesheet(instance2, precedence, root3) {
        for (var nodes = root3.querySelectorAll(
          'link[rel="stylesheet"][data-precedence],style[data-precedence]'
        ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
          var node2 = nodes[i];
          if (node2.dataset.precedence === precedence) prior = node2;
          else if (prior !== last) break;
        }
        prior ? prior.parentNode.insertBefore(instance2, prior.nextSibling) : (precedence = 9 === root3.nodeType ? root3.head : root3, precedence.insertBefore(instance2, precedence.firstChild));
      }
      function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
        null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
        null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
        null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
      }
      function adoptPreloadPropsForScript(scriptProps, preloadProps) {
        null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
        null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
        null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
      }
      var tagCaches = null;
      function getHydratableHoistableCache(type, keyAttribute, ownerDocument3) {
        if (null === tagCaches) {
          var cache = /* @__PURE__ */ new Map();
          var caches = tagCaches = /* @__PURE__ */ new Map();
          caches.set(ownerDocument3, cache);
        } else
          caches = tagCaches, cache = caches.get(ownerDocument3), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument3, cache));
        if (cache.has(type)) return cache;
        cache.set(type, null);
        ownerDocument3 = ownerDocument3.getElementsByTagName(type);
        for (caches = 0; caches < ownerDocument3.length; caches++) {
          var node2 = ownerDocument3[caches];
          if (!(node2[internalHoistableMarker] || node2[internalInstanceKey] || "link" === type && "stylesheet" === node2.getAttribute("rel")) && "http://www.w3.org/2000/svg" !== node2.namespaceURI) {
            var nodeKey = node2.getAttribute(keyAttribute) || "";
            nodeKey = type + nodeKey;
            var existing = cache.get(nodeKey);
            existing ? existing.push(node2) : cache.set(nodeKey, [node2]);
          }
        }
        return cache;
      }
      function mountHoistable(hoistableRoot, type, instance2) {
        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
        hoistableRoot.head.insertBefore(
          instance2,
          "title" === type ? hoistableRoot.querySelector("head > title") : null
        );
      }
      function isHostHoistableType(type, props, hostContext) {
        if (1 === hostContext || null != props.itemProp) return false;
        switch (type) {
          case "meta":
          case "title":
            return true;
          case "style":
            if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href)
              break;
            return true;
          case "link":
            if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError)
              break;
            switch (props.rel) {
              case "stylesheet":
                return type = props.disabled, "string" === typeof props.precedence && null == type;
              default:
                return true;
            }
          case "script":
            if (props.async && "function" !== typeof props.async && "symbol" !== typeof props.async && !props.onLoad && !props.onError && props.src && "string" === typeof props.src)
              return true;
        }
        return false;
      }
      function preloadResource(resource) {
        return "stylesheet" === resource.type && 0 === (resource.state.loading & 3) ? false : true;
      }
      var suspendedState = null;
      function noop6() {
      }
      function suspendResource(hoistableRoot, resource, props) {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && 0 === (resource.state.loading & 4)) {
          if (null === resource.instance) {
            var key = getStyleKey(props.href), instance2 = hoistableRoot.querySelector(
              getStylesheetSelectorFromKey(key)
            );
            if (instance2) {
              hoistableRoot = instance2._p;
              null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
              resource.state.loading |= 4;
              resource.instance = instance2;
              markNodeAsHoistable(instance2);
              return;
            }
            instance2 = hoistableRoot.ownerDocument || hoistableRoot;
            props = stylesheetPropsFromRawProps(props);
            (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
            instance2 = instance2.createElement("link");
            markNodeAsHoistable(instance2);
            var linkInstance = instance2;
            linkInstance._p = new Promise(function(resolve, reject) {
              linkInstance.onload = resolve;
              linkInstance.onerror = reject;
            });
            setInitialProperties(instance2, "link", props);
            resource.instance = instance2;
          }
          null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
          state.stylesheets.set(resource, hoistableRoot);
          (hoistableRoot = resource.state.preload) && 0 === (resource.state.loading & 3) && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
        }
      }
      function waitForCommitToBeReady() {
        if (null === suspendedState) throw Error(formatProdErrorMessage(475));
        var state = suspendedState;
        state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
        return 0 < state.count ? function(commit) {
          var stylesheetTimer = setTimeout(function() {
            state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
            if (state.unsuspend) {
              var unsuspend = state.unsuspend;
              state.unsuspend = null;
              unsuspend();
            }
          }, 6e4);
          state.unsuspend = commit;
          return function() {
            state.unsuspend = null;
            clearTimeout(stylesheetTimer);
          };
        } : null;
      }
      function onUnsuspend() {
        this.count--;
        if (0 === this.count) {
          if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);
          else if (this.unsuspend) {
            var unsuspend = this.unsuspend;
            this.unsuspend = null;
            unsuspend();
          }
        }
      }
      var precedencesByRoot = null;
      function insertSuspendedStylesheets(state, resources) {
        state.stylesheets = null;
        null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
      }
      function insertStylesheetIntoRoot(root3, resource) {
        if (!(resource.state.loading & 4)) {
          var precedences = precedencesByRoot.get(root3);
          if (precedences) var last = precedences.get(null);
          else {
            precedences = /* @__PURE__ */ new Map();
            precedencesByRoot.set(root3, precedences);
            for (var nodes = root3.querySelectorAll(
              "link[data-precedence],style[data-precedence]"
            ), i = 0; i < nodes.length; i++) {
              var node2 = nodes[i];
              if ("LINK" === node2.nodeName || "not all" !== node2.getAttribute("media"))
                precedences.set(node2.dataset.precedence, node2), last = node2;
            }
            last && precedences.set(null, last);
          }
          nodes = resource.instance;
          node2 = nodes.getAttribute("data-precedence");
          i = precedences.get(node2) || last;
          i === last && precedences.set(null, nodes);
          precedences.set(node2, nodes);
          this.count++;
          last = onUnsuspend.bind(this);
          nodes.addEventListener("load", last);
          nodes.addEventListener("error", last);
          i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root3 = 9 === root3.nodeType ? root3.head : root3, root3.insertBefore(nodes, root3.firstChild));
          resource.state.loading |= 4;
        }
      }
      var HostTransitionContext = {
        $$typeof: REACT_CONTEXT_TYPE,
        Provider: null,
        Consumer: null,
        _currentValue: sharedNotPendingObject,
        _currentValue2: sharedNotPendingObject,
        _threadCount: 0
      };
      function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
        this.tag = 1;
        this.containerInfo = containerInfo;
        this.pingCache = this.current = this.pendingChildren = null;
        this.timeoutHandle = -1;
        this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
        this.callbackPriority = 0;
        this.expirationTimes = createLaneMap(-1);
        this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
        this.entanglements = createLaneMap(0);
        this.hiddenUpdates = createLaneMap(null);
        this.identifierPrefix = identifierPrefix;
        this.onUncaughtError = onUncaughtError;
        this.onCaughtError = onCaughtError;
        this.onRecoverableError = onRecoverableError;
        this.pooledCache = null;
        this.pooledCacheLanes = 0;
        this.formState = formState;
        this.incompleteTransitions = /* @__PURE__ */ new Map();
      }
      function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
        containerInfo = new FiberRootNode(
          containerInfo,
          tag,
          hydrate,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          formState
        );
        tag = 1;
        true === isStrictMode && (tag |= 24);
        isStrictMode = createFiberImplClass(3, null, null, tag);
        containerInfo.current = isStrictMode;
        isStrictMode.stateNode = containerInfo;
        tag = createCache3();
        tag.refCount++;
        containerInfo.pooledCache = tag;
        tag.refCount++;
        isStrictMode.memoizedState = {
          element: initialChildren,
          isDehydrated: hydrate,
          cache: tag
        };
        initializeUpdateQueue(isStrictMode);
        return containerInfo;
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) return emptyContextObject;
        parentComponent = emptyContextObject;
        return parentComponent;
      }
      function updateContainerImpl(rootFiber, lane, element, container2, parentComponent, callback) {
        parentComponent = getContextForSubtree(parentComponent);
        null === container2.context ? container2.context = parentComponent : container2.pendingContext = parentComponent;
        container2 = createUpdate2(lane);
        container2.payload = { element };
        callback = void 0 === callback ? null : callback;
        null !== callback && (container2.callback = callback);
        element = enqueueUpdate(rootFiber, container2, lane);
        null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
      }
      function markRetryLaneImpl(fiber, retryLane) {
        fiber = fiber.memoizedState;
        if (null !== fiber && null !== fiber.dehydrated) {
          var a = fiber.retryLane;
          fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
      }
      function attemptContinuousHydration(fiber) {
        if (13 === fiber.tag) {
          var root3 = enqueueConcurrentRenderForLane(fiber, 67108864);
          null !== root3 && scheduleUpdateOnFiber(root3, fiber, 67108864);
          markRetryLaneIfNotHydrated(fiber, 67108864);
        }
      }
      var _enabled = true;
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 2, dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container2, nativeEvent) {
        var prevTransition = ReactSharedInternals.T;
        ReactSharedInternals.T = null;
        var previousPriority = ReactDOMSharedInternals.p;
        try {
          ReactDOMSharedInternals.p = 8, dispatchEvent(domEventName, eventSystemFlags, container2, nativeEvent);
        } finally {
          ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (_enabled) {
          var blockedOn = findInstanceBlockingEvent(nativeEvent);
          if (null === blockedOn)
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              return_targetInst,
              targetContainer
            ), clearIfContinuousEvent(domEventName, nativeEvent);
          else if (queueIfContinuousEvent(
            blockedOn,
            domEventName,
            eventSystemFlags,
            targetContainer,
            nativeEvent
          ))
            nativeEvent.stopPropagation();
          else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
            for (; null !== blockedOn; ) {
              var fiber = getInstanceFromNode(blockedOn);
              if (null !== fiber)
                switch (fiber.tag) {
                  case 3:
                    fiber = fiber.stateNode;
                    if (fiber.current.memoizedState.isDehydrated) {
                      var lanes = getHighestPriorityLanes(fiber.pendingLanes);
                      if (0 !== lanes) {
                        var root3 = fiber;
                        root3.pendingLanes |= 2;
                        for (root3.entangledLanes |= 2; lanes; ) {
                          var lane = 1 << 31 - clz32(lanes);
                          root3.entanglements[1] |= lane;
                          lanes &= ~lane;
                        }
                        ensureRootIsScheduled(fiber);
                        0 === (executionContext & 6) && (workInProgressRootRenderTargetTime = now() + 500, flushSyncWorkAcrossRoots_impl(0, false));
                      }
                    }
                    break;
                  case 13:
                    root3 = enqueueConcurrentRenderForLane(fiber, 2), null !== root3 && scheduleUpdateOnFiber(root3, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
                }
              fiber = findInstanceBlockingEvent(nativeEvent);
              null === fiber && dispatchEventForPluginEventSystem(
                domEventName,
                eventSystemFlags,
                nativeEvent,
                return_targetInst,
                targetContainer
              );
              if (fiber === blockedOn) break;
              blockedOn = fiber;
            }
            null !== blockedOn && nativeEvent.stopPropagation();
          } else
            dispatchEventForPluginEventSystem(
              domEventName,
              eventSystemFlags,
              nativeEvent,
              null,
              targetContainer
            );
        }
      }
      function findInstanceBlockingEvent(nativeEvent) {
        nativeEvent = getEventTarget(nativeEvent);
        return findInstanceBlockingTarget(nativeEvent);
      }
      var return_targetInst = null;
      function findInstanceBlockingTarget(targetNode) {
        return_targetInst = null;
        targetNode = getClosestInstanceFromNode(targetNode);
        if (null !== targetNode) {
          var nearestMounted = getNearestMountedFiber(targetNode);
          if (null === nearestMounted) targetNode = null;
          else {
            var tag = nearestMounted.tag;
            if (13 === tag) {
              targetNode = getSuspenseInstanceFromFiber(nearestMounted);
              if (null !== targetNode) return targetNode;
              targetNode = null;
            } else if (3 === tag) {
              if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
                return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              targetNode = null;
            } else nearestMounted !== targetNode && (targetNode = null);
          }
        }
        return_targetInst = targetNode;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "beforetoggle":
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "toggle":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return 2;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return 8;
          case "message":
            switch (getCurrentPriorityLevel()) {
              case ImmediatePriority:
                return 2;
              case UserBlockingPriority:
                return 8;
              case NormalPriority$1:
              case LowPriority:
                return 32;
              case IdlePriority:
                return 268435456;
              default:
                return 32;
            }
          default:
            return 32;
        }
      }
      var hasScheduledReplayAttempt = false;
      var queuedFocus = null;
      var queuedDrag = null;
      var queuedMouse = null;
      var queuedPointers = /* @__PURE__ */ new Map();
      var queuedPointerCaptures = /* @__PURE__ */ new Map();
      var queuedExplicitHydrationTargets = [];
      var discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
        " "
      );
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout":
            queuedPointers.delete(nativeEvent.pointerId);
            break;
          case "gotpointercapture":
          case "lostpointercapture":
            queuedPointerCaptures.delete(nativeEvent.pointerId);
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
          return existingQueuedEvent = {
            blockedOn,
            domEventName,
            eventSystemFlags,
            nativeEvent,
            targetContainers: [targetContainer]
          }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        blockedOn = existingQueuedEvent.targetContainers;
        null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin":
            return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedFocus,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "dragenter":
            return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedDrag,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "mouseover":
            return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
              queuedMouse,
              blockedOn,
              domEventName,
              eventSystemFlags,
              targetContainer,
              nativeEvent
            ), true;
          case "pointerover":
            var pointerId = nativeEvent.pointerId;
            queuedPointers.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointers.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            );
            return true;
          case "gotpointercapture":
            return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
              pointerId,
              accumulateOrCreateContinuousQueuedReplayableEvent(
                queuedPointerCaptures.get(pointerId) || null,
                blockedOn,
                domEventName,
                eventSystemFlags,
                targetContainer,
                nativeEvent
              )
            ), true;
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (null !== targetInst) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (null !== nearestMounted) {
            if (targetInst = nearestMounted.tag, 13 === targetInst) {
              if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
                queuedTarget.blockedOn = targetInst;
                runWithPriority(queuedTarget.priority, function() {
                  if (13 === nearestMounted.tag) {
                    var lane = requestUpdateLane();
                    lane = getBumpedLaneForHydrationByLane(lane);
                    var root3 = enqueueConcurrentRenderForLane(nearestMounted, lane);
                    null !== root3 && scheduleUpdateOnFiber(root3, nearestMounted, lane);
                    markRetryLaneIfNotHydrated(nearestMounted, lane);
                  }
                });
                return;
              }
            } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
              queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
              return;
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (null !== queuedEvent.blockedOn) return false;
        for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
          if (null === nextBlockedOn) {
            nextBlockedOn = queuedEvent.nativeEvent;
            var nativeEventClone = new nextBlockedOn.constructor(
              nextBlockedOn.type,
              nextBlockedOn
            );
            currentReplayingEvent = nativeEventClone;
            nextBlockedOn.target.dispatchEvent(nativeEventClone);
            currentReplayingEvent = null;
          } else
            return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map2) {
        attemptReplayContinuousQueuedEvent(queuedEvent) && map2.delete(key);
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
        null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
        null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          replayUnblockedEvents
        )));
      }
      var lastScheduledReplayQueue = null;
      function scheduleReplayQueueIfNeeded(formReplayingQueue) {
        lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
          Scheduler.unstable_NormalPriority,
          function() {
            lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
            for (var i = 0; i < formReplayingQueue.length; i += 3) {
              var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
              if ("function" !== typeof submitterOrAction)
                if (null === findInstanceBlockingTarget(submitterOrAction || form))
                  continue;
                else break;
              var formInst = getInstanceFromNode(form);
              null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, startHostTransition(
                formInst,
                {
                  pending: true,
                  data: formData,
                  method: form.method,
                  action: submitterOrAction
                },
                submitterOrAction,
                formData
              ));
            }
          }
        ));
      }
      function retryIfBlockedOn(unblocked) {
        function unblock(queuedEvent) {
          return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
        }
        null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
          var queuedTarget = queuedExplicitHydrationTargets[i];
          queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
        }
        for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
          attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
        i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
        if (null != i)
          for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
            var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
            if ("function" === typeof submitterOrAction)
              formProps || scheduleReplayQueueIfNeeded(i);
            else if (formProps) {
              var action = null;
              if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
                if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
                  action = formProps.formAction;
                else {
                  if (null !== findInstanceBlockingTarget(form)) continue;
                }
              else action = formProps.action;
              "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
              scheduleReplayQueueIfNeeded(i);
            }
          }
      }
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root3 = this._internalRoot;
        if (null === root3) throw Error(formatProdErrorMessage(409));
        var current = root3.current, lane = requestUpdateLane();
        updateContainerImpl(current, lane, children, root3, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        var root3 = this._internalRoot;
        if (null !== root3) {
          this._internalRoot = null;
          var container2 = root3.containerInfo;
          updateContainerImpl(root3.current, 2, null, root3, null, null);
          flushSyncWork$1();
          container2[internalContainerInstanceKey] = null;
        }
      };
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
        if (target) {
          var updatePriority = resolveUpdatePriority();
          target = { blockedOn: null, target, priority: updatePriority };
          for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
          queuedExplicitHydrationTargets.splice(i, 0, target);
          0 === i && attemptExplicitHydrationTarget(target);
        }
      };
      var isomorphicReactPackageVersion$jscomp$inline_1785 = React141.version;
      if ("19.1.0" !== isomorphicReactPackageVersion$jscomp$inline_1785)
        throw Error(
          formatProdErrorMessage(
            527,
            isomorphicReactPackageVersion$jscomp$inline_1785,
            "19.1.0"
          )
        );
      ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
        var fiber = componentOrElement._reactInternals;
        if (void 0 === fiber) {
          if ("function" === typeof componentOrElement.render)
            throw Error(formatProdErrorMessage(188));
          componentOrElement = Object.keys(componentOrElement).join(",");
          throw Error(formatProdErrorMessage(268, componentOrElement));
        }
        componentOrElement = findCurrentFiberUsingSlowPath(fiber);
        componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
        componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
        return componentOrElement;
      };
      var internals$jscomp$inline_2256 = {
        bundleType: 0,
        version: "19.1.0",
        rendererPackageName: "react-dom",
        currentDispatcherRef: ReactSharedInternals,
        reconcilerVersion: "19.1.0"
      };
      if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
        hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (!hook$jscomp$inline_2257.isDisabled && hook$jscomp$inline_2257.supportsFiber)
          try {
            rendererID = hook$jscomp$inline_2257.inject(
              internals$jscomp$inline_2256
            ), injectedHook = hook$jscomp$inline_2257;
          } catch (err) {
          }
      }
      var hook$jscomp$inline_2257;
      exports.createRoot = function(container2, options2) {
        if (!isValidContainer(container2)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks));
        options2 = createFiberRoot(
          container2,
          1,
          false,
          null,
          null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          null
        );
        container2[internalContainerInstanceKey] = options2.current;
        listenToAllSupportedEvents(container2);
        return new ReactDOMRoot(options2);
      };
      exports.hydrateRoot = function(container2, initialChildren, options2) {
        if (!isValidContainer(container2)) throw Error(formatProdErrorMessage(299));
        var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
        null !== options2 && void 0 !== options2 && (true === options2.unstable_strictMode && (isStrictMode = true), void 0 !== options2.identifierPrefix && (identifierPrefix = options2.identifierPrefix), void 0 !== options2.onUncaughtError && (onUncaughtError = options2.onUncaughtError), void 0 !== options2.onCaughtError && (onCaughtError = options2.onCaughtError), void 0 !== options2.onRecoverableError && (onRecoverableError = options2.onRecoverableError), void 0 !== options2.unstable_transitionCallbacks && (transitionCallbacks = options2.unstable_transitionCallbacks), void 0 !== options2.formState && (formState = options2.formState));
        initialChildren = createFiberRoot(
          container2,
          1,
          true,
          initialChildren,
          null != options2 ? options2 : null,
          isStrictMode,
          identifierPrefix,
          onUncaughtError,
          onCaughtError,
          onRecoverableError,
          transitionCallbacks,
          formState
        );
        initialChildren.context = getContextForSubtree(null);
        options2 = initialChildren.current;
        isStrictMode = requestUpdateLane();
        isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
        identifierPrefix = createUpdate2(isStrictMode);
        identifierPrefix.callback = null;
        enqueueUpdate(options2, identifierPrefix, isStrictMode);
        options2 = isStrictMode;
        initialChildren.current.lanes = options2;
        markRootUpdated$1(initialChildren, options2);
        ensureRootIsScheduled(initialChildren);
        container2[internalContainerInstanceKey] = initialChildren.current;
        listenToAllSupportedEvents(container2);
        return new ReactDOMHydrationRoot(initialChildren);
      };
      exports.version = "19.1.0";
    }
  });

  // node_modules/react-dom/client.js
  var require_client = __commonJS({
    "node_modules/react-dom/client.js"(exports, module) {
      "use strict";
      function checkDCE() {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
          return;
        }
        if (false) {
          throw new Error("^_^");
        }
        try {
          __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
        } catch (err) {
          console.error(err);
        }
      }
      if (true) {
        checkDCE();
        module.exports = require_react_dom_client_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/react/cjs/react-jsx-runtime.production.js
  var require_react_jsx_runtime_production = __commonJS({
    "node_modules/react/cjs/react-jsx-runtime.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      function jsxProd(type, config2, maybeKey) {
        var key = null;
        void 0 !== maybeKey && (key = "" + maybeKey);
        void 0 !== config2.key && (key = "" + config2.key);
        if ("key" in config2) {
          maybeKey = {};
          for (var propName in config2)
            "key" !== propName && (maybeKey[propName] = config2[propName]);
        } else maybeKey = config2;
        config2 = maybeKey.ref;
        return {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref: void 0 !== config2 ? config2 : null,
          props: maybeKey
        };
      }
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = jsxProd;
      exports.jsxs = jsxProd;
    }
  });

  // node_modules/react/jsx-runtime.js
  var require_jsx_runtime = __commonJS({
    "node_modules/react/jsx-runtime.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_jsx_runtime_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js
  var require_react_is_production_min = __commonJS({
    "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.production.min.js"(exports) {
      "use strict";
      var b = "function" === typeof Symbol && Symbol.for;
      var c = b ? Symbol.for("react.element") : 60103;
      var d = b ? Symbol.for("react.portal") : 60106;
      var e = b ? Symbol.for("react.fragment") : 60107;
      var f = b ? Symbol.for("react.strict_mode") : 60108;
      var g = b ? Symbol.for("react.profiler") : 60114;
      var h = b ? Symbol.for("react.provider") : 60109;
      var k = b ? Symbol.for("react.context") : 60110;
      var l = b ? Symbol.for("react.async_mode") : 60111;
      var m = b ? Symbol.for("react.concurrent_mode") : 60111;
      var n = b ? Symbol.for("react.forward_ref") : 60112;
      var p = b ? Symbol.for("react.suspense") : 60113;
      var q = b ? Symbol.for("react.suspense_list") : 60120;
      var r2 = b ? Symbol.for("react.memo") : 60115;
      var t = b ? Symbol.for("react.lazy") : 60116;
      var v = b ? Symbol.for("react.block") : 60121;
      var w = b ? Symbol.for("react.fundamental") : 60117;
      var x = b ? Symbol.for("react.responder") : 60118;
      var y = b ? Symbol.for("react.scope") : 60119;
      function z(a) {
        if ("object" === typeof a && null !== a) {
          var u = a.$$typeof;
          switch (u) {
            case c:
              switch (a = a.type, a) {
                case l:
                case m:
                case e:
                case g:
                case f:
                case p:
                  return a;
                default:
                  switch (a = a && a.$$typeof, a) {
                    case k:
                    case n:
                    case t:
                    case r2:
                    case h:
                      return a;
                    default:
                      return u;
                  }
              }
            case d:
              return u;
          }
        }
      }
      function A(a) {
        return z(a) === m;
      }
      exports.AsyncMode = l;
      exports.ConcurrentMode = m;
      exports.ContextConsumer = k;
      exports.ContextProvider = h;
      exports.Element = c;
      exports.ForwardRef = n;
      exports.Fragment = e;
      exports.Lazy = t;
      exports.Memo = r2;
      exports.Portal = d;
      exports.Profiler = g;
      exports.StrictMode = f;
      exports.Suspense = p;
      exports.isAsyncMode = function(a) {
        return A(a) || z(a) === l;
      };
      exports.isConcurrentMode = A;
      exports.isContextConsumer = function(a) {
        return z(a) === k;
      };
      exports.isContextProvider = function(a) {
        return z(a) === h;
      };
      exports.isElement = function(a) {
        return "object" === typeof a && null !== a && a.$$typeof === c;
      };
      exports.isForwardRef = function(a) {
        return z(a) === n;
      };
      exports.isFragment = function(a) {
        return z(a) === e;
      };
      exports.isLazy = function(a) {
        return z(a) === t;
      };
      exports.isMemo = function(a) {
        return z(a) === r2;
      };
      exports.isPortal = function(a) {
        return z(a) === d;
      };
      exports.isProfiler = function(a) {
        return z(a) === g;
      };
      exports.isStrictMode = function(a) {
        return z(a) === f;
      };
      exports.isSuspense = function(a) {
        return z(a) === p;
      };
      exports.isValidElementType = function(a) {
        return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r2 || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
      };
      exports.typeOf = z;
    }
  });

  // node_modules/hoist-non-react-statics/node_modules/react-is/index.js
  var require_react_is = __commonJS({
    "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_is_production_min();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
  var require_hoist_non_react_statics_cjs = __commonJS({
    "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
      "use strict";
      var reactIs = require_react_is();
      var REACT_STATICS = {
        childContextTypes: true,
        contextType: true,
        contextTypes: true,
        defaultProps: true,
        displayName: true,
        getDefaultProps: true,
        getDerivedStateFromError: true,
        getDerivedStateFromProps: true,
        mixins: true,
        propTypes: true,
        type: true
      };
      var KNOWN_STATICS = {
        name: true,
        length: true,
        prototype: true,
        caller: true,
        callee: true,
        arguments: true,
        arity: true
      };
      var FORWARD_REF_STATICS = {
        "$$typeof": true,
        render: true,
        defaultProps: true,
        displayName: true,
        propTypes: true
      };
      var MEMO_STATICS = {
        "$$typeof": true,
        compare: true,
        defaultProps: true,
        displayName: true,
        propTypes: true,
        type: true
      };
      var TYPE_STATICS = {};
      TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
      TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
      function getStatics(component) {
        if (reactIs.isMemo(component)) {
          return MEMO_STATICS;
        }
        return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
      }
      var defineProperty = Object.defineProperty;
      var getOwnPropertyNames = Object.getOwnPropertyNames;
      var getOwnPropertySymbols = Object.getOwnPropertySymbols;
      var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      var getPrototypeOf = Object.getPrototypeOf;
      var objectPrototype = Object.prototype;
      function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
        if (typeof sourceComponent !== "string") {
          if (objectPrototype) {
            var inheritedComponent = getPrototypeOf(sourceComponent);
            if (inheritedComponent && inheritedComponent !== objectPrototype) {
              hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
            }
          }
          var keys = getOwnPropertyNames(sourceComponent);
          if (getOwnPropertySymbols) {
            keys = keys.concat(getOwnPropertySymbols(sourceComponent));
          }
          var targetStatics = getStatics(targetComponent);
          var sourceStatics = getStatics(sourceComponent);
          for (var i = 0; i < keys.length; ++i) {
            var key = keys[i];
            if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
              var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
              try {
                defineProperty(targetComponent, key, descriptor);
              } catch (e) {
              }
            }
          }
        }
        return targetComponent;
      }
      module.exports = hoistNonReactStatics;
    }
  });

  // node_modules/@babel/runtime/helpers/extends.js
  var require_extends = __commonJS({
    "node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
      "use strict";
      function _extends2() {
        return module.exports = _extends2 = Object.assign ? Object.assign.bind() : function(n) {
          for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
          }
          return n;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports, _extends2.apply(null, arguments);
      }
      module.exports = _extends2, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
  });

  // node_modules/react-is/cjs/react-is.production.js
  var require_react_is_production = __commonJS({
    "node_modules/react-is/cjs/react-is.production.js"(exports) {
      "use strict";
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition");
      var REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      function typeOf(object) {
        if ("object" === typeof object && null !== object) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              switch (object = object.type, object) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_VIEW_TRANSITION_TYPE:
                  return object;
                default:
                  switch (object = object && object.$$typeof, object) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                      return object;
                    case REACT_CONSUMER_TYPE:
                      return object;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      exports.ContextConsumer = REACT_CONSUMER_TYPE;
      exports.ContextProvider = REACT_CONTEXT_TYPE;
      exports.Element = REACT_ELEMENT_TYPE;
      exports.ForwardRef = REACT_FORWARD_REF_TYPE;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Lazy = REACT_LAZY_TYPE;
      exports.Memo = REACT_MEMO_TYPE;
      exports.Portal = REACT_PORTAL_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      exports.isContextConsumer = function(object) {
        return typeOf(object) === REACT_CONSUMER_TYPE;
      };
      exports.isContextProvider = function(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      };
      exports.isElement = function(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      };
      exports.isForwardRef = function(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      };
      exports.isFragment = function(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      };
      exports.isLazy = function(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      };
      exports.isMemo = function(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      };
      exports.isPortal = function(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      };
      exports.isProfiler = function(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      };
      exports.isStrictMode = function(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      };
      exports.isSuspense = function(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      };
      exports.isSuspenseList = function(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      };
      exports.isValidElementType = function(type) {
        return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
      };
      exports.typeOf = typeOf;
    }
  });

  // node_modules/react-is/index.js
  var require_react_is2 = __commonJS({
    "node_modules/react-is/index.js"(exports, module) {
      "use strict";
      if (true) {
        module.exports = require_react_is_production();
      } else {
        module.exports = null;
      }
    }
  });

  // node_modules/dayjs/dayjs.min.js
  var require_dayjs_min = __commonJS({
    "node_modules/dayjs/dayjs.min.js"(exports, module) {
      "use strict";
      !function(t, e) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
      }(exports, function() {
        "use strict";
        var t = 1e3, e = 6e4, n = 36e5, r2 = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
          var e3 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
          return "[" + t2 + (e3[(n2 - 20) % 10] || e3[n2] || e3[0]) + "]";
        } }, m = function(t2, e3, n2) {
          var r3 = String(t2);
          return !r3 || r3.length >= e3 ? t2 : "" + Array(e3 + 1 - r3.length).join(n2) + t2;
        }, v = { s: m, z: function(t2) {
          var e3 = -t2.utcOffset(), n2 = Math.abs(e3), r3 = Math.floor(n2 / 60), i2 = n2 % 60;
          return (e3 <= 0 ? "+" : "-") + m(r3, 2, "0") + ":" + m(i2, 2, "0");
        }, m: function t2(e3, n2) {
          if (e3.date() < n2.date()) return -t2(n2, e3);
          var r3 = 12 * (n2.year() - e3.year()) + (n2.month() - e3.month()), i2 = e3.clone().add(r3, c), s2 = n2 - i2 < 0, u2 = e3.clone().add(r3 + (s2 ? -1 : 1), c);
          return +(-(r3 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
        }, a: function(t2) {
          return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
        }, p: function(t2) {
          return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r2, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
        }, u: function(t2) {
          return void 0 === t2;
        } }, g = "en", D = {};
        D[g] = M;
        var p = "$isDayjsObject", S = function(t2) {
          return t2 instanceof _2 || !(!t2 || !t2[p]);
        }, w = function t2(e3, n2, r3) {
          var i2;
          if (!e3) return g;
          if ("string" == typeof e3) {
            var s2 = e3.toLowerCase();
            D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
            var u2 = e3.split("-");
            if (!i2 && u2.length > 1) return t2(u2[0]);
          } else {
            var a2 = e3.name;
            D[a2] = e3, i2 = a2;
          }
          return !r3 && i2 && (g = i2), i2 || !r3 && g;
        }, O = function(t2, e3) {
          if (S(t2)) return t2.clone();
          var n2 = "object" == typeof e3 ? e3 : {};
          return n2.date = t2, n2.args = arguments, new _2(n2);
        }, b = v;
        b.l = w, b.i = S, b.w = function(t2, e3) {
          return O(t2, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
        };
        var _2 = function() {
          function M2(t2) {
            this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
          }
          var m2 = M2.prototype;
          return m2.parse = function(t2) {
            this.$d = function(t3) {
              var e3 = t3.date, n2 = t3.utc;
              if (null === e3) return /* @__PURE__ */ new Date(NaN);
              if (b.u(e3)) return /* @__PURE__ */ new Date();
              if (e3 instanceof Date) return new Date(e3);
              if ("string" == typeof e3 && !/Z$/i.test(e3)) {
                var r3 = e3.match($);
                if (r3) {
                  var i2 = r3[2] - 1 || 0, s2 = (r3[7] || "0").substring(0, 3);
                  return n2 ? new Date(Date.UTC(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2)) : new Date(r3[1], i2, r3[3] || 1, r3[4] || 0, r3[5] || 0, r3[6] || 0, s2);
                }
              }
              return new Date(e3);
            }(t2), this.init();
          }, m2.init = function() {
            var t2 = this.$d;
            this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
          }, m2.$utils = function() {
            return b;
          }, m2.isValid = function() {
            return !(this.$d.toString() === l);
          }, m2.isSame = function(t2, e3) {
            var n2 = O(t2);
            return this.startOf(e3) <= n2 && n2 <= this.endOf(e3);
          }, m2.isAfter = function(t2, e3) {
            return O(t2) < this.startOf(e3);
          }, m2.isBefore = function(t2, e3) {
            return this.endOf(e3) < O(t2);
          }, m2.$g = function(t2, e3, n2) {
            return b.u(t2) ? this[e3] : this.set(n2, t2);
          }, m2.unix = function() {
            return Math.floor(this.valueOf() / 1e3);
          }, m2.valueOf = function() {
            return this.$d.getTime();
          }, m2.startOf = function(t2, e3) {
            var n2 = this, r3 = !!b.u(e3) || e3, f2 = b.p(t2), l2 = function(t3, e4) {
              var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e4, t3) : new Date(n2.$y, e4, t3), n2);
              return r3 ? i2 : i2.endOf(a);
            }, $2 = function(t3, e4) {
              return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r3 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n2);
            }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
            switch (f2) {
              case h:
                return r3 ? l2(1, 0) : l2(31, 11);
              case c:
                return r3 ? l2(1, M3) : l2(0, M3 + 1);
              case o:
                var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
                return l2(r3 ? m3 - D2 : m3 + (6 - D2), M3);
              case a:
              case d:
                return $2(v2 + "Hours", 0);
              case u:
                return $2(v2 + "Minutes", 1);
              case s:
                return $2(v2 + "Seconds", 2);
              case i:
                return $2(v2 + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m2.endOf = function(t2) {
            return this.startOf(t2, false);
          }, m2.$set = function(t2, e3) {
            var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r2] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e3 - this.$W) : e3;
            if (o2 === c || o2 === h) {
              var y2 = this.clone().set(d, 1);
              y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
            } else l2 && this.$d[l2]($2);
            return this.init(), this;
          }, m2.set = function(t2, e3) {
            return this.clone().$set(t2, e3);
          }, m2.get = function(t2) {
            return this[b.p(t2)]();
          }, m2.add = function(r3, f2) {
            var d2, l2 = this;
            r3 = Number(r3);
            var $2 = b.p(f2), y2 = function(t2) {
              var e3 = O(l2);
              return b.w(e3.date(e3.date() + Math.round(t2 * r3)), l2);
            };
            if ($2 === c) return this.set(c, this.$M + r3);
            if ($2 === h) return this.set(h, this.$y + r3);
            if ($2 === a) return y2(1);
            if ($2 === o) return y2(7);
            var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r3 * M3;
            return b.w(m3, this);
          }, m2.subtract = function(t2, e3) {
            return this.add(-1 * t2, e3);
          }, m2.format = function(t2) {
            var e3 = this, n2 = this.$locale();
            if (!this.isValid()) return n2.invalidDate || l;
            var r3 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c6 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
              return t3 && (t3[n3] || t3(e3, r3)) || i3[n3].slice(0, s3);
            }, d2 = function(t3) {
              return b.s(s2 % 12 || 12, t3, "0");
            }, $2 = f2 || function(t3, e4, n3) {
              var r4 = t3 < 12 ? "AM" : "PM";
              return n3 ? r4.toLowerCase() : r4;
            };
            return r3.replace(y, function(t3, r4) {
              return r4 || function(t4) {
                switch (t4) {
                  case "YY":
                    return String(e3.$y).slice(-2);
                  case "YYYY":
                    return b.s(e3.$y, 4, "0");
                  case "M":
                    return a2 + 1;
                  case "MM":
                    return b.s(a2 + 1, 2, "0");
                  case "MMM":
                    return h2(n2.monthsShort, a2, c6, 3);
                  case "MMMM":
                    return h2(c6, a2);
                  case "D":
                    return e3.$D;
                  case "DD":
                    return b.s(e3.$D, 2, "0");
                  case "d":
                    return String(e3.$W);
                  case "dd":
                    return h2(n2.weekdaysMin, e3.$W, o2, 2);
                  case "ddd":
                    return h2(n2.weekdaysShort, e3.$W, o2, 3);
                  case "dddd":
                    return o2[e3.$W];
                  case "H":
                    return String(s2);
                  case "HH":
                    return b.s(s2, 2, "0");
                  case "h":
                    return d2(1);
                  case "hh":
                    return d2(2);
                  case "a":
                    return $2(s2, u2, true);
                  case "A":
                    return $2(s2, u2, false);
                  case "m":
                    return String(u2);
                  case "mm":
                    return b.s(u2, 2, "0");
                  case "s":
                    return String(e3.$s);
                  case "ss":
                    return b.s(e3.$s, 2, "0");
                  case "SSS":
                    return b.s(e3.$ms, 3, "0");
                  case "Z":
                    return i2;
                }
                return null;
              }(t3) || i2.replace(":", "");
            });
          }, m2.utcOffset = function() {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m2.diff = function(r3, d2, l2) {
            var $2, y2 = this, M3 = b.p(d2), m3 = O(r3), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
              return b.m(y2, m3);
            };
            switch (M3) {
              case h:
                $2 = D2() / 12;
                break;
              case c:
                $2 = D2();
                break;
              case f:
                $2 = D2() / 3;
                break;
              case o:
                $2 = (g2 - v2) / 6048e5;
                break;
              case a:
                $2 = (g2 - v2) / 864e5;
                break;
              case u:
                $2 = g2 / n;
                break;
              case s:
                $2 = g2 / e;
                break;
              case i:
                $2 = g2 / t;
                break;
              default:
                $2 = g2;
            }
            return l2 ? $2 : b.a($2);
          }, m2.daysInMonth = function() {
            return this.endOf(c).$D;
          }, m2.$locale = function() {
            return D[this.$L];
          }, m2.locale = function(t2, e3) {
            if (!t2) return this.$L;
            var n2 = this.clone(), r3 = w(t2, e3, true);
            return r3 && (n2.$L = r3), n2;
          }, m2.clone = function() {
            return b.w(this.$d, this);
          }, m2.toDate = function() {
            return new Date(this.valueOf());
          }, m2.toJSON = function() {
            return this.isValid() ? this.toISOString() : null;
          }, m2.toISOString = function() {
            return this.$d.toISOString();
          }, m2.toString = function() {
            return this.$d.toUTCString();
          }, M2;
        }(), k = _2.prototype;
        return O.prototype = k, [["$ms", r2], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
          k[t2[1]] = function(e3) {
            return this.$g(e3, t2[0], t2[1]);
          };
        }), O.extend = function(t2, e3) {
          return t2.$i || (t2(e3, _2, O), t2.$i = true), O;
        }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
          return O(1e3 * t2);
        }, O.en = D[g], O.Ls = D, O.p = {}, O;
      });
    }
  });

  // node_modules/lodash/lodash.js
  var require_lodash = __commonJS({
    "node_modules/lodash/lodash.js"(exports, module) {
      "use strict";
      (function() {
        var undefined2;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [
          ["ary", WRAP_ARY_FLAG],
          ["bind", WRAP_BIND_FLAG],
          ["bindKey", WRAP_BIND_KEY_FLAG],
          ["curry", WRAP_CURRY_FLAG],
          ["curryRight", WRAP_CURRY_RIGHT_FLAG],
          ["flip", WRAP_FLIP_FLAG],
          ["partial", WRAP_PARTIAL_FLAG],
          ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
          ["rearg", WRAP_REARG_FLAG]
        ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([
          rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
          rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
          rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
          rsUpper + "+" + rsOptContrUpper,
          rsOrdUpper,
          rsOrdLower,
          rsDigits,
          rsEmoji
        ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [
          "Array",
          "Buffer",
          "DataView",
          "Date",
          "Error",
          "Float32Array",
          "Float64Array",
          "Function",
          "Int8Array",
          "Int16Array",
          "Int32Array",
          "Map",
          "Math",
          "Object",
          "Promise",
          "RegExp",
          "Set",
          "String",
          "Symbol",
          "TypeError",
          "Uint8Array",
          "Uint8ClampedArray",
          "Uint16Array",
          "Uint32Array",
          "WeakMap",
          "_",
          "clearTimeout",
          "isFinite",
          "parseInt",
          "setTimeout"
        ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          // Latin-1 Supplement block.
          "\xC0": "A",
          "\xC1": "A",
          "\xC2": "A",
          "\xC3": "A",
          "\xC4": "A",
          "\xC5": "A",
          "\xE0": "a",
          "\xE1": "a",
          "\xE2": "a",
          "\xE3": "a",
          "\xE4": "a",
          "\xE5": "a",
          "\xC7": "C",
          "\xE7": "c",
          "\xD0": "D",
          "\xF0": "d",
          "\xC8": "E",
          "\xC9": "E",
          "\xCA": "E",
          "\xCB": "E",
          "\xE8": "e",
          "\xE9": "e",
          "\xEA": "e",
          "\xEB": "e",
          "\xCC": "I",
          "\xCD": "I",
          "\xCE": "I",
          "\xCF": "I",
          "\xEC": "i",
          "\xED": "i",
          "\xEE": "i",
          "\xEF": "i",
          "\xD1": "N",
          "\xF1": "n",
          "\xD2": "O",
          "\xD3": "O",
          "\xD4": "O",
          "\xD5": "O",
          "\xD6": "O",
          "\xD8": "O",
          "\xF2": "o",
          "\xF3": "o",
          "\xF4": "o",
          "\xF5": "o",
          "\xF6": "o",
          "\xF8": "o",
          "\xD9": "U",
          "\xDA": "U",
          "\xDB": "U",
          "\xDC": "U",
          "\xF9": "u",
          "\xFA": "u",
          "\xFB": "u",
          "\xFC": "u",
          "\xDD": "Y",
          "\xFD": "y",
          "\xFF": "y",
          "\xC6": "Ae",
          "\xE6": "ae",
          "\xDE": "Th",
          "\xFE": "th",
          "\xDF": "ss",
          // Latin Extended-A block.
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010A": "C",
          "\u010C": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010B": "c",
          "\u010D": "c",
          "\u010E": "D",
          "\u0110": "D",
          "\u010F": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011A": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011B": "e",
          "\u011C": "G",
          "\u011E": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011D": "g",
          "\u011F": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012A": "I",
          "\u012C": "I",
          "\u012E": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012B": "i",
          "\u012D": "i",
          "\u012F": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013B": "L",
          "\u013D": "L",
          "\u013F": "L",
          "\u0141": "L",
          "\u013A": "l",
          "\u013C": "l",
          "\u013E": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014A": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014B": "n",
          "\u014C": "O",
          "\u014E": "O",
          "\u0150": "O",
          "\u014D": "o",
          "\u014F": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015A": "S",
          "\u015C": "S",
          "\u015E": "S",
          "\u0160": "S",
          "\u015B": "s",
          "\u015D": "s",
          "\u015F": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016A": "U",
          "\u016C": "U",
          "\u016E": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016B": "u",
          "\u016D": "u",
          "\u016F": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017B": "Z",
          "\u017D": "Z",
          "\u017A": "z",
          "\u017C": "z",
          "\u017E": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017F": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root2 = freeGlobal || freeSelf || Function("return this")();
        var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
        var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) {
              return types;
            }
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {
          }
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length2 = array == null ? 0 : array.length;
          while (++index < length2) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length2 = array == null ? 0 : array.length;
          while (++index < length2) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length2 = array == null ? 0 : array.length;
          while (length2--) {
            if (iteratee(array[length2], length2, array) === false) {
              break;
            }
          }
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length2 = array == null ? 0 : array.length;
          while (++index < length2) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length2) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length2 = array == null ? 0 : array.length;
          return !!length2 && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length2 = array == null ? 0 : array.length;
          while (++index < length2) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length2 = array == null ? 0 : array.length, result = Array(length2);
          while (++index < length2) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }
        function arrayPush(array, values3) {
          var index = -1, length2 = values3.length, offset2 = array.length;
          while (++index < length2) {
            array[offset2 + index] = values3[index];
          }
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length2 = array == null ? 0 : array.length;
          if (initAccum && length2) {
            accumulator = array[++index];
          }
          while (++index < length2) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length2 = array == null ? 0 : array.length;
          if (initAccum && length2) {
            accumulator = array[--length2];
          }
          while (length2--) {
            accumulator = iteratee(accumulator, array[length2], length2, array);
          }
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length2 = array == null ? 0 : array.length;
          while (++index < length2) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection2) {
            if (predicate(value, key, collection2)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length2 = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length2) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length2 = array.length;
          while (++index < length2) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length2 = array == null ? 0 : array.length;
          return length2 ? baseSum(array, iteratee) / length2 : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return object == null ? undefined2 : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return object == null ? undefined2 : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection2) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length2 = array.length;
          array.sort(comparer);
          while (length2--) {
            array[length2] = array[length2].value;
          }
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length2 = array.length;
          while (++index < length2) {
            var current = iteratee(array[index]);
            if (current !== undefined2) {
              result = result === undefined2 ? current : result + current;
            }
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [key, object[key]];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length2 = strSymbols.length;
          while (++index < length2 && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
          }
          return index;
        }
        function countHolders(array, placeholder) {
          var length2 = array.length, result = 0;
          while (length2--) {
            if (array[length2] === placeholder) {
              ++result;
            }
          }
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue2(object, key) {
          return object == null ? undefined2 : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }
        function mapToArray(map2) {
          var index = -1, result = Array(map2.size);
          map2.forEach(function(value, key) {
            result[++index] = [key, value];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg2) {
            return func(transform(arg2));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length2 = array.length, resIndex = 0, result = [];
          while (++index < length2) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [value, value];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length2 = array.length;
          while (++index < length2) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {
          }
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext2(context) {
          context = context == null ? root2 : _2.defaults(root2.Object(), context, _2.pick(root2, contextProps));
          var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
          var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object2);
          var oldDash = root2._;
          var reIsNative = RegExp2(
            "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
          );
          var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
          var defineProperty = function() {
            try {
              var func = getNative(Object2, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {
            }
          }();
          var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
          var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
          var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
          var metaMap = WeakMap2 && new WeakMap2();
          var realNames = {};
          var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
          var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, "__wrapped__")) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }
          var baseCreate = /* @__PURE__ */ function() {
            function object() {
            }
            return function(proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result2 = new object();
              object.prototype = undefined2;
              return result2;
            };
          }();
          function baseLodash() {
          }
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined2;
          }
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "escape": reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "evaluate": reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            "interpolate": reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            "variable": "",
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            "imports": {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              "_": lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result2 = new LazyWrapper(this.__wrapped__);
            result2.__actions__ = copyArray(this.__actions__);
            result2.__dir__ = this.__dir__;
            result2.__filtered__ = this.__filtered__;
            result2.__iteratees__ = copyArray(this.__iteratees__);
            result2.__takeCount__ = this.__takeCount__;
            result2.__views__ = copyArray(this.__views__);
            return result2;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result2 = new LazyWrapper(this);
              result2.__dir__ = -1;
              result2.__filtered__ = true;
            } else {
              result2 = this.clone();
              result2.__dir__ *= -1;
            }
            return result2;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start3 = view.start, end2 = view.end, length2 = end2 - start3, index = isRight ? end2 : start3 - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result2 = [];
            outer:
              while (length2-- && resIndex < takeCount) {
                index += dir;
                var iterIndex = -1, value = array[index];
                while (++iterIndex < iterLength) {
                  var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                  if (type == LAZY_MAP_FLAG) {
                    value = computed;
                  } else if (!computed) {
                    if (type == LAZY_FILTER_FLAG) {
                      continue outer;
                    } else {
                      break outer;
                    }
                  }
                }
                result2[resIndex++] = value;
              }
            return result2;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length2) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result2 = this.has(key) && delete this.__data__[key];
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result2 = data[key];
              return result2 === HASH_UNDEFINED ? undefined2 : result2;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined2;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length2) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined2 : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length2 = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length2) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              "hash": new Hash(),
              "map": new (Map2 || ListCache)(),
              "string": new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result2 = getMapData(this, key)["delete"](key);
            this.size -= result2 ? 1 : 0;
            return result2;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size2 = data.size;
            data.set(key, value);
            this.size += data.size == size2 ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values4) {
            var index = -1, length2 = values4 == null ? 0 : values4.length;
            this.__data__ = new MapCache();
            while (++index < length2) {
              this.add(values4[index]);
            }
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack2(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result2 = data["delete"](key);
            this.size = data.size;
            return result2;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack2.prototype.clear = stackClear;
          Stack2.prototype["delete"] = stackDelete;
          Stack2.prototype.get = stackGet;
          Stack2.prototype.has = stackHas;
          Stack2.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
              (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
              isIndex(key, length2)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function arraySample(array) {
            var length2 = array.length;
            return length2 ? array[baseRandom(0, length2 - 1)] : undefined2;
          }
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }
          function assocIndexOf(array, key) {
            var length2 = array.length;
            while (length2--) {
              if (eq(array[length2][0], key)) {
                return length2;
              }
            }
            return -1;
          }
          function baseAggregator(collection, setter, iteratee2, accumulator) {
            baseEach(collection, function(value, key, collection2) {
              setter(accumulator, value, iteratee2(value), collection2);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            if (key == "__proto__" && defineProperty) {
              defineProperty(object, key, {
                "configurable": true,
                "enumerable": true,
                "value": value,
                "writable": true
              });
            } else {
              object[key] = value;
            }
          }
          function baseAt(object, paths) {
            var index = -1, length2 = paths.length, result2 = Array2(length2), skip = object == null;
            while (++index < length2) {
              result2[index] = skip ? undefined2 : get(object, paths[index]);
            }
            return result2;
          }
          function baseClamp(number4, lower, upper) {
            if (number4 === number4) {
              if (upper !== undefined2) {
                number4 = number4 <= upper ? number4 : upper;
              }
              if (lower !== undefined2) {
                number4 = number4 >= lower ? number4 : lower;
              }
            }
            return number4;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result2 = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result2 !== undefined2) {
              return result2;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result2 = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result2);
              }
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result2 = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result2 = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack2());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result2);
            if (isSet(value)) {
              value.forEach(function(subValue) {
                result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function(subValue, key2) {
                result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined2 : keysFunc(value);
            arrayEach(props || value, function(subValue, key2) {
              if (props) {
                key2 = subValue;
                subValue = value[key2];
              }
              assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
            return result2;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length2 = props.length;
            if (object == null) {
              return !length2;
            }
            object = Object2(object);
            while (length2--) {
              var key = props[length2], predicate = source[key], value = object[key];
              if (value === undefined2 && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return setTimeout2(function() {
              func.apply(undefined2, args);
            }, wait);
          }
          function baseDifference(array, values4, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, isCommon = true, length2 = array.length, result2 = [], valuesLength = values4.length;
            if (!length2) {
              return result2;
            }
            if (iteratee2) {
              values4 = arrayMap(values4, baseUnary(iteratee2));
            }
            if (comparator) {
              includes2 = arrayIncludesWith;
              isCommon = false;
            } else if (values4.length >= LARGE_ARRAY_SIZE) {
              includes2 = cacheHas;
              isCommon = false;
              values4 = new SetCache(values4);
            }
            outer:
              while (++index < length2) {
                var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var valuesIndex = valuesLength;
                  while (valuesIndex--) {
                    if (values4[valuesIndex] === computed) {
                      continue outer;
                    }
                  }
                  result2.push(value);
                } else if (!includes2(values4, computed, comparator)) {
                  result2.push(value);
                }
              }
            return result2;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result2 = true;
            baseEach(collection, function(value, index, collection2) {
              result2 = !!predicate(value, index, collection2);
              return result2;
            });
            return result2;
          }
          function baseExtremum(array, iteratee2, comparator) {
            var index = -1, length2 = array.length;
            while (++index < length2) {
              var value = array[index], current = iteratee2(value);
              if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current, result2 = value;
              }
            }
            return result2;
          }
          function baseFill(array, value, start3, end2) {
            var length2 = array.length;
            start3 = toInteger(start3);
            if (start3 < 0) {
              start3 = -start3 > length2 ? 0 : length2 + start3;
            }
            end2 = end2 === undefined2 || end2 > length2 ? length2 : toInteger(end2);
            if (end2 < 0) {
              end2 += length2;
            }
            end2 = start3 > end2 ? 0 : toLength(end2);
            while (start3 < end2) {
              array[start3++] = value;
            }
            return array;
          }
          function baseFilter(collection, predicate) {
            var result2 = [];
            baseEach(collection, function(value, index, collection2) {
              if (predicate(value, index, collection2)) {
                result2.push(value);
              }
            });
            return result2;
          }
          function baseFlatten(array, depth, predicate, isStrict, result2) {
            var index = -1, length2 = array.length;
            predicate || (predicate = isFlattenable);
            result2 || (result2 = []);
            while (++index < length2) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  baseFlatten(value, depth - 1, predicate, isStrict, result2);
                } else {
                  arrayPush(result2, value);
                }
              } else if (!isStrict) {
                result2[result2.length] = value;
              }
            }
            return result2;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee2) {
            return object && baseFor(object, iteratee2, keys);
          }
          function baseForOwnRight(object, iteratee2) {
            return object && baseForRight(object, iteratee2, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length2 = path.length;
            while (object != null && index < length2) {
              object = object[toKey(path[index++])];
            }
            return index && index == length2 ? object : undefined2;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result2 = keysFunc(object);
            return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined2 ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return object != null && key in Object2(object);
          }
          function baseInRange(number4, start3, end2) {
            return number4 >= nativeMin(start3, end2) && number4 < nativeMax(start3, end2);
          }
          function baseIntersection(arrays, iteratee2, comparator) {
            var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee2) {
                array = arrayMap(array, baseUnary(iteratee2));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer:
              while (++index < length2 && result2.length < maxLength) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                  othIndex = othLength;
                  while (--othIndex) {
                    var cache = caches[othIndex];
                    if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                      continue outer;
                    }
                  }
                  if (seen) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseInverter(object, setter, iteratee2, accumulator) {
            baseForOwn(object, function(value, key, object2) {
              setter(accumulator, iteratee2(value), key, object2);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined2 : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack2());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack2());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack2());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length2 = index, noCustomizer = !customizer;
            if (object == null) {
              return !length2;
            }
            object = Object2(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length2) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined2 && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack2();
                if (customizer) {
                  var result2 = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                  return false;
                }
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if (typeof value == "function") {
              return value;
            }
            if (value == null) {
              return identity2;
            }
            if (typeof value == "object") {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result2 = [];
            for (var key in Object2(object)) {
              if (hasOwnProperty.call(object, key) && key != "constructor") {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object), result2 = [];
            for (var key in object) {
              if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
                result2.push(key);
              }
            }
            return result2;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee2) {
            var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value, key, collection2) {
              result2[++index] = iteratee2(value, key, collection2);
            });
            return result2;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack2());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
                if (newValue === undefined2) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
            var isCommon = newValue === undefined2;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n) {
            var length2 = array.length;
            if (!length2) {
              return;
            }
            n += n < 0 ? length2 : 0;
            return isIndex(n, length2) ? array[n] : undefined2;
          }
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function(iteratee2) {
                if (isArray(iteratee2)) {
                  return function(value) {
                    return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                  };
                }
                return iteratee2;
              });
            } else {
              iteratees = [identity2];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result2 = baseMap(collection, function(value, key, collection2) {
              var criteria = arrayMap(iteratees, function(iteratee2) {
                return iteratee2(value);
              });
              return { "criteria": criteria, "index": ++index, "value": value };
            });
            return baseSortBy(result2, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length2 = paths.length, result2 = {};
            while (++index < length2) {
              var path = paths[index], value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result2, castPath(path, object), value);
              }
            }
            return result2;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values4, iteratee2, comparator) {
            var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length2 = values4.length, seen = array;
            if (array === values4) {
              values4 = copyArray(values4);
            }
            if (iteratee2) {
              seen = arrayMap(array, baseUnary(iteratee2));
            }
            while (++index < length2) {
              var fromIndex = 0, value = values4[index], computed = iteratee2 ? iteratee2(value) : value;
              while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length2 = array ? indexes.length : 0, lastIndex = length2 - 1;
            while (length2--) {
              var index = indexes[length2];
              if (length2 == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start3, end2, step, fromRight) {
            var index = -1, length2 = nativeMax(nativeCeil((end2 - start3) / (step || 1)), 0), result2 = Array2(length2);
            while (length2--) {
              result2[fromRight ? length2 : ++index] = start3;
              start3 += step;
            }
            return result2;
          }
          function baseRepeat(string, n) {
            var result2 = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result2;
            }
            do {
              if (n % 2) {
                result2 += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result2;
          }
          function baseRest(func, start3) {
            return setToString(overRest(func, start3, identity2), func + "");
          }
          function baseSample(collection) {
            return arraySample(values3(collection));
          }
          function baseSampleSize(collection, n) {
            var array = values3(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1, length2 = path.length, lastIndex = length2 - 1, nested = object;
            while (nested != null && ++index < length2) {
              var key = toKey(path[index]), newValue = value;
              if (key === "__proto__" || key === "constructor" || key === "prototype") {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined2;
                if (newValue === undefined2) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = !metaMap ? identity2 : function(func, data) {
            metaMap.set(func, data);
            return func;
          };
          var baseSetToString = !defineProperty ? identity2 : function(func, string) {
            return defineProperty(func, "toString", {
              "configurable": true,
              "enumerable": false,
              "value": constant(string),
              "writable": true
            });
          };
          function baseShuffle(collection) {
            return shuffleSelf(values3(collection));
          }
          function baseSlice(array, start3, end2) {
            var index = -1, length2 = array.length;
            if (start3 < 0) {
              start3 = -start3 > length2 ? 0 : length2 + start3;
            }
            end2 = end2 > length2 ? length2 : end2;
            if (end2 < 0) {
              end2 += length2;
            }
            length2 = start3 > end2 ? 0 : end2 - start3 >>> 0;
            start3 >>>= 0;
            var result2 = Array2(length2);
            while (++index < length2) {
              result2[index] = array[index + start3];
            }
            return result2;
          }
          function baseSome(collection, predicate) {
            var result2;
            baseEach(collection, function(value, index, collection2) {
              result2 = predicate(value, index, collection2);
              return !result2;
            });
            return !!result2;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = array == null ? low : array.length;
            if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity2, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee2, retHighest) {
            var low = 0, high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee2(value);
            var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee2) {
            var index = -1, length2 = array.length, resIndex = 0, result2 = [];
            while (++index < length2) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result2[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result2;
          }
          function baseToNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }
          function baseToString(value) {
            if (typeof value == "string") {
              return value;
            }
            if (isArray(value)) {
              return arrayMap(value, baseToString) + "";
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : "";
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function baseUniq(array, iteratee2, comparator) {
            var index = -1, includes2 = arrayIncludes, length2 = array.length, isCommon = true, result2 = [], seen = result2;
            if (comparator) {
              isCommon = false;
              includes2 = arrayIncludesWith;
            } else if (length2 >= LARGE_ARRAY_SIZE) {
              var set2 = iteratee2 ? null : createSet(array);
              if (set2) {
                return setToArray(set2);
              }
              isCommon = false;
              includes2 = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee2 ? [] : result2;
            }
            outer:
              while (++index < length2) {
                var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
                value = comparator || value !== 0 ? value : 0;
                if (isCommon && computed === computed) {
                  var seenIndex = seen.length;
                  while (seenIndex--) {
                    if (seen[seenIndex] === computed) {
                      continue outer;
                    }
                  }
                  if (iteratee2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                } else if (!includes2(seen, computed, comparator)) {
                  if (seen !== result2) {
                    seen.push(computed);
                  }
                  result2.push(value);
                }
              }
            return result2;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length2 = array.length, index = fromRight ? length2 : -1;
            while ((fromRight ? index-- : ++index < length2) && predicate(array[index], index, array)) {
            }
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length2) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length2 : index);
          }
          function baseWrapperValue(value, actions) {
            var result2 = value;
            if (result2 instanceof LazyWrapper) {
              result2 = result2.value();
            }
            return arrayReduce(actions, function(result3, action) {
              return action.func.apply(action.thisArg, arrayPush([result3], action.args));
            }, result2);
          }
          function baseXor(arrays, iteratee2, comparator) {
            var length2 = arrays.length;
            if (length2 < 2) {
              return length2 ? baseUniq(arrays[0]) : [];
            }
            var index = -1, result2 = Array2(length2);
            while (++index < length2) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length2) {
                if (othIndex != index) {
                  result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
          }
          function baseZipObject(props, values4, assignFunc) {
            var index = -1, length2 = props.length, valsLength = values4.length, result2 = {};
            while (++index < length2) {
              var value = index < valsLength ? values4[index] : undefined2;
              assignFunc(result2, props[index], value);
            }
            return result2;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return typeof value == "function" ? value : identity2;
          }
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array, start3, end2) {
            var length2 = array.length;
            end2 = end2 === undefined2 ? length2 : end2;
            return !start3 && end2 >= length2 ? array : baseSlice(array, start3, end2);
          }
          var clearTimeout2 = ctxClearTimeout || function(id) {
            return root2.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
            buffer.copy(result2);
            return result2;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
            return result2;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result2.lastIndex = regexp.lastIndex;
            return result2;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
            while (++index < length2) {
              var result2 = compareAscending(objCriteria[index], othCriteria[index]);
              if (result2) {
                if (index >= ordersLength) {
                  return result2;
                }
                var order2 = orders[index];
                return result2 * (order2 == "desc" ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result2[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result2[leftIndex++] = args[argsIndex++];
            }
            return result2;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result2[argsIndex] = args[argsIndex];
            }
            var offset2 = argsIndex;
            while (++rightIndex < rightLength) {
              result2[offset2 + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result2;
          }
          function copyArray(source, array) {
            var index = -1, length2 = source.length;
            array || (array = Array2(length2));
            while (++index < length2) {
              array[index] = source[index];
            }
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length2 = props.length;
            while (++index < length2) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
              if (newValue === undefined2) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee2) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined2, guard = length2 > 2 ? sources[2] : undefined2;
              customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined2;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length2 < 3 ? undefined2 : customizer;
                length2 = 1;
              }
              object = Object2(object);
              while (++index < length2) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee2) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee2);
              }
              var length2 = collection.length, index = fromRight ? length2 : -1, iterable = Object2(collection);
              while (fromRight ? index-- : ++index < length2) {
                if (iteratee2(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee2, keysFunc) {
              var index = -1, iterable = Object2(object), props = keysFunc(object), length2 = props.length;
              while (length2--) {
                var key = props[fromRight ? length2 : ++index];
                if (iteratee2(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper2() {
              var fn2 = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
              return fn2.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper2;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
              return isObject(result2) ? result2 : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper2() {
              var length2 = arguments.length, args = Array2(length2), index = length2, placeholder = getHolder(wrapper2);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length2 -= holders.length;
              if (length2 < arity) {
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper2.placeholder,
                  undefined2,
                  args,
                  holders,
                  undefined2,
                  undefined2,
                  arity - length2
                );
              }
              var fn2 = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
              return apply(fn2, this, args);
            }
            return wrapper2;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object2(collection);
              if (!isArrayLike(collection)) {
                var iteratee2 = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee2(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length2 = funcs.length, index = length2, prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper2 && getFuncName(func) == "wrapper") {
                  var wrapper2 = new LodashWrapper([], true);
                }
              }
              index = wrapper2 ? index : length2;
              while (++index < length2) {
                func = funcs[index];
                var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper2 = wrapper2[getFuncName(data[0])].apply(wrapper2, data[3]);
                } else {
                  wrapper2 = func.length == 1 && isLaziable(func) ? wrapper2[funcName]() : wrapper2.thru(func);
                }
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper2 && args.length == 1 && isArray(value)) {
                  return wrapper2.plant(value).value();
                }
                var index2 = 0, result2 = length2 ? funcs[index2].apply(this, args) : value;
                while (++index2 < length2) {
                  result2 = funcs[index2].call(this, result2);
                }
                return result2;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
            function wrapper2() {
              var length2 = arguments.length, args = Array2(length2), index = length2;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper2), holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length2 -= holdersCount;
              if (isCurried && length2 < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(
                  func,
                  bitmask,
                  createHybrid,
                  wrapper2.placeholder,
                  thisArg,
                  args,
                  newHolders,
                  argPos,
                  ary2,
                  arity - length2
                );
              }
              var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
              length2 = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length2 > 1) {
                args.reverse();
              }
              if (isAry && ary2 < length2) {
                args.length = ary2;
              }
              if (this && this !== root2 && this instanceof wrapper2) {
                fn2 = Ctor || createCtor(fn2);
              }
              return fn2.apply(thisBinding, args);
            }
            return wrapper2;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee2) {
              return baseInverter(object, setter, toIteratee(iteratee2), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result2;
              if (value === undefined2 && other === undefined2) {
                return defaultValue;
              }
              if (value !== undefined2) {
                result2 = value;
              }
              if (other !== undefined2) {
                if (result2 === undefined2) {
                  return other;
                }
                if (typeof value == "string" || typeof other == "string") {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result2 = operator(value, other);
              }
              return result2;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee2) {
                  return apply(iteratee2, thisArg, args);
                });
              });
            });
          }
          function createPadding(length2, chars) {
            chars = chars === undefined2 ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length2) : chars;
            }
            var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper2() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root2 && this instanceof wrapper2 ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn2, isBind ? thisArg : this, args);
            }
            return wrapper2;
          }
          function createRange(fromRight) {
            return function(start3, end2, step) {
              if (step && typeof step != "number" && isIterateeCall(start3, end2, step)) {
                end2 = step = undefined2;
              }
              start3 = toFinite(start3);
              if (end2 === undefined2) {
                end2 = start3;
                start3 = 0;
              } else {
                end2 = toFinite(end2);
              }
              step = step === undefined2 ? start3 < end2 ? 1 : -1 : toFinite(step);
              return baseRange(start3, end2, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!(typeof value == "string" && typeof other == "string")) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [
              func,
              bitmask,
              thisArg,
              newPartials,
              newHolders,
              newPartialsRight,
              newHoldersRight,
              argPos,
              ary2,
              arity
            ];
            var result2 = wrapFunc.apply(undefined2, newData);
            if (isLaziable(func)) {
              setData(result2, newData);
            }
            result2.placeholder = placeholder;
            return setWrapToString(result2, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math2[methodName];
            return function(number4, precision) {
              number4 = toNumber(number4);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number4)) {
                var pair = (toString(number4) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number4);
            };
          }
          var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop6 : function(values4) {
            return new Set2(values4);
          };
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var length2 = partials ? partials.length : 0;
            if (!length2) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined2;
            }
            ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
            arity = arity === undefined2 ? arity : toInteger(arity);
            length2 -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined2;
            }
            var data = isBindKey ? undefined2 : getData(func);
            var newData = [
              func,
              bitmask,
              thisArg,
              partials,
              holders,
              partialsRight,
              holdersRight,
              argPos,
              ary2,
              arity
            ];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result2 = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result2 = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result2 = createPartial(func, bitmask, thisArg, partials);
            } else {
              result2 = createHybrid.apply(undefined2, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result2, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject2(value) ? undefined2 : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined2) {
                if (compared) {
                  continue;
                }
                result2 = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue2, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result2 = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result2 = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result2;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                return object == other + "";
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;
                stack.set(object, other);
                var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack["delete"](object);
                return result2;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result2 = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result2 = false;
                break;
              }
              skipCtor || (skipCtor = key == "constructor");
            }
            if (result2 && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                result2 = false;
              }
            }
            stack["delete"](object);
            stack["delete"](other);
            return result2;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined2, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = !metaMap ? noop6 : function(func) {
            return metaMap.get(func);
          };
          function getFuncName(func) {
            var result2 = func.name + "", array = realNames[result2], length2 = hasOwnProperty.call(realNames, result2) ? array.length : 0;
            while (length2--) {
              var data = array[length2], otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result2;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result2 = lodash.iteratee || iteratee;
            result2 = result2 === iteratee ? baseIteratee : result2;
            return arguments.length ? result2(arguments[0], arguments[1]) : result2;
          }
          function getMapData(map3, key) {
            var data = map3.__data__;
            return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result2 = keys(object), length2 = result2.length;
            while (length2--) {
              var key = result2[length2], value = object[key];
              result2[length2] = [key, value, isStrictComparable(value)];
            }
            return result2;
          }
          function getNative(object, key) {
            var value = getValue2(object, key);
            return baseIsNative(value) ? value : undefined2;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined2;
              var unmasked = true;
            } catch (e) {
            }
            var result2 = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result2;
          }
          var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
            if (object == null) {
              return [];
            }
            object = Object2(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
            var result2 = [];
            while (object) {
              arrayPush(result2, getSymbols(object));
              object = getPrototype(object);
            }
            return result2;
          };
          var getTag = baseGetTag;
          if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
            getTag = function(value) {
              var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result2;
            };
          }
          function getView(start3, end2, transforms) {
            var index = -1, length2 = transforms.length;
            while (++index < length2) {
              var data = transforms[index], size2 = data.size;
              switch (data.type) {
                case "drop":
                  start3 += size2;
                  break;
                case "dropRight":
                  end2 -= size2;
                  break;
                case "take":
                  end2 = nativeMin(end2, start3 + size2);
                  break;
                case "takeRight":
                  start3 = nativeMax(start3, end2 - size2);
                  break;
              }
            }
            return { "start": start3, "end": end2 };
          }
          function getWrapDetails(source) {
            var match2 = source.match(reWrapDetails);
            return match2 ? match2[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length2 = path.length, result2 = false;
            while (++index < length2) {
              var key = toKey(path[index]);
              if (!(result2 = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result2 || ++index != length2) {
              return result2;
            }
            length2 = object == null ? 0 : object.length;
            return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length2 = array.length, result2 = new array.constructor(length2);
            if (length2 && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
              result2.index = array.index;
              result2.input = array.input;
            }
            return result2;
          }
          function initCloneObject(object) {
            return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length2 = details.length;
            if (!length2) {
              return source;
            }
            var lastIndex = length2 - 1;
            details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length2 > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length2) {
            var type = typeof value;
            length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
            return !!length2 && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
          }
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
              return eq(object[index], value);
            }
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
            };
          }
          function memoizeCapped(func) {
            var result2 = memoize3(func, function(key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result2.cache;
            return result2;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) {
              return data;
            }
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            if (value) {
              data[7] = value;
            }
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            if (data[9] == null) {
              data[9] = source[9];
            }
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result2 = [];
            if (object != null) {
              for (var key in Object2(object)) {
                result2.push(key);
              }
            }
            return result2;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start3, transform2) {
            start3 = nativeMax(start3 === undefined2 ? func.length - 1 : start3, 0);
            return function() {
              var args = arguments, index = -1, length2 = nativeMax(args.length - start3, 0), array = Array2(length2);
              while (++index < length2) {
                array[index] = args[start3 + index];
              }
              index = -1;
              var otherArgs = Array2(start3 + 1);
              while (++index < start3) {
                otherArgs[index] = args[index];
              }
              otherArgs[start3] = transform2(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length2--) {
              var index = indexes[length2];
              array[length2] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
            }
            return array;
          }
          function safeGet(object, key) {
            if (key === "constructor" && typeof object[key] === "function") {
              return;
            }
            if (key == "__proto__") {
              return;
            }
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout2 = ctxSetTimeout || function(func, wait) {
            return root2.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper2, reference2, bitmask) {
            var source = reference2 + "";
            return setToString(wrapper2, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined2, arguments);
            };
          }
          function shuffleSelf(array, size2) {
            var index = -1, length2 = array.length, lastIndex = length2 - 1;
            size2 = size2 === undefined2 ? length2 : size2;
            while (++index < size2) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size2;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result2 = [];
            if (string.charCodeAt(0) === 46) {
              result2.push("");
            }
            string.replace(rePropName, function(match2, number4, quote, subString) {
              result2.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match2);
            });
            return result2;
          });
          function toKey(value) {
            if (typeof value == "string" || isSymbol(value)) {
              return value;
            }
            var result2 = value + "";
            return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
          }
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {
              }
              try {
                return func + "";
              } catch (e) {
              }
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }
          function wrapperClone(wrapper2) {
            if (wrapper2 instanceof LazyWrapper) {
              return wrapper2.clone();
            }
            var result2 = new LodashWrapper(wrapper2.__wrapped__, wrapper2.__chain__);
            result2.__actions__ = copyArray(wrapper2.__actions__);
            result2.__index__ = wrapper2.__index__;
            result2.__values__ = wrapper2.__values__;
            return result2;
          }
          function chunk(array, size2, guard) {
            if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
              size2 = 1;
            } else {
              size2 = nativeMax(toInteger(size2), 0);
            }
            var length2 = array == null ? 0 : array.length;
            if (!length2 || size2 < 1) {
              return [];
            }
            var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
            while (index < length2) {
              result2[resIndex++] = baseSlice(array, index, index += size2);
            }
            return result2;
          }
          function compact(array) {
            var index = -1, length2 = array == null ? 0 : array.length, resIndex = 0, result2 = [];
            while (++index < length2) {
              var value = array[index];
              if (value) {
                result2[resIndex++] = value;
              }
            }
            return result2;
          }
          function concat() {
            var length2 = arguments.length;
            if (!length2) {
              return [];
            }
            var args = Array2(length2 - 1), array = arguments[0], index = length2;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values4) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values4, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values4) {
            var iteratee2 = last(values4);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values4, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values4) {
            var comparator = last(values4);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined2;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values4, 1, isArrayLikeObject, true), undefined2, comparator) : [];
          });
          function drop(array, n, guard) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length2);
          }
          function dropRight(array, n, guard) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length2 - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start3, end2) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            if (start3 && typeof start3 != "number" && isIterateeCall(array, value, start3)) {
              start3 = 0;
              end2 = length2;
            }
            return baseFill(array, value, start3, end2);
          }
          function findIndex2(array, predicate, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length2 + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index = length2 - 1;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length2 + index, 0) : nativeMin(index, length2 - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
            while (++index < length2) {
              var pair = pairs[index];
              result2[pair[0]] = pair[1];
            }
            return result2;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined2;
          }
          function indexOf(array, value, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length2 + index, 0);
            }
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee2 === last(mapped)) {
              iteratee2 = undefined2;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
          });
          function join(array, separator) {
            return array == null ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? array[length2 - 1] : undefined2;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return -1;
            }
            var index = length2;
            if (fromIndex !== undefined2) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length2 + index, 0) : nativeMin(index, length2 - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values4) {
            return array && array.length && values4 && values4.length ? basePullAll(array, values4) : array;
          }
          function pullAllBy(array, values4, iteratee2) {
            return array && array.length && values4 && values4.length ? basePullAll(array, values4, getIteratee(iteratee2, 2)) : array;
          }
          function pullAllWith(array, values4, comparator) {
            return array && array.length && values4 && values4.length ? basePullAll(array, values4, undefined2, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length2 = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length2) ? +index : index;
            }).sort(compareAscending));
            return result2;
          });
          function remove(array, predicate) {
            var result2 = [];
            if (!(array && array.length)) {
              return result2;
            }
            var index = -1, indexes = [], length2 = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length2) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result2.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result2;
          }
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }
          function slice3(array, start3, end2) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            if (end2 && typeof end2 != "number" && isIterateeCall(array, start3, end2)) {
              start3 = 0;
              end2 = length2;
            } else {
              start3 = start3 == null ? 0 : toInteger(start3);
              end2 = end2 === undefined2 ? length2 : toInteger(end2);
            }
            return baseSlice(array, start3, end2);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
          }
          function sortedIndexOf(array, value) {
            var length2 = array == null ? 0 : array.length;
            if (length2) {
              var index = baseSortedIndex(array, value);
              if (index < length2 && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee2) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length2 = array == null ? 0 : array.length;
            if (length2) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee2) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function tail(array) {
            var length2 = array == null ? 0 : array.length;
            return length2 ? baseSlice(array, 1, length2) : [];
          }
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function takeRight(array, n, guard) {
            var length2 = array == null ? 0 : array.length;
            if (!length2) {
              return [];
            }
            n = guard || n === undefined2 ? 1 : toInteger(n);
            n = length2 - n;
            return baseSlice(array, n < 0 ? 0 : n, length2);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee2) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return array && array.length ? baseUniq(array, undefined2, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length2 = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length2 = nativeMax(group.length, length2);
                return true;
              }
            });
            return baseTimes(length2, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee2) {
            if (!(array && array.length)) {
              return [];
            }
            var result2 = unzip(array);
            if (iteratee2 == null) {
              return result2;
            }
            return arrayMap(result2, function(group) {
              return apply(iteratee2, undefined2, group);
            });
          }
          var without = baseRest(function(array, values4) {
            return isArrayLikeObject(array) ? baseDifference(array, values4) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee2 = last(arrays);
            if (isArrayLikeObject(iteratee2)) {
              iteratee2 = undefined2;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == "function" ? comparator : undefined2;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values4) {
            return baseZipObject(props || [], values4 || [], assignValue);
          }
          function zipObjectDeep(props, values4) {
            return baseZipObject(props || [], values4 || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined2;
            iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
            return unzipWith(arrays, iteratee2);
          });
          function chain(value) {
            var result2 = lodash(value);
            result2.__chain__ = true;
            return result2;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length2 = paths.length, start3 = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start3)) {
              return this.thru(interceptor);
            }
            value = value.slice(start3, +start3 + (length2 ? 1 : 0));
            value.__actions__.push({
              "func": thru,
              "args": [interceptor],
              "thisArg": undefined2
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              if (length2 && !array.length) {
                array.push(undefined2);
              }
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            if (this.__values__ === undefined2) {
              this.__values__ = toArray2(this.value());
            }
            var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
            return { "done": done, "value": value };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result2, parent2 = this;
            while (parent2 instanceof baseLodash) {
              var clone2 = wrapperClone(parent2);
              clone2.__index__ = 0;
              clone2.__values__ = undefined2;
              if (result2) {
                previous.__wrapped__ = clone2;
              } else {
                result2 = clone2;
              }
              var previous = clone2;
              parent2 = parent2.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result2;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                "func": thru,
                "args": [reverse],
                "thisArg": undefined2
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              ++result2[key];
            } else {
              baseAssignValue(result2, key, 1);
            }
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex2);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee2) {
            return baseFlatten(map2(collection, iteratee2), 1);
          }
          function flatMapDeep(collection, iteratee2) {
            return baseFlatten(map2(collection, iteratee2), INFINITY);
          }
          function flatMapDepth(collection, iteratee2, depth) {
            depth = depth === undefined2 ? 1 : toInteger(depth);
            return baseFlatten(map2(collection, iteratee2), depth);
          }
          function forEach(collection, iteratee2) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function forEachRight(collection, iteratee2) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee2, 3));
          }
          var groupBy = createAggregator(function(result2, value, key) {
            if (hasOwnProperty.call(result2, key)) {
              result2[key].push(value);
            } else {
              baseAssignValue(result2, key, [value]);
            }
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values3(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length2 = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length2 + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
            baseEach(collection, function(value) {
              result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result2;
          });
          var keyBy = createAggregator(function(result2, value, key) {
            baseAssignValue(result2, key, value);
          });
          function map2(collection, iteratee2) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee2, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined2 : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result2, value, key) {
            result2[key ? 0 : 1].push(value);
          }, function() {
            return [[], []];
          });
          function reduce(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee2, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined2;
            }
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length2 = iteratees.length;
            if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root2.Date.now();
          };
          function after(n, func) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined2 : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
          }
          function before(n, func) {
            var result2;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function() {
              if (--n > 0) {
                result2 = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined2;
              }
              return result2;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curry.placeholder;
            return result2;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined2 : arity;
            var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
            result2.placeholder = curryRight.placeholder;
            return result2;
          }
          function debounce2(func, wait, options) {
            var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time2) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined2;
              lastInvokeTime = time2;
              result2 = func.apply(thisArg, args);
              return result2;
            }
            function leadingEdge(time2) {
              lastInvokeTime = time2;
              timerId = setTimeout2(timerExpired, wait);
              return leading ? invokeFunc(time2) : result2;
            }
            function remainingWait(time2) {
              var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time2) {
              var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
              return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time2 = now();
              if (shouldInvoke(time2)) {
                return trailingEdge(time2);
              }
              timerId = setTimeout2(timerExpired, remainingWait(time2));
            }
            function trailingEdge(time2) {
              timerId = undefined2;
              if (trailing && lastArgs) {
                return invokeFunc(time2);
              }
              lastArgs = lastThis = undefined2;
              return result2;
            }
            function cancel() {
              if (timerId !== undefined2) {
                clearTimeout2(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined2;
            }
            function flush2() {
              return timerId === undefined2 ? result2 : trailingEdge(now());
            }
            function debounced() {
              var time2 = now(), isInvoking = shouldInvoke(time2);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time2;
              if (isInvoking) {
                if (timerId === undefined2) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  clearTimeout2(timerId);
                  timerId = setTimeout2(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined2) {
                timerId = setTimeout2(timerExpired, wait);
              }
              return result2;
            }
            debounced.cancel = cancel;
            debounced.flush = flush2;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip2(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize3(func, resolver) {
            if (typeof func != "function" || resolver != null && typeof resolver != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result2 = func.apply(this, args);
              memoized.cache = cache.set(key, result2) || cache;
              return result2;
            };
            memoized.cache = new (memoize3.Cache || MapCache)();
            return memoized;
          }
          memoize3.Cache = MapCache;
          function negate(predicate) {
            if (typeof predicate != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return function() {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once2(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length2 = nativeMin(args.length, funcsLength);
              while (++index < length2) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
          });
          function rest(func, start3) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start3 = start3 === undefined2 ? start3 : toInteger(start3);
            return baseRest(func, start3);
          }
          function spread(func, start3) {
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            start3 = start3 == null ? 0 : nativeMax(toInteger(start3), 0);
            return baseRest(function(args) {
              var array = args[start3], otherArgs = castSlice(args, 0, start3);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce2(func, wait, {
              "leading": leading,
              "maxWait": wait,
              "trailing": trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper2) {
            return partial(castFunction(wrapper2), value);
          }
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(/* @__PURE__ */ function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array2.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement2(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
          }
          function isEmpty2(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }
          function isEqual2(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            var result2 = customizer ? customizer(value, other) : undefined2;
            return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
          }
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
          }
          function isFinite2(value) {
            return typeof value == "number" && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return typeof value == "number" && value == toInteger(value);
          }
          function isLength(value) {
            return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
          }
          function isObjectLike(value) {
            return value != null && typeof value == "object";
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN2(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error2(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }
          function isNull(value) {
            return value === null;
          }
          function isNil(value) {
            return value == null;
          }
          function isNumber(value) {
            return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject2(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined2;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray2(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values3;
            return func(value);
          }
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result2 = toFinite(value), remainder = result2 % 1;
            return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if (typeof value == "number") {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == "function" ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }
          function toString(value) {
            return value == null ? "" : baseToString(value);
          }
          var assign3 = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties2) {
            var result2 = baseCreate(prototype);
            return properties2 == null ? result2 : baseAssign(result2, properties2);
          }
          var defaults2 = baseRest(function(object, sources) {
            object = Object2(object);
            var index = -1;
            var length2 = sources.length;
            var guard = length2 > 2 ? sources[2] : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length2 = 1;
            }
            while (++index < length2) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined2, customDefaultsMerge);
            return apply(mergeWith, undefined2, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee2) {
            return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forInRight(object, iteratee2) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
          }
          function forOwn(object, iteratee2) {
            return object && baseForOwn(object, getIteratee(iteratee2, 3));
          }
          function forOwnRight(object, iteratee2) {
            return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
          }
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result2 = object == null ? undefined2 : baseGet(object, path);
            return result2 === undefined2 ? defaultValue : result2;
          }
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            result2[value] = key;
          }, constant(identity2));
          var invertBy = createInverter(function(result2, value, key) {
            if (value != null && typeof value.toString != "function") {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result2, value)) {
              result2[value].push(key);
            } else {
              result2[value] = [key];
            }
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, iteratee2(value, key, object2), value);
            });
            return result2;
          }
          function mapValues(object, iteratee2) {
            var result2 = {};
            iteratee2 = getIteratee(iteratee2, 3);
            baseForOwn(object, function(value, key, object2) {
              baseAssignValue(result2, key, iteratee2(value, key, object2));
            });
            return result2;
          }
          var merge2 = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result2 = {};
            if (object == null) {
              return result2;
            }
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result2);
            if (isDeep) {
              result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length2 = paths.length;
            while (length2--) {
              baseUnset(result2, paths[length2]);
            }
            return result2;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return object == null ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length2 = path.length;
            if (!length2) {
              length2 = 1;
              object = undefined2;
            }
            while (++index < length2) {
              var value = object == null ? undefined2 : object[toKey(path[index])];
              if (value === undefined2) {
                index = length2;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee2, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee2 = getIteratee(iteratee2, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
              return iteratee2(accumulator, value, index, object2);
            });
            return accumulator;
          }
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }
          function update3(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == "function" ? customizer : undefined2;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values3(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }
          function clamp3(number4, lower, upper) {
            if (upper === undefined2) {
              upper = lower;
              lower = undefined2;
            }
            if (upper !== undefined2) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined2) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number4), lower, upper);
          }
          function inRange(number4, start3, end2) {
            start3 = toFinite(start3);
            if (end2 === undefined2) {
              end2 = start3;
              start3 = 0;
            } else {
              end2 = toFinite(end2);
            }
            number4 = toNumber(number4);
            return baseInRange(number4, start3, end2);
          }
          function random(lower, upper, floating) {
            if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined2;
            }
            if (floating === undefined2) {
              if (typeof upper == "boolean") {
                floating = upper;
                upper = undefined2;
              } else if (typeof lower == "boolean") {
                floating = lower;
                lower = undefined2;
              }
            }
            if (lower === undefined2 && upper === undefined2) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined2) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result2, word, index) {
            word = word.toLowerCase();
            return result2 + (index ? capitalize2(word) : word);
          });
          function capitalize2(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position2) {
            string = toString(string);
            target = baseToString(target);
            var length2 = string.length;
            position2 = position2 === undefined2 ? length2 : baseClamp(toInteger(position2), 0, length2);
            var end2 = position2;
            position2 -= target.length;
            return position2 >= 0 && string.slice(position2, end2) == target;
          }
          function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad2(string, length2, chars) {
            string = toString(string);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string) : 0;
            if (!length2 || strLength >= length2) {
              return string;
            }
            var mid = (length2 - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length2, chars) {
            string = toString(string);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string) : 0;
            return length2 && strLength < length2 ? string + createPadding(length2 - strLength, chars) : string;
          }
          function padStart(string, length2, chars) {
            string = toString(string);
            length2 = toInteger(length2);
            var strLength = length2 ? stringSize(string) : 0;
            return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string : string;
          }
          function parseInt2(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString(string), n);
          }
          function replace2() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined2;
            }
            limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString(string);
            if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position2) {
            string = toString(string);
            position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string.length);
            target = baseToString(target);
            return string.slice(position2, position2 + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined2;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate2 = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp2(
              (options.escape || reNoMatch).source + "|" + interpolate2.source + "|" + (interpolate2 === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
              "g"
            );
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset2).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset2 + match2.length;
              return match2;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (!variable) {
              source = "with (obj) {\n" + source + "\n}\n";
            } else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
            }
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result2 = attempt(function() {
              return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
            });
            result2.source = source;
            if (isError(result2)) {
              throw result2;
            }
            return result2;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim2(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start3 = charsStartIndex(strSymbols, chrSymbols), end2 = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start3, end2).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), end2 = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end2).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined2)) {
              return string.replace(reTrimStart, "");
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string), start3 = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start3).join("");
          }
          function truncate(string, options) {
            var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length2 = "length" in options ? toInteger(options.length) : length2;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length2 >= strLength) {
              return string;
            }
            var end2 = length2 - stringSize(omission);
            if (end2 < 1) {
              return omission;
            }
            var result2 = strSymbols ? castSlice(strSymbols, 0, end2).join("") : string.slice(0, end2);
            if (separator === undefined2) {
              return result2 + omission;
            }
            if (strSymbols) {
              end2 += result2.length - end2;
            }
            if (isRegExp(separator)) {
              if (string.slice(end2).search(separator)) {
                var match2, substring = result2;
                if (!separator.global) {
                  separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
                }
                separator.lastIndex = 0;
                while (match2 = separator.exec(substring)) {
                  var newEnd = match2.index;
                }
                result2 = result2.slice(0, newEnd === undefined2 ? end2 : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end2) != end2) {
              var index = result2.lastIndexOf(separator);
              if (index > -1) {
                result2 = result2.slice(0, index);
              }
            }
            return result2 + omission;
          }
          function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result2, word, index) {
            return result2 + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined2 : pattern;
            if (pattern === undefined2) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined2, args);
            } catch (e) {
              return isError(e) ? e : new Error2(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = !length2 ? [] : arrayMap(pairs, function(pair) {
              if (typeof pair[1] != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function(args) {
              var index = -1;
              while (++index < length2) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity2(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function() {
                  var chainAll = this.__chain__;
                  if (chain2 || chainAll) {
                    var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                    actions.push({ "func": func, "args": arguments, "thisArg": object });
                    result2.__chain__ = chainAll;
                    return result2;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }
          function noConflict() {
            if (root2._ === this) {
              root2._ = oldDash;
            }
            return this;
          }
          function noop6() {
          }
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return object == null ? undefined2 : baseGet(object, path);
            };
          }
          var range2 = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee2) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH, length2 = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee2 = getIteratee(iteratee2);
            n -= MAX_ARRAY_LENGTH;
            var result2 = baseTimes(length2, iteratee2);
            while (++index < n) {
              iteratee2(index);
            }
            return result2;
          }
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }
          function uniqueId(prefix3) {
            var id = ++idCounter;
            return toString(prefix3) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max2(array) {
            return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined2;
          }
          function maxBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
          }
          function mean(array) {
            return baseMean(array, identity2);
          }
          function meanBy(array, iteratee2) {
            return baseMean(array, getIteratee(iteratee2, 2));
          }
          function min2(array) {
            return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined2;
          }
          function minBy(array, iteratee2) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round3 = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum2(array) {
            return array && array.length ? baseSum(array, identity2) : 0;
          }
          function sumBy(array, iteratee2) {
            return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign3;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce2;
          lodash.defaults = defaults2;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip2;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map2;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize3;
          lodash.merge = merge2;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once2;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range2;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice3;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray2;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update3;
          lodash.updateWith = updateWith;
          lodash.values = values3;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize2;
          lodash.ceil = ceil;
          lodash.clamp = clamp3;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex2;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity2;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement2;
          lodash.isEmpty = isEmpty2;
          lodash.isEqual = isEqual2;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite2;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN2;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject2;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max2;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min2;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop6;
          lodash.now = now;
          lodash.pad = pad2;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt2;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace2;
          lodash.result = result;
          lodash.round = round3;
          lodash.runInContext = runInContext2;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum2;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim2;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), { "chain": false });
          lodash.VERSION = VERSION;
          arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach(["drop", "take"], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
              var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result2.__filtered__) {
                result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
              } else {
                result2.__views__.push({
                  "size": nativeMin(n, MAX_ARRAY_LENGTH),
                  "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                });
              }
              return result2;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee2) {
              var result2 = this.clone();
              result2.__iteratees__.push({
                "iteratee": getIteratee(iteratee2, 3),
                "type": type
              });
              result2.__filtered__ = result2.__filtered__ || isFilter;
              return result2;
            };
          });
          arrayEach(["head", "last"], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach(["initial", "tail"], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity2);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if (typeof path == "function") {
              return new LazyWrapper(this);
            }
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start3, end2) {
            start3 = toInteger(start3);
            var result2 = this;
            if (result2.__filtered__ && (start3 > 0 || end2 < 0)) {
              return new LazyWrapper(result2);
            }
            if (start3 < 0) {
              result2 = result2.takeRight(-start3);
            } else if (start3) {
              result2 = result2.drop(start3);
            }
            if (end2 !== undefined2) {
              end2 = toInteger(end2);
              result2 = end2 < 0 ? result2.dropRight(-end2) : result2.take(end2 - start3);
            }
            return result2;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value2) {
                var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
                return isTaker && chainAll ? result3[0] : result3;
              };
              if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result2 = func.apply(value, args);
                result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
                return new LodashWrapper(result2, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result2 = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
            };
          });
          arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value2) {
                return func.apply(isArray(value2) ? value2 : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({ "name": methodName, "func": lodashFunc });
            }
          });
          realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
            "name": "wrapper",
            "func": undefined2
          }];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };
        var _2 = runInContext();
        if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
          root2._ = _2;
          define(function() {
            return _2;
          });
        } else if (freeModule) {
          (freeModule.exports = _2)._ = _2;
          freeExports._ = _2;
        } else {
          root2._ = _2;
        }
      }).call(exports);
    }
  });

  // src/Services/Frame/Root.ts
  var import_client = __toESM(require_client());
  var root = null;
  var container = null;
  var getOrCreateFrameRoot = () => {
    if (!container) {
      container = document.createElement("div");
      container.id = "ui-coverage-agent-root";
      container.style.position = "absolute";
      container.style.top = "0";
      container.style.left = "0";
      container.style.zIndex = "9999";
      container.style.pointerEvents = "none";
      document.body.appendChild(container);
    }
    if (!root && container) {
      root = (0, import_client.createRoot)(container);
    }
    return root;
  };
  var destroyFrameRoot = () => {
    if (root) {
      root.unmount();
      root = null;
    }
    if (container) {
      container.remove();
      container = null;
    }
  };
  var patchHistoryMethod = (method, callback) => {
    const original = history[method];
    history[method] = function(...args) {
      const result = original.apply(this, args);
      callback();
      return result;
    };
  };
  var watchFrameRoot = (getFrame) => {
    let currentUrl = location.href;
    const initFrame = () => {
      const root2 = getOrCreateFrameRoot();
      root2.render(getFrame());
    };
    const onUrlChange = () => {
      const newUrl = location.href;
      if (newUrl !== currentUrl) {
        currentUrl = newUrl;
        destroyFrameRoot();
        initFrame();
      }
    };
    patchHistoryMethod("pushState", onUrlChange);
    patchHistoryMethod("replaceState", onUrlChange);
    window.addEventListener("popstate", onUrlChange);
    const observer = new MutationObserver(onUrlChange);
    observer.observe(document.body, {
      childList: true,
      subtree: true,
      attributes: true,
      characterData: true
    });
    initFrame();
  };

  // src/Providers/AgentInitialStateProvider.tsx
  var import_react = __toESM(require_react());
  var import_jsx_runtime = __toESM(require_jsx_runtime());
  var AgentInitialStateContext = (0, import_react.createContext)(null);
  var AgentInitialStateProvider = ({ children }) => {
    const [state, setState] = (0, import_react.useState)({});
    const listener = (0, import_react.useCallback)((event) => {
      if (event == null ? void 0 : event.data) {
        setState(event.data);
      }
    }, []);
    (0, import_react.useEffect)(() => {
      window.addEventListener("message", listener);
      return () => {
        window.removeEventListener("message", listener);
      };
    }, [listener]);
    return /* @__PURE__ */ (0, import_jsx_runtime.jsx)(AgentInitialStateContext.Provider, { value: { state }, children });
  };
  var useAgentInitialState = () => {
    const event = (0, import_react.useContext)(AgentInitialStateContext);
    if (event == null) {
      throw new Error("useAgentInitialState() called outside of a AgentInitialStateProvider?");
    }
    return event;
  };

  // src/Views/Agent/Elements/ElementsView.tsx
  var import_react33 = __toESM(require_react());

  // src/Views/Agent/Elements/ElementView.tsx
  var import_react32 = __toESM(require_react());

  // src/Services/Frame/Element.ts
  var import_react2 = __toESM(require_react());

  // node_modules/@mui/material/colors/common.js
  var common = {
    black: "#000",
    white: "#fff"
  };
  var common_default = common;

  // node_modules/@mui/material/colors/red.js
  var red = {
    50: "#ffebee",
    100: "#ffcdd2",
    200: "#ef9a9a",
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    600: "#e53935",
    700: "#d32f2f",
    800: "#c62828",
    900: "#b71c1c",
    A100: "#ff8a80",
    A200: "#ff5252",
    A400: "#ff1744",
    A700: "#d50000"
  };
  var red_default = red;

  // node_modules/@mui/material/colors/purple.js
  var purple = {
    50: "#f3e5f5",
    100: "#e1bee7",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    600: "#8e24aa",
    700: "#7b1fa2",
    800: "#6a1b9a",
    900: "#4a148c",
    A100: "#ea80fc",
    A200: "#e040fb",
    A400: "#d500f9",
    A700: "#aa00ff"
  };
  var purple_default = purple;

  // node_modules/@mui/material/colors/blue.js
  var blue = {
    50: "#e3f2fd",
    100: "#bbdefb",
    200: "#90caf9",
    300: "#64b5f6",
    400: "#42a5f5",
    500: "#2196f3",
    600: "#1e88e5",
    700: "#1976d2",
    800: "#1565c0",
    900: "#0d47a1",
    A100: "#82b1ff",
    A200: "#448aff",
    A400: "#2979ff",
    A700: "#2962ff"
  };
  var blue_default = blue;

  // node_modules/@mui/material/colors/lightBlue.js
  var lightBlue = {
    50: "#e1f5fe",
    100: "#b3e5fc",
    200: "#81d4fa",
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    600: "#039be5",
    700: "#0288d1",
    800: "#0277bd",
    900: "#01579b",
    A100: "#80d8ff",
    A200: "#40c4ff",
    A400: "#00b0ff",
    A700: "#0091ea"
  };
  var lightBlue_default = lightBlue;

  // node_modules/@mui/material/colors/green.js
  var green = {
    50: "#e8f5e9",
    100: "#c8e6c9",
    200: "#a5d6a7",
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    600: "#43a047",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20",
    A100: "#b9f6ca",
    A200: "#69f0ae",
    A400: "#00e676",
    A700: "#00c853"
  };
  var green_default = green;

  // node_modules/@mui/material/colors/orange.js
  var orange = {
    50: "#fff3e0",
    100: "#ffe0b2",
    200: "#ffcc80",
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    600: "#fb8c00",
    700: "#f57c00",
    800: "#ef6c00",
    900: "#e65100",
    A100: "#ffd180",
    A200: "#ffab40",
    A400: "#ff9100",
    A700: "#ff6d00"
  };
  var orange_default = orange;

  // node_modules/@mui/material/colors/grey.js
  var grey = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
  };
  var grey_default = grey;

  // src/Services/Core.ts
  var hexToRGBA = (hex2, alpha2) => {
    const sanitized = hex2.replace("#", "");
    const bigint = parseInt(sanitized, 16);
    return `rgba(${bigint >> 16 & 255}, ${bigint >> 8 & 255}, ${bigint & 255}, ${alpha2})`;
  };

  // src/Services/Frame/Element.ts
  var getElementByXpath = (selector) => {
    return document.evaluate(selector, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
  };
  var getElement = ({ type, value }) => {
    let node2 = null;
    switch (type) {
      case "CSS" /* CSS */: {
        node2 = document.querySelector(value);
        break;
      }
      case "XPATH" /* XPath */: {
        const result = getElementByXpath(value);
        node2 = result.singleNodeValue instanceof Element ? result.singleNodeValue : null;
        break;
      }
      default:
        return null;
    }
    return node2 instanceof HTMLElement ? node2 : null;
  };
  var MAP_COLOR_TO_BORDER_COLOR = {
    ["info" /* Info */]: blue_default["300"],
    ["error" /* Error */]: red_default["700"],
    ["primary" /* Primary */]: blue_default["700"],
    ["success" /* Success */]: green_default["500"],
    ["warning" /* Warning */]: orange_default["300"],
    ["secondary" /* Secondary */]: purple_default["500"]
  };
  var useElement = (props) => {
    const { type, value, settings } = props;
    const node2 = getElement({ type, value });
    const highlightElement = (el) => {
      const color3 = MAP_COLOR_TO_BORDER_COLOR[(settings == null ? void 0 : settings.overlayColor) || "primary" /* Primary */];
      el.style.outline = `1px solid ${color3}`;
      el.style.backgroundColor = hexToRGBA(color3, 0.1);
    };
    const clearHighlight = (el) => {
      el.style.outline = "";
      el.style.backgroundColor = "";
    };
    (0, import_react2.useEffect)(() => {
      if (!node2) return;
      highlightElement(node2);
      return () => {
        clearHighlight(node2);
      };
    }, [node2, settings == null ? void 0 : settings.overlayColor]);
    return { node: node2 };
  };

  // node_modules/@mui/utils/esm/formatMuiErrorMessage/formatMuiErrorMessage.js
  function formatMuiErrorMessage(code, ...args) {
    const url = new URL(`https://mui.com/production-error/?code=${code}`);
    args.forEach((arg2) => url.searchParams.append("args[]", arg2));
    return `Minified MUI error #${code}; visit ${url} for the full message.`;
  }

  // node_modules/@mui/material/styles/identifier.js
  var identifier_default = "$$material";

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
      for (var e = 1; e < arguments.length; e++) {
        var t = arguments[e];
        for (var r2 in t) ({}).hasOwnProperty.call(t, r2) && (n[r2] = t[r2]);
      }
      return n;
    }, _extends.apply(null, arguments);
  }

  // node_modules/@emotion/react/dist/emotion-element-d59e098f.esm.js
  var React2 = __toESM(require_react());
  var import_react3 = __toESM(require_react());

  // node_modules/@emotion/sheet/dist/emotion-sheet.esm.js
  var isDevelopment = false;
  function sheetForTag(tag) {
    if (tag.sheet) {
      return tag.sheet;
    }
    for (var i = 0; i < document.styleSheets.length; i++) {
      if (document.styleSheets[i].ownerNode === tag) {
        return document.styleSheets[i];
      }
    }
    return void 0;
  }
  function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== void 0) {
      tag.setAttribute("nonce", options.nonce);
    }
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
  }
  var StyleSheet = /* @__PURE__ */ function() {
    function StyleSheet2(options) {
      var _this = this;
      this._insertTag = function(tag) {
        var before;
        if (_this.tags.length === 0) {
          if (_this.insertionPoint) {
            before = _this.insertionPoint.nextSibling;
          } else if (_this.prepend) {
            before = _this.container.firstChild;
          } else {
            before = _this.before;
          }
        } else {
          before = _this.tags[_this.tags.length - 1].nextSibling;
        }
        _this.container.insertBefore(tag, before);
        _this.tags.push(tag);
      };
      this.isSpeedy = options.speedy === void 0 ? !isDevelopment : options.speedy;
      this.tags = [];
      this.ctr = 0;
      this.nonce = options.nonce;
      this.key = options.key;
      this.container = options.container;
      this.prepend = options.prepend;
      this.insertionPoint = options.insertionPoint;
      this.before = null;
    }
    var _proto = StyleSheet2.prototype;
    _proto.hydrate = function hydrate(nodes) {
      nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
      if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
        this._insertTag(createStyleElement(this));
      }
      var tag = this.tags[this.tags.length - 1];
      if (this.isSpeedy) {
        var sheet = sheetForTag(tag);
        try {
          sheet.insertRule(rule, sheet.cssRules.length);
        } catch (e) {
        }
      } else {
        tag.appendChild(document.createTextNode(rule));
      }
      this.ctr++;
    };
    _proto.flush = function flush2() {
      this.tags.forEach(function(tag) {
        var _tag$parentNode;
        return (_tag$parentNode = tag.parentNode) == null ? void 0 : _tag$parentNode.removeChild(tag);
      });
      this.tags = [];
      this.ctr = 0;
    };
    return StyleSheet2;
  }();

  // node_modules/stylis/src/Enum.js
  var MS = "-ms-";
  var MOZ = "-moz-";
  var WEBKIT = "-webkit-";
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";

  // node_modules/stylis/src/Utility.js
  var abs = Math.abs;
  var from = String.fromCharCode;
  var assign = Object.assign;
  function hash(value, length2) {
    return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
  }
  function trim(value) {
    return value.trim();
  }
  function match(value, pattern) {
    return (value = pattern.exec(value)) ? value[0] : value;
  }
  function replace(value, pattern, replacement) {
    return value.replace(pattern, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index) {
    return value.charCodeAt(index) | 0;
  }
  function substr(value, begin, end2) {
    return value.slice(begin, end2);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array) {
    return array.push(value), value;
  }
  function combine(array, callback) {
    return array.map(callback).join("");
  }

  // node_modules/stylis/src/Tokenizer.js
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root2, parent, type, props, children, length2) {
    return { value, root: root2, parent, type, props, children, line, column, length: length2, return: "" };
  }
  function copy(root2, props) {
    return assign(node("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end2) {
    return substr(characters, begin, end2);
  }
  function token(type) {
    switch (type) {
      // \0 \t \n \r \s whitespace token
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      // ! + , / > @ ~ isolate token
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      // ; { } breakpoint token
      case 59:
      case 123:
      case 125:
        return 4;
      // : accompanied token
      case 58:
        return 3;
      // " ' ( [ opening delimit token
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      // ) ] closing delimit token
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type) {
    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
  }
  function whitespace(type) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type) {
    while (next())
      switch (character) {
        // ] ) " '
        case type:
          return position;
        // " '
        case 34:
        case 39:
          if (type !== 34 && type !== 39)
            delimiter(character);
          break;
        // (
        case 40:
          if (type === 41)
            delimiter(type);
          break;
        // \
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type, index) {
    while (next())
      if (type + character === 47 + 10)
        break;
      else if (type + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
  }
  function identifier(index) {
    while (!token(peek()))
      next();
    return slice(index, position);
  }

  // node_modules/stylis/src/Parser.js
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
    var index = 0;
    var offset2 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type = "";
    var props = rules;
    var children = rulesets;
    var reference2 = rule;
    var characters2 = type;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        // (
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        // " ' [
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        // \t \n \r \s
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace(previous);
          break;
        // \
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        // /
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root2, parent), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        // {
        case 123 * variable:
          points[index++] = strlen(characters2) * ampersand;
        // } ; \0
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            // \0 }
            case 0:
            case 125:
              scanning = 0;
            // ;
            case 59 + offset2:
              if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
              break;
            // @ ;
            case 59:
              characters2 += ";";
            // { rule/at-rule
            default:
              append(reference2 = ruleset(characters2, root2, parent, index, offset2, rules, points, type, props = [], children = [], length2), rulesets);
              if (character2 === 123)
                if (offset2 === 0)
                  parse(characters2, root2, reference2, reference2, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    // d l m s
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference2, reference2, rule && append(ruleset(value, reference2, reference2, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference2, reference2, reference2, [""], children, 0, points, children);
                  }
          }
          index = offset2 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
          break;
        // :
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            // &
            case 38:
              ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            // ,
            case 44:
              points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            // @
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
              break;
            // -
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root2, parent, index, offset2, rules, points, type, props, children, length2) {
    var post = offset2 - 1;
    var rule = offset2 === 0 ? rules : [""];
    var size = sizeof(rule);
    for (var i = 0, j = 0, k = 0; i < index; ++i)
      for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
        if (z = trim(j > 0 ? rule[x] + " " + y : replace(y, /&\f/g, rule[x])))
          props[k++] = z;
    return node(value, root2, parent, offset2 === 0 ? RULESET : type, props, children, length2);
  }
  function comment(value, root2, parent) {
    return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
  }
  function declaration(value, root2, parent, length2) {
    return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
  }

  // node_modules/stylis/src/Serializer.js
  function serialize(children, callback) {
    var output = "";
    var length2 = sizeof(children);
    for (var i = 0; i < length2; i++)
      output += callback(children[i], i, children, callback) || "";
    return output;
  }
  function stringify(element, index, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length) break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        element.value = element.props.join(",");
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }

  // node_modules/stylis/src/Middleware.js
  function middleware(collection) {
    var length2 = sizeof(collection);
    return function(element, index, children, callback) {
      var output = "";
      for (var i = 0; i < length2; i++)
        output += collection[i](element, index, children, callback) || "";
      return output;
    };
  }
  function rulesheet(callback) {
    return function(element) {
      if (!element.root) {
        if (element = element.return)
          callback(element);
      }
    };
  }

  // node_modules/@emotion/weak-memoize/dist/emotion-weak-memoize.esm.js
  var weakMemoize = function weakMemoize2(func) {
    var cache = /* @__PURE__ */ new WeakMap();
    return function(arg2) {
      if (cache.has(arg2)) {
        return cache.get(arg2);
      }
      var ret = func(arg2);
      cache.set(arg2, ret);
      return ret;
    };
  };

  // node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
  function memoize(fn2) {
    var cache = /* @__PURE__ */ Object.create(null);
    return function(arg2) {
      if (cache[arg2] === void 0) cache[arg2] = fn2(arg2);
      return cache[arg2];
    };
  }

  // node_modules/@emotion/cache/dist/emotion-cache.esm.js
  var isBrowser = typeof document !== "undefined";
  var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
    var previous = 0;
    var character2 = 0;
    while (true) {
      previous = character2;
      character2 = peek();
      if (previous === 38 && character2 === 12) {
        points[index] = 1;
      }
      if (token(character2)) {
        break;
      }
      next();
    }
    return slice(begin, position);
  };
  var toRules = function toRules2(parsed, points) {
    var index = -1;
    var character2 = 44;
    do {
      switch (token(character2)) {
        case 0:
          if (character2 === 38 && peek() === 12) {
            points[index] = 1;
          }
          parsed[index] += identifierWithPointTracking(position - 1, points, index);
          break;
        case 2:
          parsed[index] += delimit(character2);
          break;
        case 4:
          if (character2 === 44) {
            parsed[++index] = peek() === 58 ? "&\f" : "";
            points[index] = parsed[index].length;
            break;
          }
        // fallthrough
        default:
          parsed[index] += from(character2);
      }
    } while (character2 = next());
    return parsed;
  };
  var getRules = function getRules2(value, points) {
    return dealloc(toRules(alloc(value), points));
  };
  var fixedElements = /* @__PURE__ */ new WeakMap();
  var compat = function compat2(element) {
    if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    element.length < 1) {
      return;
    }
    var value = element.value;
    var parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while (parent.type !== "rule") {
      parent = parent.parent;
      if (!parent) return;
    }
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
      return;
    }
    if (isImplicitRule) {
      return;
    }
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for (var i = 0, k = 0; i < rules.length; i++) {
      for (var j = 0; j < parentRules.length; j++, k++) {
        element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
      }
    }
  };
  var removeLabel = function removeLabel2(element) {
    if (element.type === "decl") {
      var value = element.value;
      if (
        // charcode for l
        value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98
      ) {
        element["return"] = "";
        element.value = "";
      }
    }
  };
  function prefix(value, length2) {
    switch (hash(value, length2)) {
      // color-adjust
      case 5103:
        return WEBKIT + "print-" + value + value;
      // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
      case 5737:
      case 4201:
      case 3177:
      case 3433:
      case 1641:
      case 4457:
      case 2921:
      // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
      case 5572:
      case 6356:
      case 5844:
      case 3191:
      case 6645:
      case 3005:
      // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
      case 6391:
      case 5879:
      case 5623:
      case 6135:
      case 4599:
      case 4855:
      // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
      case 4215:
      case 6389:
      case 5109:
      case 5365:
      case 5621:
      case 3829:
        return WEBKIT + value + value;
      // appearance, user-select, transform, hyphens, text-size-adjust
      case 5349:
      case 4246:
      case 4810:
      case 6968:
      case 2756:
        return WEBKIT + value + MOZ + value + MS + value + value;
      // flex, flex-direction
      case 6828:
      case 4268:
        return WEBKIT + value + MS + value + value;
      // order
      case 6165:
        return WEBKIT + value + MS + "flex-" + value + value;
      // align-items
      case 5187:
        return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
      // align-self
      case 5443:
        return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
      // align-content
      case 4675:
        return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
      // flex-shrink
      case 5548:
        return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
      // flex-basis
      case 5292:
        return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
      // flex-grow
      case 6060:
        return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
      // transition
      case 4554:
        return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
      // cursor
      case 6187:
        return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
      // background, background-image
      case 5495:
      case 3959:
        return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
      // justify-content
      case 4968:
        return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
      // (margin|padding)-inline-(start|end)
      case 4095:
      case 3583:
      case 4068:
      case 2532:
        return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
      // (min|max)?(width|height|inline-size|block-size)
      case 8116:
      case 7059:
      case 5753:
      case 5535:
      case 5445:
      case 5701:
      case 4933:
      case 4677:
      case 5533:
      case 5789:
      case 5021:
      case 4765:
        if (strlen(value) - 1 - length2 > 6) switch (charat(value, length2 + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (charat(value, length2 + 4) !== 45) break;
          // (f)ill-available, (f)it-content
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          // (s)tretch
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
        break;
      // position: sticky
      case 4949:
        if (charat(value, length2 + 1) !== 115) break;
      // display: (flex|inline-flex)
      case 6444:
        switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
          // stic(k)y
          case 107:
            return replace(value, ":", ":" + WEBKIT) + value;
          // (inline-)?fl(e)x
          case 101:
            return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        }
        break;
      // writing-mode
      case 5936:
        switch (charat(value, length2 + 11)) {
          // vertical-l(r)
          case 114:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
          // vertical-r(l)
          case 108:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
          // horizontal(-)tb
          case 45:
            return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
        }
        return WEBKIT + value + MS + value + value;
    }
    return value;
  }
  var prefixer = function prefixer2(element, index, children, callback) {
    if (element.length > -1) {
      if (!element["return"]) switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length) return combine(element.props, function(value) {
            switch (match(value, /(::plac\w+|:read-\w+)/)) {
              // :read-(only|write)
              case ":read-only":
              case ":read-write":
                return serialize([copy(element, {
                  props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                })], callback);
              // :placeholder
              case "::placeholder":
                return serialize([copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                })], callback);
            }
            return "";
          });
      }
    }
  };
  var getServerStylisCache = isBrowser ? void 0 : weakMemoize(function() {
    return memoize(function() {
      return {};
    });
  });
  var defaultStylisPlugins = [prefixer];
  var createCache = function createCache2(options) {
    var key = options.key;
    if (isBrowser && key === "css") {
      var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
      Array.prototype.forEach.call(ssrStyles, function(node2) {
        var dataEmotionAttribute = node2.getAttribute("data-emotion");
        if (dataEmotionAttribute.indexOf(" ") === -1) {
          return;
        }
        document.head.appendChild(node2);
        node2.setAttribute("data-s", "");
      });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    var inserted = {};
    var container2;
    var nodesToHydrate = [];
    if (isBrowser) {
      container2 = options.container || document.head;
      Array.prototype.forEach.call(
        // this means we will ignore elements which don't have a space in them which
        // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
        document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
        function(node2) {
          var attrib = node2.getAttribute("data-emotion").split(" ");
          for (var i = 1; i < attrib.length; i++) {
            inserted[attrib[i]] = true;
          }
          nodesToHydrate.push(node2);
        }
      );
    }
    var _insert;
    var omnipresentPlugins = [compat, removeLabel];
    if (!getServerStylisCache) {
      var currentSheet;
      var finalizingPlugins = [stringify, rulesheet(function(rule) {
        currentSheet.insert(rule);
      })];
      var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
      var stylis = function stylis2(styles2) {
        return serialize(compile(styles2), serializer);
      };
      _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) {
          cache.inserted[serialized.name] = true;
        }
      };
    } else {
      var _finalizingPlugins = [stringify];
      var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));
      var _stylis = function _stylis2(styles2) {
        return serialize(compile(styles2), _serializer);
      };
      var serverStylisCache = getServerStylisCache(stylisPlugins)(key);
      var getRules3 = function getRules4(selector, serialized) {
        var name = serialized.name;
        if (serverStylisCache[name] === void 0) {
          serverStylisCache[name] = _stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        }
        return serverStylisCache[name];
      };
      _insert = function _insert2(selector, serialized, sheet, shouldCache) {
        var name = serialized.name;
        var rules = getRules3(selector, serialized);
        if (cache.compat === void 0) {
          if (shouldCache) {
            cache.inserted[name] = true;
          }
          return rules;
        } else {
          if (shouldCache) {
            cache.inserted[name] = rules;
          } else {
            return rules;
          }
        }
      };
    }
    var cache = {
      key,
      sheet: new StyleSheet({
        key,
        container: container2,
        nonce: options.nonce,
        speedy: options.speedy,
        prepend: options.prepend,
        insertionPoint: options.insertionPoint
      }),
      nonce: options.nonce,
      inserted,
      registered: {},
      insert: _insert
    };
    cache.sheet.hydrate(nodesToHydrate);
    return cache;
  };

  // node_modules/@emotion/utils/dist/emotion-utils.esm.js
  var isBrowser2 = typeof document !== "undefined";
  function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
      if (registered[className] !== void 0) {
        registeredStyles.push(registered[className] + ";");
      } else if (className) {
        rawClassName += className + " ";
      }
    });
    return rawClassName;
  }
  var registerStyles = function registerStyles2(cache, serialized, isStringTag2) {
    var className = cache.key + "-" + serialized.name;
    if (
      // we only need to add the styles to the registered cache if the
      // class name could be used further down
      // the tree but if it's a string tag, we know it won't
      // so we don't have to add it to registered cache.
      // this improves memory usage since we can avoid storing the whole style string
      (isStringTag2 === false || // we need to always store it if we're in compat mode and
      // in node since emotion-server relies on whether a style is in
      // the registered cache to know whether a style is global or not
      // also, note that this check will be dead code eliminated in the browser
      isBrowser2 === false && cache.compat !== void 0) && cache.registered[className] === void 0
    ) {
      cache.registered[className] = serialized.styles;
    }
  };
  var insertStyles = function insertStyles2(cache, serialized, isStringTag2) {
    registerStyles(cache, serialized, isStringTag2);
    var className = cache.key + "-" + serialized.name;
    if (cache.inserted[serialized.name] === void 0) {
      var stylesForSSR = "";
      var current = serialized;
      do {
        var maybeStyles = cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
        if (!isBrowser2 && maybeStyles !== void 0) {
          stylesForSSR += maybeStyles;
        }
        current = current.next;
      } while (current !== void 0);
      if (!isBrowser2 && stylesForSSR.length !== 0) {
        return stylesForSSR;
      }
    }
  };

  // node_modules/@emotion/hash/dist/emotion-hash.esm.js
  function murmur2(str) {
    var h = 0;
    var k, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
      k ^= /* k >>> r: */
      k >>> 24;
      h = /* Math.imul(k, m): */
      (k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h ^= str.charCodeAt(i) & 255;
        h = /* Math.imul(h, m): */
        (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    }
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */
    (h & 65535) * 1540483477 + ((h >>> 16) * 59797 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }

  // node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
  var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };

  // node_modules/@emotion/serialize/dist/emotion-serialize.esm.js
  var isDevelopment2 = false;
  var hyphenateRegex = /[A-Z]|^ms/g;
  var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
  var isCustomProperty = function isCustomProperty2(property) {
    return property.charCodeAt(1) === 45;
  };
  var isProcessableValue = function isProcessableValue2(value) {
    return value != null && typeof value !== "boolean";
  };
  var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
  });
  var processStyleValue = function processStyleValue2(key, value) {
    switch (key) {
      case "animation":
      case "animationName": {
        if (typeof value === "string") {
          return value.replace(animationRegex, function(match2, p1, p2) {
            cursor = {
              name: p1,
              styles: p2,
              next: cursor
            };
            return p1;
          });
        }
      }
    }
    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
      return value + "px";
    }
    return value;
  };
  var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
  function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) {
      return "";
    }
    var componentSelector = interpolation;
    if (componentSelector.__emotion_styles !== void 0) {
      return componentSelector;
    }
    switch (typeof interpolation) {
      case "boolean": {
        return "";
      }
      case "object": {
        var keyframes2 = interpolation;
        if (keyframes2.anim === 1) {
          cursor = {
            name: keyframes2.name,
            styles: keyframes2.styles,
            next: cursor
          };
          return keyframes2.name;
        }
        var serializedStyles = interpolation;
        if (serializedStyles.styles !== void 0) {
          var next2 = serializedStyles.next;
          if (next2 !== void 0) {
            while (next2 !== void 0) {
              cursor = {
                name: next2.name,
                styles: next2.styles,
                next: cursor
              };
              next2 = next2.next;
            }
          }
          var styles2 = serializedStyles.styles + ";";
          return styles2;
        }
        return createStringFromObject(mergedProps, registered, interpolation);
      }
      case "function": {
        if (mergedProps !== void 0) {
          var previousCursor = cursor;
          var result = interpolation(mergedProps);
          cursor = previousCursor;
          return handleInterpolation(mergedProps, registered, result);
        }
        break;
      }
    }
    var asString = interpolation;
    if (registered == null) {
      return asString;
    }
    var cached = registered[asString];
    return cached !== void 0 ? cached : asString;
  }
  function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
        string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
      }
    } else {
      for (var key in obj) {
        var value = obj[key];
        if (typeof value !== "object") {
          var asString = value;
          if (registered != null && registered[asString] !== void 0) {
            string += key + "{" + registered[asString] + "}";
          } else if (isProcessableValue(asString)) {
            string += processStyleName(key) + ":" + processStyleValue(key, asString) + ";";
          }
        } else {
          if (key === "NO_COMPONENT_SELECTOR" && isDevelopment2) {
            throw new Error(noComponentSelectorMessage);
          }
          if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
            for (var _i = 0; _i < value.length; _i++) {
              if (isProcessableValue(value[_i])) {
                string += processStyleName(key) + ":" + processStyleValue(key, value[_i]) + ";";
              }
            }
          } else {
            var interpolated = handleInterpolation(mergedProps, registered, value);
            switch (key) {
              case "animation":
              case "animationName": {
                string += processStyleName(key) + ":" + interpolated + ";";
                break;
              }
              default: {
                string += key + "{" + interpolated + "}";
              }
            }
          }
        }
      }
    }
    return string;
  }
  var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g;
  var cursor;
  function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
      return args[0];
    }
    var stringMode = true;
    var styles2 = "";
    cursor = void 0;
    var strings = args[0];
    if (strings == null || strings.raw === void 0) {
      stringMode = false;
      styles2 += handleInterpolation(mergedProps, registered, strings);
    } else {
      var asTemplateStringsArr = strings;
      styles2 += asTemplateStringsArr[0];
    }
    for (var i = 1; i < args.length; i++) {
      styles2 += handleInterpolation(mergedProps, registered, args[i]);
      if (stringMode) {
        var templateStringsArr = strings;
        styles2 += templateStringsArr[i];
      }
    }
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match2;
    while ((match2 = labelPattern.exec(styles2)) !== null) {
      identifierName += "-" + match2[1];
    }
    var name = murmur2(styles2) + identifierName;
    return {
      name,
      styles: styles2,
      next: cursor
    };
  }

  // node_modules/@emotion/use-insertion-effect-with-fallbacks/dist/emotion-use-insertion-effect-with-fallbacks.esm.js
  var React = __toESM(require_react());
  var isBrowser3 = typeof document !== "undefined";
  var syncFallback = function syncFallback2(create) {
    return create();
  };
  var useInsertionEffect2 = React["useInsertionEffect"] ? React["useInsertionEffect"] : false;
  var useInsertionEffectAlwaysWithSyncFallback = !isBrowser3 ? syncFallback : useInsertionEffect2 || syncFallback;
  var useInsertionEffectWithLayoutFallback = useInsertionEffect2 || React.useLayoutEffect;

  // node_modules/@emotion/react/dist/emotion-element-d59e098f.esm.js
  var isDevelopment3 = false;
  var isBrowser4 = typeof document !== "undefined";
  var EmotionCacheContext = /* @__PURE__ */ React2.createContext(
    // we're doing this to avoid preconstruct's dead code elimination in this one case
    // because this module is primarily intended for the browser and node
    // but it's also required in react native and similar environments sometimes
    // and we could have a special build just for that
    // but this is much easier and the native packages
    // might use a different theme context in the future anyway
    typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
      key: "css"
    }) : null
  );
  var CacheProvider = EmotionCacheContext.Provider;
  var withEmotionCache = function withEmotionCache2(func) {
    return /* @__PURE__ */ (0, import_react3.forwardRef)(function(props, ref) {
      var cache = (0, import_react3.useContext)(EmotionCacheContext);
      return func(props, cache, ref);
    });
  };
  if (!isBrowser4) {
    withEmotionCache = function withEmotionCache3(func) {
      return function(props) {
        var cache = (0, import_react3.useContext)(EmotionCacheContext);
        if (cache === null) {
          cache = createCache({
            key: "css"
          });
          return /* @__PURE__ */ React2.createElement(EmotionCacheContext.Provider, {
            value: cache
          }, func(props, cache));
        } else {
          return func(props, cache);
        }
      };
    };
  }
  var ThemeContext = /* @__PURE__ */ React2.createContext({});
  var hasOwn = {}.hasOwnProperty;
  var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
  var createEmotionProps = function createEmotionProps2(type, props) {
    var newProps = {};
    for (var _key in props) {
      if (hasOwn.call(props, _key)) {
        newProps[_key] = props[_key];
      }
    }
    newProps[typePropName] = type;
    return newProps;
  };
  var Insertion = function Insertion2(_ref) {
    var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
    registerStyles(cache, serialized, isStringTag2);
    var rules = useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache, serialized, isStringTag2);
    });
    if (!isBrowser4 && rules !== void 0) {
      var _ref2;
      var serializedNames = serialized.name;
      var next2 = serialized.next;
      while (next2 !== void 0) {
        serializedNames += " " + next2.name;
        next2 = next2.next;
      }
      return /* @__PURE__ */ React2.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
        __html: rules
      }, _ref2.nonce = cache.sheet.nonce, _ref2));
    }
    return null;
  };
  var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
    var cssProp = props.css;
    if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
      cssProp = cache.registered[cssProp];
    }
    var WrappedComponent = props[typePropName];
    var registeredStyles = [cssProp];
    var className = "";
    if (typeof props.className === "string") {
      className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
    } else if (props.className != null) {
      className = props.className + " ";
    }
    var serialized = serializeStyles(registeredStyles, void 0, React2.useContext(ThemeContext));
    className += cache.key + "-" + serialized.name;
    var newProps = {};
    for (var _key2 in props) {
      if (hasOwn.call(props, _key2) && _key2 !== "css" && _key2 !== typePropName && !isDevelopment3) {
        newProps[_key2] = props[_key2];
      }
    }
    newProps.className = className;
    if (ref) {
      newProps.ref = ref;
    }
    return /* @__PURE__ */ React2.createElement(React2.Fragment, null, /* @__PURE__ */ React2.createElement(Insertion, {
      cache,
      serialized,
      isStringTag: typeof WrappedComponent === "string"
    }), /* @__PURE__ */ React2.createElement(WrappedComponent, newProps));
  });
  var Emotion$1 = Emotion;

  // node_modules/@emotion/react/dist/emotion-react.esm.js
  var React3 = __toESM(require_react());
  var import_extends2 = __toESM(require_extends());
  var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
  var jsx2 = function jsx3(type, props) {
    var args = arguments;
    if (props == null || !hasOwn.call(props, "css")) {
      return React3.createElement.apply(void 0, args);
    }
    var argsLength = args.length;
    var createElementArgArray = new Array(argsLength);
    createElementArgArray[0] = Emotion$1;
    createElementArgArray[1] = createEmotionProps(type, props);
    for (var i = 2; i < argsLength; i++) {
      createElementArgArray[i] = args[i];
    }
    return React3.createElement.apply(null, createElementArgArray);
  };
  (function(_jsx88) {
    var JSX;
    /* @__PURE__ */ (function(_JSX) {
    })(JSX || (JSX = _jsx88.JSX || (_jsx88.JSX = {})));
  })(jsx2 || (jsx2 = {}));
  var Global = /* @__PURE__ */ withEmotionCache(function(props, cache) {
    var styles2 = props.styles;
    var serialized = serializeStyles([styles2], void 0, React3.useContext(ThemeContext));
    if (!isBrowser4) {
      var _ref;
      var serializedNames = serialized.name;
      var serializedStyles = serialized.styles;
      var next2 = serialized.next;
      while (next2 !== void 0) {
        serializedNames += " " + next2.name;
        serializedStyles += next2.styles;
        next2 = next2.next;
      }
      var shouldCache = cache.compat === true;
      var rules = cache.insert("", {
        name: serializedNames,
        styles: serializedStyles
      }, cache.sheet, shouldCache);
      if (shouldCache) {
        return null;
      }
      return /* @__PURE__ */ React3.createElement("style", (_ref = {}, _ref["data-emotion"] = cache.key + "-global " + serializedNames, _ref.dangerouslySetInnerHTML = {
        __html: rules
      }, _ref.nonce = cache.sheet.nonce, _ref));
    }
    var sheetRef = React3.useRef();
    useInsertionEffectWithLayoutFallback(function() {
      var key = cache.key + "-global";
      var sheet = new cache.sheet.constructor({
        key,
        nonce: cache.sheet.nonce,
        container: cache.sheet.container,
        speedy: cache.sheet.isSpeedy
      });
      var rehydrating = false;
      var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
      if (cache.sheet.tags.length) {
        sheet.before = cache.sheet.tags[0];
      }
      if (node2 !== null) {
        rehydrating = true;
        node2.setAttribute("data-emotion", key);
        sheet.hydrate([node2]);
      }
      sheetRef.current = [sheet, rehydrating];
      return function() {
        sheet.flush();
      };
    }, [cache]);
    useInsertionEffectWithLayoutFallback(function() {
      var sheetRefCurrent = sheetRef.current;
      var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
      if (rehydrating) {
        sheetRefCurrent[1] = false;
        return;
      }
      if (serialized.next !== void 0) {
        insertStyles(cache, serialized.next, true);
      }
      if (sheet.tags.length) {
        var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
        sheet.before = element;
        sheet.flush();
      }
      cache.insert("", serialized, sheet, false);
    }, [cache, serialized.name]);
    return null;
  });
  function css() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return serializeStyles(args);
  }
  function keyframes() {
    var insertable = css.apply(void 0, arguments);
    var name = "animation-" + insertable.name;
    return {
      name,
      styles: "@keyframes " + name + "{" + insertable.styles + "}",
      anim: 1,
      toString: function toString() {
        return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
      }
    };
  }

  // node_modules/@emotion/styled/base/dist/emotion-styled-base.esm.js
  var React4 = __toESM(require_react());

  // node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
  var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
  var isPropValid = /* @__PURE__ */ memoize(
    function(prop) {
      return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
    }
    /* Z+1 */
  );

  // node_modules/@emotion/styled/base/dist/emotion-styled-base.esm.js
  var isBrowser5 = typeof document !== "undefined";
  var isDevelopment4 = false;
  var testOmitPropsOnStringTag = isPropValid;
  var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
    return key !== "theme";
  };
  var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
  };
  var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
    var shouldForwardProp2;
    if (options) {
      var optionsShouldForwardProp = options.shouldForwardProp;
      shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
        return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
      } : optionsShouldForwardProp;
    }
    if (typeof shouldForwardProp2 !== "function" && isReal) {
      shouldForwardProp2 = tag.__emotion_forwardProp;
    }
    return shouldForwardProp2;
  };
  var Insertion3 = function Insertion4(_ref) {
    var cache = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
    registerStyles(cache, serialized, isStringTag2);
    var rules = useInsertionEffectAlwaysWithSyncFallback(function() {
      return insertStyles(cache, serialized, isStringTag2);
    });
    if (!isBrowser5 && rules !== void 0) {
      var _ref2;
      var serializedNames = serialized.name;
      var next2 = serialized.next;
      while (next2 !== void 0) {
        serializedNames += " " + next2.name;
        next2 = next2.next;
      }
      return /* @__PURE__ */ React4.createElement("style", (_ref2 = {}, _ref2["data-emotion"] = cache.key + " " + serializedNames, _ref2.dangerouslySetInnerHTML = {
        __html: rules
      }, _ref2.nonce = cache.sheet.nonce, _ref2));
    }
    return null;
  };
  var createStyled = function createStyled2(tag, options) {
    var isReal = tag.__emotion_real === tag;
    var baseTag = isReal && tag.__emotion_base || tag;
    var identifierName;
    var targetClassName;
    if (options !== void 0) {
      identifierName = options.label;
      targetClassName = options.target;
    }
    var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
    var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
    var shouldUseAs = !defaultShouldForwardProp("as");
    return function() {
      var args = arguments;
      var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
      if (identifierName !== void 0) {
        styles2.push("label:" + identifierName + ";");
      }
      if (args[0] == null || args[0].raw === void 0) {
        styles2.push.apply(styles2, args);
      } else {
        var templateStringsArr = args[0];
        styles2.push(templateStringsArr[0]);
        var len = args.length;
        var i = 1;
        for (; i < len; i++) {
          styles2.push(args[i], templateStringsArr[i]);
        }
      }
      var Styled = withEmotionCache(function(props, cache, ref) {
        var FinalTag = shouldUseAs && props.as || baseTag;
        var className = "";
        var classInterpolations = [];
        var mergedProps = props;
        if (props.theme == null) {
          mergedProps = {};
          for (var key in props) {
            mergedProps[key] = props[key];
          }
          mergedProps.theme = React4.useContext(ThemeContext);
        }
        if (typeof props.className === "string") {
          className = getRegisteredStyles(cache.registered, classInterpolations, props.className);
        } else if (props.className != null) {
          className = props.className + " ";
        }
        var serialized = serializeStyles(styles2.concat(classInterpolations), cache.registered, mergedProps);
        className += cache.key + "-" + serialized.name;
        if (targetClassName !== void 0) {
          className += " " + targetClassName;
        }
        var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
        var newProps = {};
        for (var _key in props) {
          if (shouldUseAs && _key === "as") continue;
          if (finalShouldForwardProp(_key)) {
            newProps[_key] = props[_key];
          }
        }
        newProps.className = className;
        if (ref) {
          newProps.ref = ref;
        }
        return /* @__PURE__ */ React4.createElement(React4.Fragment, null, /* @__PURE__ */ React4.createElement(Insertion3, {
          cache,
          serialized,
          isStringTag: typeof FinalTag === "string"
        }), /* @__PURE__ */ React4.createElement(FinalTag, newProps));
      });
      Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
      Styled.defaultProps = tag.defaultProps;
      Styled.__emotion_real = Styled;
      Styled.__emotion_base = baseTag;
      Styled.__emotion_styles = styles2;
      Styled.__emotion_forwardProp = shouldForwardProp2;
      Object.defineProperty(Styled, "toString", {
        value: function value() {
          if (targetClassName === void 0 && isDevelopment4) {
            return "NO_COMPONENT_SELECTOR";
          }
          return "." + targetClassName;
        }
      });
      Styled.withComponent = function(nextTag, nextOptions) {
        var newStyled2 = createStyled2(nextTag, _extends({}, options, nextOptions, {
          shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
        }));
        return newStyled2.apply(void 0, styles2);
      };
      return Styled;
    };
  };

  // node_modules/@emotion/styled/dist/emotion-styled.esm.js
  var import_extends4 = __toESM(require_extends());
  var import_react5 = __toESM(require_react());
  var tags = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "marquee",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ];
  var newStyled = createStyled.bind(null);
  tags.forEach(function(tagName) {
    newStyled[tagName] = newStyled(tagName);
  });

  // node_modules/@mui/styled-engine/GlobalStyles/GlobalStyles.js
  var React5 = __toESM(require_react());
  var import_jsx_runtime2 = __toESM(require_jsx_runtime());
  function isEmpty(obj) {
    return obj === void 0 || obj === null || Object.keys(obj).length === 0;
  }
  function GlobalStyles(props) {
    const {
      styles: styles2,
      defaultTheme: defaultTheme5 = {}
    } = props;
    const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty(themeInput) ? defaultTheme5 : themeInput) : styles2;
    return /* @__PURE__ */ (0, import_jsx_runtime2.jsx)(Global, {
      styles: globalStyles
    });
  }
  false ? GlobalStyles.propTypes = {
    defaultTheme: import_prop_types.default.object,
    styles: import_prop_types.default.oneOfType([import_prop_types.default.array, import_prop_types.default.string, import_prop_types.default.object, import_prop_types.default.func])
  } : void 0;

  // node_modules/@mui/styled-engine/index.js
  function styled(tag, options) {
    const stylesFactory = newStyled(tag, options);
    if (false) {
      return (...styles2) => {
        const component = typeof tag === "string" ? `"${tag}"` : "component";
        if (styles2.length === 0) {
          console.error([`MUI: Seems like you called \`styled(${component})()\` without a \`style\` argument.`, 'You must provide a `styles` argument: `styled("div")(styleYouForgotToPass)`.'].join("\n"));
        } else if (styles2.some((style4) => style4 === void 0)) {
          console.error(`MUI: the styled(${component})(...args) API requires all its args to be defined.`);
        }
        return stylesFactory(...styles2);
      };
    }
    return stylesFactory;
  }
  function internal_mutateStyles(tag, processor) {
    if (Array.isArray(tag.__emotion_styles)) {
      tag.__emotion_styles = processor(tag.__emotion_styles);
    }
  }
  var wrapper = [];
  function internal_serializeStyles(styles2) {
    wrapper[0] = styles2;
    return serializeStyles(wrapper);
  }

  // node_modules/@mui/utils/esm/deepmerge/deepmerge.js
  var React6 = __toESM(require_react());
  var import_react_is = __toESM(require_react_is2());
  function isPlainObject(item) {
    if (typeof item !== "object" || item === null) {
      return false;
    }
    const prototype = Object.getPrototypeOf(item);
    return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in item) && !(Symbol.iterator in item);
  }
  function deepClone(source) {
    if (/* @__PURE__ */ React6.isValidElement(source) || (0, import_react_is.isValidElementType)(source) || !isPlainObject(source)) {
      return source;
    }
    const output = {};
    Object.keys(source).forEach((key) => {
      output[key] = deepClone(source[key]);
    });
    return output;
  }
  function deepmerge(target, source, options = {
    clone: true
  }) {
    const output = options.clone ? __spreadValues({}, target) : target;
    if (isPlainObject(target) && isPlainObject(source)) {
      Object.keys(source).forEach((key) => {
        if (/* @__PURE__ */ React6.isValidElement(source[key]) || (0, import_react_is.isValidElementType)(source[key])) {
          output[key] = source[key];
        } else if (isPlainObject(source[key]) && // Avoid prototype pollution
        Object.prototype.hasOwnProperty.call(target, key) && isPlainObject(target[key])) {
          output[key] = deepmerge(target[key], source[key], options);
        } else if (options.clone) {
          output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
        } else {
          output[key] = source[key];
        }
      });
    }
    return output;
  }

  // node_modules/@mui/system/esm/createBreakpoints/createBreakpoints.js
  var sortBreakpointsValues = (values3) => {
    const breakpointsAsArray = Object.keys(values3).map((key) => ({
      key,
      val: values3[key]
    })) || [];
    breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
    return breakpointsAsArray.reduce((acc, obj) => {
      return __spreadProps(__spreadValues({}, acc), {
        [obj.key]: obj.val
      });
    }, {});
  };
  function createBreakpoints(breakpoints) {
    const _a = breakpoints, {
      values: values3 = {
        xs: 0,
        // phone
        sm: 600,
        // tablet
        md: 900,
        // small laptop
        lg: 1200,
        // desktop
        xl: 1536
        // large screen
      },
      unit: unit2 = "px",
      step = 5
    } = _a, other = __objRest(_a, [
      // The breakpoint **start** at this value.
      // For instance with the first breakpoint xs: [xs, sm).
      "values",
      "unit",
      "step"
    ]);
    const sortedValues = sortBreakpointsValues(values3);
    const keys = Object.keys(sortedValues);
    function up(key) {
      const value = typeof values3[key] === "number" ? values3[key] : key;
      return `@media (min-width:${value}${unit2})`;
    }
    function down(key) {
      const value = typeof values3[key] === "number" ? values3[key] : key;
      return `@media (max-width:${value - step / 100}${unit2})`;
    }
    function between(start3, end2) {
      const endIndex = keys.indexOf(end2);
      return `@media (min-width:${typeof values3[start3] === "number" ? values3[start3] : start3}${unit2}) and (max-width:${(endIndex !== -1 && typeof values3[keys[endIndex]] === "number" ? values3[keys[endIndex]] : end2) - step / 100}${unit2})`;
    }
    function only(key) {
      if (keys.indexOf(key) + 1 < keys.length) {
        return between(key, keys[keys.indexOf(key) + 1]);
      }
      return up(key);
    }
    function not(key) {
      const keyIndex = keys.indexOf(key);
      if (keyIndex === 0) {
        return up(keys[1]);
      }
      if (keyIndex === keys.length - 1) {
        return down(keys[keyIndex]);
      }
      return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
    }
    return __spreadValues({
      keys,
      values: sortedValues,
      up,
      down,
      between,
      only,
      not,
      unit: unit2
    }, other);
  }

  // node_modules/@mui/system/esm/cssContainerQueries/cssContainerQueries.js
  function sortContainerQueries(theme, css2) {
    if (!theme.containerQueries) {
      return css2;
    }
    const sorted = Object.keys(css2).filter((key) => key.startsWith("@container")).sort((a, b) => {
      var _a, _b;
      const regex = /min-width:\s*([0-9.]+)/;
      return +(((_a = a.match(regex)) == null ? void 0 : _a[1]) || 0) - +(((_b = b.match(regex)) == null ? void 0 : _b[1]) || 0);
    });
    if (!sorted.length) {
      return css2;
    }
    return sorted.reduce((acc, key) => {
      const value = css2[key];
      delete acc[key];
      acc[key] = value;
      return acc;
    }, __spreadValues({}, css2));
  }
  function isCqShorthand(breakpointKeys, value) {
    return value === "@" || value.startsWith("@") && (breakpointKeys.some((key) => value.startsWith(`@${key}`)) || !!value.match(/^@\d/));
  }
  function getContainerQuery(theme, shorthand) {
    const matches = shorthand.match(/^@([^/]+)?\/?(.+)?$/);
    if (!matches) {
      if (false) {
        throw new Error(false ? `MUI: The provided shorthand ${`(${shorthand})`} is invalid. The format should be \`@<breakpoint | number>\` or \`@<breakpoint | number>/<container>\`.
For example, \`@sm\` or \`@600\` or \`@40rem/sidebar\`.` : formatMuiErrorMessage(18, `(${shorthand})`));
      }
      return null;
    }
    const [, containerQuery, containerName] = matches;
    const value = Number.isNaN(+containerQuery) ? containerQuery || 0 : +containerQuery;
    return theme.containerQueries(containerName).up(value);
  }
  function cssContainerQueries(themeInput) {
    const toContainerQuery = (mediaQuery, name) => mediaQuery.replace("@media", name ? `@container ${name}` : "@container");
    function attachCq(node3, name) {
      node3.up = (...args) => toContainerQuery(themeInput.breakpoints.up(...args), name);
      node3.down = (...args) => toContainerQuery(themeInput.breakpoints.down(...args), name);
      node3.between = (...args) => toContainerQuery(themeInput.breakpoints.between(...args), name);
      node3.only = (...args) => toContainerQuery(themeInput.breakpoints.only(...args), name);
      node3.not = (...args) => {
        const result = toContainerQuery(themeInput.breakpoints.not(...args), name);
        if (result.includes("not all and")) {
          return result.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or");
        }
        return result;
      };
    }
    const node2 = {};
    const containerQueries = (name) => {
      attachCq(node2, name);
      return node2;
    };
    attachCq(containerQueries);
    return __spreadProps(__spreadValues({}, themeInput), {
      containerQueries
    });
  }

  // node_modules/@mui/system/esm/createTheme/shape.js
  var shape = {
    borderRadius: 4
  };
  var shape_default = shape;

  // node_modules/@mui/system/esm/merge/merge.js
  function merge(acc, item) {
    if (!item) {
      return acc;
    }
    return deepmerge(acc, item, {
      clone: false
      // No need to clone deep, it's way faster.
    });
  }
  var merge_default = merge;

  // node_modules/@mui/system/esm/breakpoints/breakpoints.js
  var values = {
    xs: 0,
    // phone
    sm: 600,
    // tablet
    md: 900,
    // small laptop
    lg: 1200,
    // desktop
    xl: 1536
    // large screen
  };
  var defaultBreakpoints = {
    // Sorted ASC by size. That's important.
    // It can't be configured as it's used statically for propTypes.
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: (key) => `@media (min-width:${values[key]}px)`
  };
  var defaultContainerQueries = {
    containerQueries: (containerName) => ({
      up: (key) => {
        let result = typeof key === "number" ? key : values[key] || key;
        if (typeof result === "number") {
          result = `${result}px`;
        }
        return containerName ? `@container ${containerName} (min-width:${result})` : `@container (min-width:${result})`;
      }
    })
  };
  function handleBreakpoints(props, propValue, styleFromPropValue) {
    const theme = props.theme || {};
    if (Array.isArray(propValue)) {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return propValue.reduce((acc, item, index) => {
        acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
        return acc;
      }, {});
    }
    if (typeof propValue === "object") {
      const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
      return Object.keys(propValue).reduce((acc, breakpoint) => {
        if (isCqShorthand(themeBreakpoints.keys, breakpoint)) {
          const containerKey = getContainerQuery(theme.containerQueries ? theme : defaultContainerQueries, breakpoint);
          if (containerKey) {
            acc[containerKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
          }
        } else if (Object.keys(themeBreakpoints.values || values).includes(breakpoint)) {
          const mediaKey = themeBreakpoints.up(breakpoint);
          acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
        } else {
          const cssKey = breakpoint;
          acc[cssKey] = propValue[cssKey];
        }
        return acc;
      }, {});
    }
    const output = styleFromPropValue(propValue);
    return output;
  }
  function createEmptyBreakpointObject(breakpointsInput = {}) {
    var _a;
    const breakpointsInOrder = (_a = breakpointsInput.keys) == null ? void 0 : _a.reduce((acc, key) => {
      const breakpointStyleKey = breakpointsInput.up(key);
      acc[breakpointStyleKey] = {};
      return acc;
    }, {});
    return breakpointsInOrder || {};
  }
  function removeUnusedBreakpoints(breakpointKeys, style4) {
    return breakpointKeys.reduce((acc, key) => {
      const breakpointOutput = acc[key];
      const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
      if (isBreakpointUnused) {
        delete acc[key];
      }
      return acc;
    }, style4);
  }
  function mergeBreakpointsInOrder(breakpointsInput, ...styles2) {
    const emptyBreakpoints = createEmptyBreakpointObject(breakpointsInput);
    const mergedOutput = [emptyBreakpoints, ...styles2].reduce((prev2, next2) => deepmerge(prev2, next2), {});
    return removeUnusedBreakpoints(Object.keys(emptyBreakpoints), mergedOutput);
  }
  function computeBreakpointsBase(breakpointValues, themeBreakpoints) {
    if (typeof breakpointValues !== "object") {
      return {};
    }
    const base = {};
    const breakpointsKeys = Object.keys(themeBreakpoints);
    if (Array.isArray(breakpointValues)) {
      breakpointsKeys.forEach((breakpoint, i) => {
        if (i < breakpointValues.length) {
          base[breakpoint] = true;
        }
      });
    } else {
      breakpointsKeys.forEach((breakpoint) => {
        if (breakpointValues[breakpoint] != null) {
          base[breakpoint] = true;
        }
      });
    }
    return base;
  }
  function resolveBreakpointValues({
    values: breakpointValues,
    breakpoints: themeBreakpoints,
    base: customBase
  }) {
    const base = customBase || computeBreakpointsBase(breakpointValues, themeBreakpoints);
    const keys = Object.keys(base);
    if (keys.length === 0) {
      return breakpointValues;
    }
    let previous;
    return keys.reduce((acc, breakpoint, i) => {
      if (Array.isArray(breakpointValues)) {
        acc[breakpoint] = breakpointValues[i] != null ? breakpointValues[i] : breakpointValues[previous];
        previous = i;
      } else if (typeof breakpointValues === "object") {
        acc[breakpoint] = breakpointValues[breakpoint] != null ? breakpointValues[breakpoint] : breakpointValues[previous];
        previous = breakpoint;
      } else {
        acc[breakpoint] = breakpointValues;
      }
      return acc;
    }, {});
  }

  // node_modules/@mui/utils/esm/capitalize/capitalize.js
  function capitalize(string) {
    if (typeof string !== "string") {
      throw new Error(false ? "MUI: `capitalize(string)` expects a string argument." : formatMuiErrorMessage(7));
    }
    return string.charAt(0).toUpperCase() + string.slice(1);
  }

  // node_modules/@mui/system/esm/style/style.js
  function getPath(obj, path, checkVars = true) {
    if (!path || typeof path !== "string") {
      return null;
    }
    if (obj && obj.vars && checkVars) {
      const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
      if (val != null) {
        return val;
      }
    }
    return path.split(".").reduce((acc, item) => {
      if (acc && acc[item] != null) {
        return acc[item];
      }
      return null;
    }, obj);
  }
  function getStyleValue(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
    let value;
    if (typeof themeMapping === "function") {
      value = themeMapping(propValueFinal);
    } else if (Array.isArray(themeMapping)) {
      value = themeMapping[propValueFinal] || userValue;
    } else {
      value = getPath(themeMapping, propValueFinal) || userValue;
    }
    if (transform) {
      value = transform(value, userValue, themeMapping);
    }
    return value;
  }
  function style(options) {
    const {
      prop,
      cssProperty = options.prop,
      themeKey,
      transform
    } = options;
    const fn2 = (props) => {
      if (props[prop] == null) {
        return null;
      }
      const propValue = props[prop];
      const theme = props.theme;
      const themeMapping = getPath(theme, themeKey) || {};
      const styleFromPropValue = (propValueFinal) => {
        let value = getStyleValue(themeMapping, transform, propValueFinal);
        if (propValueFinal === value && typeof propValueFinal === "string") {
          value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
        }
        if (cssProperty === false) {
          return value;
        }
        return {
          [cssProperty]: value
        };
      };
      return handleBreakpoints(props, propValue, styleFromPropValue);
    };
    fn2.propTypes = false ? {
      [prop]: responsivePropType_default
    } : {};
    fn2.filterProps = [prop];
    return fn2;
  }
  var style_default = style;

  // node_modules/@mui/system/esm/memoize/memoize.js
  function memoize2(fn2) {
    const cache = {};
    return (arg2) => {
      if (cache[arg2] === void 0) {
        cache[arg2] = fn2(arg2);
      }
      return cache[arg2];
    };
  }

  // node_modules/@mui/system/esm/spacing/spacing.js
  var properties = {
    m: "margin",
    p: "padding"
  };
  var directions = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
  };
  var aliases = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
  };
  var getCssProperties = memoize2((prop) => {
    if (prop.length > 2) {
      if (aliases[prop]) {
        prop = aliases[prop];
      } else {
        return [prop];
      }
    }
    const [a, b] = prop.split("");
    const property = properties[a];
    const direction = directions[b] || "";
    return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
  });
  var marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
  var paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
  var spacingKeys = [...marginKeys, ...paddingKeys];
  function createUnaryUnit(theme, themeKey, defaultValue, propName) {
    var _a;
    const themeSpacing = (_a = getPath(theme, themeKey, true)) != null ? _a : defaultValue;
    if (typeof themeSpacing === "number" || typeof themeSpacing === "string") {
      return (val) => {
        if (typeof val === "string") {
          return val;
        }
        if (false) {
          if (typeof val !== "number") {
            console.error(`MUI: Expected ${propName} argument to be a number or a string, got ${val}.`);
          }
        }
        if (typeof themeSpacing === "string") {
          return `calc(${val} * ${themeSpacing})`;
        }
        return themeSpacing * val;
      };
    }
    if (Array.isArray(themeSpacing)) {
      return (val) => {
        if (typeof val === "string") {
          return val;
        }
        const abs2 = Math.abs(val);
        if (false) {
          if (!Number.isInteger(abs2)) {
            console.error([`MUI: The \`theme.${themeKey}\` array type cannot be combined with non integer values.You should either use an integer value that can be used as index, or define the \`theme.${themeKey}\` as a number.`].join("\n"));
          } else if (abs2 > themeSpacing.length - 1) {
            console.error([`MUI: The value provided (${abs2}) overflows.`, `The supported values are: ${JSON.stringify(themeSpacing)}.`, `${abs2} > ${themeSpacing.length - 1}, you need to add the missing values.`].join("\n"));
          }
        }
        const transformed = themeSpacing[abs2];
        if (val >= 0) {
          return transformed;
        }
        if (typeof transformed === "number") {
          return -transformed;
        }
        return `-${transformed}`;
      };
    }
    if (typeof themeSpacing === "function") {
      return themeSpacing;
    }
    if (false) {
      console.error([`MUI: The \`theme.${themeKey}\` value (${themeSpacing}) is invalid.`, "It should be a number, an array or a function."].join("\n"));
    }
    return () => void 0;
  }
  function createUnarySpacing(theme) {
    return createUnaryUnit(theme, "spacing", 8, "spacing");
  }
  function getValue(transformer3, propValue) {
    if (typeof propValue === "string" || propValue == null) {
      return propValue;
    }
    return transformer3(propValue);
  }
  function getStyleFromPropValue(cssProperties, transformer3) {
    return (propValue) => cssProperties.reduce((acc, cssProperty) => {
      acc[cssProperty] = getValue(transformer3, propValue);
      return acc;
    }, {});
  }
  function resolveCssProperty(props, keys, prop, transformer3) {
    if (!keys.includes(prop)) {
      return null;
    }
    const cssProperties = getCssProperties(prop);
    const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer3);
    const propValue = props[prop];
    return handleBreakpoints(props, propValue, styleFromPropValue);
  }
  function style2(props, keys) {
    const transformer3 = createUnarySpacing(props.theme);
    return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer3)).reduce(merge_default, {});
  }
  function margin(props) {
    return style2(props, marginKeys);
  }
  margin.propTypes = false ? marginKeys.reduce((obj, key) => {
    obj[key] = responsivePropType_default;
    return obj;
  }, {}) : {};
  margin.filterProps = marginKeys;
  function padding(props) {
    return style2(props, paddingKeys);
  }
  padding.propTypes = false ? paddingKeys.reduce((obj, key) => {
    obj[key] = responsivePropType_default;
    return obj;
  }, {}) : {};
  padding.filterProps = paddingKeys;
  function spacing(props) {
    return style2(props, spacingKeys);
  }
  spacing.propTypes = false ? spacingKeys.reduce((obj, key) => {
    obj[key] = responsivePropType_default;
    return obj;
  }, {}) : {};
  spacing.filterProps = spacingKeys;

  // node_modules/@mui/system/esm/createTheme/createSpacing.js
  function createSpacing(spacingInput = 8, transform = createUnarySpacing({
    spacing: spacingInput
  })) {
    if (spacingInput.mui) {
      return spacingInput;
    }
    const spacing2 = (...argsInput) => {
      if (false) {
        if (!(argsInput.length <= 4)) {
          console.error(`MUI: Too many arguments provided, expected between 0 and 4, got ${argsInput.length}`);
        }
      }
      const args = argsInput.length === 0 ? [1] : argsInput;
      return args.map((argument) => {
        const output = transform(argument);
        return typeof output === "number" ? `${output}px` : output;
      }).join(" ");
    };
    spacing2.mui = true;
    return spacing2;
  }

  // node_modules/@mui/system/esm/compose/compose.js
  function compose(...styles2) {
    const handlers = styles2.reduce((acc, style4) => {
      style4.filterProps.forEach((prop) => {
        acc[prop] = style4;
      });
      return acc;
    }, {});
    const fn2 = (props) => {
      return Object.keys(props).reduce((acc, prop) => {
        if (handlers[prop]) {
          return merge_default(acc, handlers[prop](props));
        }
        return acc;
      }, {});
    };
    fn2.propTypes = false ? styles2.reduce((acc, style4) => Object.assign(acc, style4.propTypes), {}) : {};
    fn2.filterProps = styles2.reduce((acc, style4) => acc.concat(style4.filterProps), []);
    return fn2;
  }
  var compose_default = compose;

  // node_modules/@mui/system/esm/borders/borders.js
  function borderTransform(value) {
    if (typeof value !== "number") {
      return value;
    }
    return `${value}px solid`;
  }
  function createBorderStyle(prop, transform) {
    return style_default({
      prop,
      themeKey: "borders",
      transform
    });
  }
  var border = createBorderStyle("border", borderTransform);
  var borderTop = createBorderStyle("borderTop", borderTransform);
  var borderRight = createBorderStyle("borderRight", borderTransform);
  var borderBottom = createBorderStyle("borderBottom", borderTransform);
  var borderLeft = createBorderStyle("borderLeft", borderTransform);
  var borderColor = createBorderStyle("borderColor");
  var borderTopColor = createBorderStyle("borderTopColor");
  var borderRightColor = createBorderStyle("borderRightColor");
  var borderBottomColor = createBorderStyle("borderBottomColor");
  var borderLeftColor = createBorderStyle("borderLeftColor");
  var outline = createBorderStyle("outline", borderTransform);
  var outlineColor = createBorderStyle("outlineColor");
  var borderRadius = (props) => {
    if (props.borderRadius !== void 0 && props.borderRadius !== null) {
      const transformer3 = createUnaryUnit(props.theme, "shape.borderRadius", 4, "borderRadius");
      const styleFromPropValue = (propValue) => ({
        borderRadius: getValue(transformer3, propValue)
      });
      return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
    }
    return null;
  };
  borderRadius.propTypes = false ? {
    borderRadius: responsivePropType_default
  } : {};
  borderRadius.filterProps = ["borderRadius"];
  var borders = compose_default(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);

  // node_modules/@mui/system/esm/cssGrid/cssGrid.js
  var gap = (props) => {
    if (props.gap !== void 0 && props.gap !== null) {
      const transformer3 = createUnaryUnit(props.theme, "spacing", 8, "gap");
      const styleFromPropValue = (propValue) => ({
        gap: getValue(transformer3, propValue)
      });
      return handleBreakpoints(props, props.gap, styleFromPropValue);
    }
    return null;
  };
  gap.propTypes = false ? {
    gap: responsivePropType_default
  } : {};
  gap.filterProps = ["gap"];
  var columnGap = (props) => {
    if (props.columnGap !== void 0 && props.columnGap !== null) {
      const transformer3 = createUnaryUnit(props.theme, "spacing", 8, "columnGap");
      const styleFromPropValue = (propValue) => ({
        columnGap: getValue(transformer3, propValue)
      });
      return handleBreakpoints(props, props.columnGap, styleFromPropValue);
    }
    return null;
  };
  columnGap.propTypes = false ? {
    columnGap: responsivePropType_default
  } : {};
  columnGap.filterProps = ["columnGap"];
  var rowGap = (props) => {
    if (props.rowGap !== void 0 && props.rowGap !== null) {
      const transformer3 = createUnaryUnit(props.theme, "spacing", 8, "rowGap");
      const styleFromPropValue = (propValue) => ({
        rowGap: getValue(transformer3, propValue)
      });
      return handleBreakpoints(props, props.rowGap, styleFromPropValue);
    }
    return null;
  };
  rowGap.propTypes = false ? {
    rowGap: responsivePropType_default
  } : {};
  rowGap.filterProps = ["rowGap"];
  var gridColumn = style_default({
    prop: "gridColumn"
  });
  var gridRow = style_default({
    prop: "gridRow"
  });
  var gridAutoFlow = style_default({
    prop: "gridAutoFlow"
  });
  var gridAutoColumns = style_default({
    prop: "gridAutoColumns"
  });
  var gridAutoRows = style_default({
    prop: "gridAutoRows"
  });
  var gridTemplateColumns = style_default({
    prop: "gridTemplateColumns"
  });
  var gridTemplateRows = style_default({
    prop: "gridTemplateRows"
  });
  var gridTemplateAreas = style_default({
    prop: "gridTemplateAreas"
  });
  var gridArea = style_default({
    prop: "gridArea"
  });
  var grid = compose_default(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);

  // node_modules/@mui/system/esm/palette/palette.js
  function paletteTransform(value, userValue) {
    if (userValue === "grey") {
      return userValue;
    }
    return value;
  }
  var color = style_default({
    prop: "color",
    themeKey: "palette",
    transform: paletteTransform
  });
  var bgcolor = style_default({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
  });
  var backgroundColor = style_default({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
  });
  var palette = compose_default(color, bgcolor, backgroundColor);

  // node_modules/@mui/system/esm/sizing/sizing.js
  function sizingTransform(value) {
    return value <= 1 && value !== 0 ? `${value * 100}%` : value;
  }
  var width = style_default({
    prop: "width",
    transform: sizingTransform
  });
  var maxWidth = (props) => {
    if (props.maxWidth !== void 0 && props.maxWidth !== null) {
      const styleFromPropValue = (propValue) => {
        var _a, _b, _c, _d, _e;
        const breakpoint = ((_c = (_b = (_a = props.theme) == null ? void 0 : _a.breakpoints) == null ? void 0 : _b.values) == null ? void 0 : _c[propValue]) || values[propValue];
        if (!breakpoint) {
          return {
            maxWidth: sizingTransform(propValue)
          };
        }
        if (((_e = (_d = props.theme) == null ? void 0 : _d.breakpoints) == null ? void 0 : _e.unit) !== "px") {
          return {
            maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
          };
        }
        return {
          maxWidth: breakpoint
        };
      };
      return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
    }
    return null;
  };
  maxWidth.filterProps = ["maxWidth"];
  var minWidth = style_default({
    prop: "minWidth",
    transform: sizingTransform
  });
  var height = style_default({
    prop: "height",
    transform: sizingTransform
  });
  var maxHeight = style_default({
    prop: "maxHeight",
    transform: sizingTransform
  });
  var minHeight = style_default({
    prop: "minHeight",
    transform: sizingTransform
  });
  var sizeWidth = style_default({
    prop: "size",
    cssProperty: "width",
    transform: sizingTransform
  });
  var sizeHeight = style_default({
    prop: "size",
    cssProperty: "height",
    transform: sizingTransform
  });
  var boxSizing = style_default({
    prop: "boxSizing"
  });
  var sizing = compose_default(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);

  // node_modules/@mui/system/esm/styleFunctionSx/defaultSxConfig.js
  var defaultSxConfig = {
    // borders
    border: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderTop: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderRight: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderBottom: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderLeft: {
      themeKey: "borders",
      transform: borderTransform
    },
    borderColor: {
      themeKey: "palette"
    },
    borderTopColor: {
      themeKey: "palette"
    },
    borderRightColor: {
      themeKey: "palette"
    },
    borderBottomColor: {
      themeKey: "palette"
    },
    borderLeftColor: {
      themeKey: "palette"
    },
    outline: {
      themeKey: "borders",
      transform: borderTransform
    },
    outlineColor: {
      themeKey: "palette"
    },
    borderRadius: {
      themeKey: "shape.borderRadius",
      style: borderRadius
    },
    // palette
    color: {
      themeKey: "palette",
      transform: paletteTransform
    },
    bgcolor: {
      themeKey: "palette",
      cssProperty: "backgroundColor",
      transform: paletteTransform
    },
    backgroundColor: {
      themeKey: "palette",
      transform: paletteTransform
    },
    // spacing
    p: {
      style: padding
    },
    pt: {
      style: padding
    },
    pr: {
      style: padding
    },
    pb: {
      style: padding
    },
    pl: {
      style: padding
    },
    px: {
      style: padding
    },
    py: {
      style: padding
    },
    padding: {
      style: padding
    },
    paddingTop: {
      style: padding
    },
    paddingRight: {
      style: padding
    },
    paddingBottom: {
      style: padding
    },
    paddingLeft: {
      style: padding
    },
    paddingX: {
      style: padding
    },
    paddingY: {
      style: padding
    },
    paddingInline: {
      style: padding
    },
    paddingInlineStart: {
      style: padding
    },
    paddingInlineEnd: {
      style: padding
    },
    paddingBlock: {
      style: padding
    },
    paddingBlockStart: {
      style: padding
    },
    paddingBlockEnd: {
      style: padding
    },
    m: {
      style: margin
    },
    mt: {
      style: margin
    },
    mr: {
      style: margin
    },
    mb: {
      style: margin
    },
    ml: {
      style: margin
    },
    mx: {
      style: margin
    },
    my: {
      style: margin
    },
    margin: {
      style: margin
    },
    marginTop: {
      style: margin
    },
    marginRight: {
      style: margin
    },
    marginBottom: {
      style: margin
    },
    marginLeft: {
      style: margin
    },
    marginX: {
      style: margin
    },
    marginY: {
      style: margin
    },
    marginInline: {
      style: margin
    },
    marginInlineStart: {
      style: margin
    },
    marginInlineEnd: {
      style: margin
    },
    marginBlock: {
      style: margin
    },
    marginBlockStart: {
      style: margin
    },
    marginBlockEnd: {
      style: margin
    },
    // display
    displayPrint: {
      cssProperty: false,
      transform: (value) => ({
        "@media print": {
          display: value
        }
      })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    // flexbox
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    // grid
    gap: {
      style: gap
    },
    rowGap: {
      style: rowGap
    },
    columnGap: {
      style: columnGap
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    // positions
    position: {},
    zIndex: {
      themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    // shadows
    boxShadow: {
      themeKey: "shadows"
    },
    // sizing
    width: {
      transform: sizingTransform
    },
    maxWidth: {
      style: maxWidth
    },
    minWidth: {
      transform: sizingTransform
    },
    height: {
      transform: sizingTransform
    },
    maxHeight: {
      transform: sizingTransform
    },
    minHeight: {
      transform: sizingTransform
    },
    boxSizing: {},
    // typography
    font: {
      themeKey: "font"
    },
    fontFamily: {
      themeKey: "typography"
    },
    fontSize: {
      themeKey: "typography"
    },
    fontStyle: {
      themeKey: "typography"
    },
    fontWeight: {
      themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
      cssProperty: false,
      themeKey: "typography"
    }
  };
  var defaultSxConfig_default = defaultSxConfig;

  // node_modules/@mui/system/esm/styleFunctionSx/styleFunctionSx.js
  function objectsHaveSameKeys(...objects) {
    const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
    const union = new Set(allKeys);
    return objects.every((object) => union.size === Object.keys(object).length);
  }
  function callIfFn(maybeFn, arg2) {
    return typeof maybeFn === "function" ? maybeFn(arg2) : maybeFn;
  }
  function unstable_createStyleFunctionSx() {
    function getThemeValue(prop, val, theme, config2) {
      const props = {
        [prop]: val,
        theme
      };
      const options = config2[prop];
      if (!options) {
        return {
          [prop]: val
        };
      }
      const {
        cssProperty = prop,
        themeKey,
        transform,
        style: style4
      } = options;
      if (val == null) {
        return null;
      }
      if (themeKey === "typography" && val === "inherit") {
        return {
          [prop]: val
        };
      }
      const themeMapping = getPath(theme, themeKey) || {};
      if (style4) {
        return style4(props);
      }
      const styleFromPropValue = (propValueFinal) => {
        let value = getStyleValue(themeMapping, transform, propValueFinal);
        if (propValueFinal === value && typeof propValueFinal === "string") {
          value = getStyleValue(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
        }
        if (cssProperty === false) {
          return value;
        }
        return {
          [cssProperty]: value
        };
      };
      return handleBreakpoints(props, val, styleFromPropValue);
    }
    function styleFunctionSx2(props) {
      var _a;
      const {
        sx,
        theme = {}
      } = props || {};
      if (!sx) {
        return null;
      }
      const config2 = (_a = theme.unstable_sxConfig) != null ? _a : defaultSxConfig_default;
      function traverse(sxInput) {
        let sxObject = sxInput;
        if (typeof sxInput === "function") {
          sxObject = sxInput(theme);
        } else if (typeof sxInput !== "object") {
          return sxInput;
        }
        if (!sxObject) {
          return null;
        }
        const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
        const breakpointsKeys = Object.keys(emptyBreakpoints);
        let css2 = emptyBreakpoints;
        Object.keys(sxObject).forEach((styleKey) => {
          const value = callIfFn(sxObject[styleKey], theme);
          if (value !== null && value !== void 0) {
            if (typeof value === "object") {
              if (config2[styleKey]) {
                css2 = merge_default(css2, getThemeValue(styleKey, value, theme, config2));
              } else {
                const breakpointsValues = handleBreakpoints({
                  theme
                }, value, (x) => ({
                  [styleKey]: x
                }));
                if (objectsHaveSameKeys(breakpointsValues, value)) {
                  css2[styleKey] = styleFunctionSx2({
                    sx: value,
                    theme
                  });
                } else {
                  css2 = merge_default(css2, breakpointsValues);
                }
              }
            } else {
              css2 = merge_default(css2, getThemeValue(styleKey, value, theme, config2));
            }
          }
        });
        return sortContainerQueries(theme, removeUnusedBreakpoints(breakpointsKeys, css2));
      }
      return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
    }
    return styleFunctionSx2;
  }
  var styleFunctionSx = unstable_createStyleFunctionSx();
  styleFunctionSx.filterProps = ["sx"];
  var styleFunctionSx_default = styleFunctionSx;

  // node_modules/@mui/system/esm/createTheme/applyStyles.js
  function applyStyles(key, styles2) {
    var _a;
    const theme = this;
    if (theme.vars) {
      if (!((_a = theme.colorSchemes) == null ? void 0 : _a[key]) || typeof theme.getColorSchemeSelector !== "function") {
        return {};
      }
      let selector = theme.getColorSchemeSelector(key);
      if (selector === "&") {
        return styles2;
      }
      if (selector.includes("data-") || selector.includes(".")) {
        selector = `*:where(${selector.replace(/\s*&$/, "")}) &`;
      }
      return {
        [selector]: styles2
      };
    }
    if (theme.palette.mode === key) {
      return styles2;
    }
    return {};
  }

  // node_modules/@mui/system/esm/createTheme/createTheme.js
  function createTheme(options = {}, ...args) {
    const _a = options, {
      breakpoints: breakpointsInput = {},
      palette: paletteInput = {},
      spacing: spacingInput,
      shape: shapeInput = {}
    } = _a, other = __objRest(_a, [
      "breakpoints",
      "palette",
      "spacing",
      "shape"
    ]);
    const breakpoints = createBreakpoints(breakpointsInput);
    const spacing2 = createSpacing(spacingInput);
    let muiTheme = deepmerge({
      breakpoints,
      direction: "ltr",
      components: {},
      // Inject component definitions.
      palette: __spreadValues({
        mode: "light"
      }, paletteInput),
      spacing: spacing2,
      shape: __spreadValues(__spreadValues({}, shape_default), shapeInput)
    }, other);
    muiTheme = cssContainerQueries(muiTheme);
    muiTheme.applyStyles = applyStyles;
    muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
    muiTheme.unstable_sxConfig = __spreadValues(__spreadValues({}, defaultSxConfig_default), other == null ? void 0 : other.unstable_sxConfig);
    muiTheme.unstable_sx = function sx(props) {
      return styleFunctionSx_default({
        sx: props,
        theme: this
      });
    };
    return muiTheme;
  }
  var createTheme_default = createTheme;

  // node_modules/@mui/system/esm/useThemeWithoutDefault/useThemeWithoutDefault.js
  var React7 = __toESM(require_react());
  function isObjectEmpty(obj) {
    return Object.keys(obj).length === 0;
  }
  function useTheme2(defaultTheme5 = null) {
    const contextTheme = React7.useContext(ThemeContext);
    return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme5 : contextTheme;
  }
  var useThemeWithoutDefault_default = useTheme2;

  // node_modules/@mui/system/esm/useTheme/useTheme.js
  var systemDefaultTheme = createTheme_default();
  function useTheme3(defaultTheme5 = systemDefaultTheme) {
    return useThemeWithoutDefault_default(defaultTheme5);
  }
  var useTheme_default = useTheme3;

  // node_modules/@mui/system/esm/styleFunctionSx/extendSxProp.js
  var splitProps = (props) => {
    var _a, _b;
    const result = {
      systemProps: {},
      otherProps: {}
    };
    const config2 = (_b = (_a = props == null ? void 0 : props.theme) == null ? void 0 : _a.unstable_sxConfig) != null ? _b : defaultSxConfig_default;
    Object.keys(props).forEach((prop) => {
      if (config2[prop]) {
        result.systemProps[prop] = props[prop];
      } else {
        result.otherProps[prop] = props[prop];
      }
    });
    return result;
  };
  function extendSxProp(props) {
    const _a = props, {
      sx: inSx
    } = _a, other = __objRest(_a, [
      "sx"
    ]);
    const {
      systemProps,
      otherProps
    } = splitProps(other);
    let finalSx;
    if (Array.isArray(inSx)) {
      finalSx = [systemProps, ...inSx];
    } else if (typeof inSx === "function") {
      finalSx = (...args) => {
        const result = inSx(...args);
        if (!isPlainObject(result)) {
          return systemProps;
        }
        return __spreadValues(__spreadValues({}, systemProps), result);
      };
    } else {
      finalSx = __spreadValues(__spreadValues({}, systemProps), inSx);
    }
    return __spreadProps(__spreadValues({}, otherProps), {
      sx: finalSx
    });
  }

  // node_modules/@mui/utils/esm/ClassNameGenerator/ClassNameGenerator.js
  var defaultGenerator = (componentName) => componentName;
  var createClassNameGenerator = () => {
    let generate = defaultGenerator;
    return {
      configure(generator) {
        generate = generator;
      },
      generate(componentName) {
        return generate(componentName);
      },
      reset() {
        generate = defaultGenerator;
      }
    };
  };
  var ClassNameGenerator = createClassNameGenerator();
  var ClassNameGenerator_default = ClassNameGenerator;

  // node_modules/@mui/system/esm/createBox/createBox.js
  var React8 = __toESM(require_react());

  // node_modules/clsx/dist/clsx.mjs
  function r(e) {
    var t, f, n = "";
    if ("string" == typeof e || "number" == typeof e) n += e;
    else if ("object" == typeof e) if (Array.isArray(e)) {
      var o = e.length;
      for (t = 0; t < o; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
    } else for (f in e) e[f] && (n && (n += " "), n += f);
    return n;
  }
  function clsx() {
    for (var e, t, f = 0, n = "", o = arguments.length; f < o; f++) (e = arguments[f]) && (t = r(e)) && (n && (n += " "), n += t);
    return n;
  }
  var clsx_default = clsx;

  // node_modules/@mui/system/esm/createBox/createBox.js
  var import_jsx_runtime3 = __toESM(require_jsx_runtime());
  function createBox(options = {}) {
    const {
      themeId,
      defaultTheme: defaultTheme5,
      defaultClassName = "MuiBox-root",
      generateClassName
    } = options;
    const BoxRoot = styled("div", {
      shouldForwardProp: (prop) => prop !== "theme" && prop !== "sx" && prop !== "as"
    })(styleFunctionSx_default);
    const Box2 = /* @__PURE__ */ React8.forwardRef(function Box3(inProps, ref) {
      const theme = useTheme_default(defaultTheme5);
      const _a = extendSxProp(inProps), {
        className,
        component = "div"
      } = _a, other = __objRest(_a, [
        "className",
        "component"
      ]);
      return /* @__PURE__ */ (0, import_jsx_runtime3.jsx)(BoxRoot, __spreadValues({
        as: component,
        ref,
        className: clsx_default(className, generateClassName ? generateClassName(defaultClassName) : defaultClassName),
        theme: themeId ? theme[themeId] || theme : theme
      }, other));
    });
    return Box2;
  }

  // node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js
  var globalStateClasses = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
  };
  function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
    const globalStateClass = globalStateClasses[slot];
    return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator_default.generate(componentName)}-${slot}`;
  }

  // node_modules/@mui/utils/esm/generateUtilityClasses/generateUtilityClasses.js
  function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
    const result = {};
    slots.forEach((slot) => {
      result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
    });
    return result;
  }

  // node_modules/@mui/system/esm/preprocessStyles.js
  function preprocessStyles(input) {
    const _a = input, {
      variants
    } = _a, style4 = __objRest(_a, [
      "variants"
    ]);
    const result = {
      variants,
      style: internal_serializeStyles(style4),
      isProcessed: true
    };
    if (result.style === style4) {
      return result;
    }
    if (variants) {
      variants.forEach((variant) => {
        if (typeof variant.style !== "function") {
          variant.style = internal_serializeStyles(variant.style);
        }
      });
    }
    return result;
  }

  // node_modules/@mui/system/esm/createStyled/createStyled.js
  var systemDefaultTheme2 = createTheme_default();
  function shouldForwardProp(prop) {
    return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
  }
  function defaultOverridesResolver(slot) {
    if (!slot) {
      return null;
    }
    return (_props, styles2) => styles2[slot];
  }
  function attachTheme(props, themeId, defaultTheme5) {
    props.theme = isObjectEmpty2(props.theme) ? defaultTheme5 : props.theme[themeId] || props.theme;
  }
  function processStyle(props, style4) {
    const resolvedStyle = typeof style4 === "function" ? style4(props) : style4;
    if (Array.isArray(resolvedStyle)) {
      return resolvedStyle.flatMap((subStyle) => processStyle(props, subStyle));
    }
    if (Array.isArray(resolvedStyle == null ? void 0 : resolvedStyle.variants)) {
      let rootStyle;
      if (resolvedStyle.isProcessed) {
        rootStyle = resolvedStyle.style;
      } else {
        const _a = resolvedStyle, {
          variants
        } = _a, otherStyles = __objRest(_a, [
          "variants"
        ]);
        rootStyle = otherStyles;
      }
      return processStyleVariants(props, resolvedStyle.variants, [rootStyle]);
    }
    if (resolvedStyle == null ? void 0 : resolvedStyle.isProcessed) {
      return resolvedStyle.style;
    }
    return resolvedStyle;
  }
  function processStyleVariants(props, variants, results = []) {
    var _a;
    let mergedState;
    variantLoop: for (let i = 0; i < variants.length; i += 1) {
      const variant = variants[i];
      if (typeof variant.props === "function") {
        mergedState != null ? mergedState : mergedState = __spreadProps(__spreadValues(__spreadValues({}, props), props.ownerState), {
          ownerState: props.ownerState
        });
        if (!variant.props(mergedState)) {
          continue;
        }
      } else {
        for (const key in variant.props) {
          if (props[key] !== variant.props[key] && ((_a = props.ownerState) == null ? void 0 : _a[key]) !== variant.props[key]) {
            continue variantLoop;
          }
        }
      }
      if (typeof variant.style === "function") {
        mergedState != null ? mergedState : mergedState = __spreadProps(__spreadValues(__spreadValues({}, props), props.ownerState), {
          ownerState: props.ownerState
        });
        results.push(variant.style(mergedState));
      } else {
        results.push(variant.style);
      }
    }
    return results;
  }
  function createStyled3(input = {}) {
    const {
      themeId,
      defaultTheme: defaultTheme5 = systemDefaultTheme2,
      rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
      slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
    } = input;
    function styleAttachTheme(props) {
      attachTheme(props, themeId, defaultTheme5);
    }
    const styled4 = (tag, inputOptions = {}) => {
      internal_mutateStyles(tag, (styles2) => styles2.filter((style4) => style4 !== styleFunctionSx_default));
      const _a = inputOptions, {
        name: componentName,
        slot: componentSlot,
        skipVariantsResolver: inputSkipVariantsResolver,
        skipSx: inputSkipSx,
        overridesResolver: overridesResolver = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
      } = _a, options = __objRest(_a, [
        "name",
        "slot",
        "skipVariantsResolver",
        "skipSx",
        // TODO v6: remove `lowercaseFirstLetter()` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        "overridesResolver"
      ]);
      const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
        // TODO v6: remove `Root` in the next major release
        // For more details: https://github.com/mui/material-ui/pull/37908
        componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
      );
      const skipSx = inputSkipSx || false;
      let shouldForwardPropOption = shouldForwardProp;
      if (componentSlot === "Root" || componentSlot === "root") {
        shouldForwardPropOption = rootShouldForwardProp2;
      } else if (componentSlot) {
        shouldForwardPropOption = slotShouldForwardProp2;
      } else if (isStringTag(tag)) {
        shouldForwardPropOption = void 0;
      }
      const defaultStyledResolver = styled(tag, __spreadValues({
        shouldForwardProp: shouldForwardPropOption,
        label: generateStyledLabel(componentName, componentSlot)
      }, options));
      const transformStyle = (style4) => {
        if (typeof style4 === "function" && style4.__emotion_real !== style4) {
          return function styleFunctionProcessor(props) {
            return processStyle(props, style4);
          };
        }
        if (isPlainObject(style4)) {
          const serialized = preprocessStyles(style4);
          if (!serialized.variants) {
            return serialized.style;
          }
          return function styleObjectProcessor(props) {
            return processStyle(props, serialized);
          };
        }
        return style4;
      };
      const muiStyledResolver = (...expressionsInput) => {
        const expressionsHead = [];
        const expressionsBody = expressionsInput.map(transformStyle);
        const expressionsTail = [];
        expressionsHead.push(styleAttachTheme);
        if (componentName && overridesResolver) {
          expressionsTail.push(function styleThemeOverrides(props) {
            var _a2, _b;
            const theme = props.theme;
            const styleOverrides = (_b = (_a2 = theme.components) == null ? void 0 : _a2[componentName]) == null ? void 0 : _b.styleOverrides;
            if (!styleOverrides) {
              return null;
            }
            const resolvedStyleOverrides = {};
            for (const slotKey in styleOverrides) {
              resolvedStyleOverrides[slotKey] = processStyle(props, styleOverrides[slotKey]);
            }
            return overridesResolver(props, resolvedStyleOverrides);
          });
        }
        if (componentName && !skipVariantsResolver) {
          expressionsTail.push(function styleThemeVariants(props) {
            var _a2, _b;
            const theme = props.theme;
            const themeVariants = (_b = (_a2 = theme == null ? void 0 : theme.components) == null ? void 0 : _a2[componentName]) == null ? void 0 : _b.variants;
            if (!themeVariants) {
              return null;
            }
            return processStyleVariants(props, themeVariants);
          });
        }
        if (!skipSx) {
          expressionsTail.push(styleFunctionSx_default);
        }
        if (Array.isArray(expressionsBody[0])) {
          const inputStrings = expressionsBody.shift();
          const placeholdersHead = new Array(expressionsHead.length).fill("");
          const placeholdersTail = new Array(expressionsTail.length).fill("");
          let outputStrings;
          {
            outputStrings = [...placeholdersHead, ...inputStrings, ...placeholdersTail];
            outputStrings.raw = [...placeholdersHead, ...inputStrings.raw, ...placeholdersTail];
          }
          expressionsHead.unshift(outputStrings);
        }
        const expressions = [...expressionsHead, ...expressionsBody, ...expressionsTail];
        const Component = defaultStyledResolver(...expressions);
        if (tag.muiName) {
          Component.muiName = tag.muiName;
        }
        if (false) {
          Component.displayName = generateDisplayName(componentName, componentSlot, tag);
        }
        return Component;
      };
      if (defaultStyledResolver.withConfig) {
        muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
      }
      return muiStyledResolver;
    };
    return styled4;
  }
  function generateStyledLabel(componentName, componentSlot) {
    let label;
    if (false) {
      if (componentName) {
        label = `${componentName}-${lowercaseFirstLetter(componentSlot || "Root")}`;
      }
    }
    return label;
  }
  function isObjectEmpty2(object) {
    for (const _2 in object) {
      return false;
    }
    return true;
  }
  function isStringTag(tag) {
    return typeof tag === "string" && // 96 is one less than the char code
    // for "a" so this is checking that
    // it's a lowercase character
    tag.charCodeAt(0) > 96;
  }
  function lowercaseFirstLetter(string) {
    if (!string) {
      return string;
    }
    return string.charAt(0).toLowerCase() + string.slice(1);
  }

  // node_modules/@mui/system/esm/styled/styled.js
  var styled2 = createStyled3();
  var styled_default = styled2;

  // node_modules/@mui/utils/esm/resolveProps/resolveProps.js
  function resolveProps(defaultProps4, props) {
    const output = __spreadValues({}, props);
    for (const key in defaultProps4) {
      if (Object.prototype.hasOwnProperty.call(defaultProps4, key)) {
        const propName = key;
        if (propName === "components" || propName === "slots") {
          output[propName] = __spreadValues(__spreadValues({}, defaultProps4[propName]), output[propName]);
        } else if (propName === "componentsProps" || propName === "slotProps") {
          const defaultSlotProps = defaultProps4[propName];
          const slotProps = props[propName];
          if (!slotProps) {
            output[propName] = defaultSlotProps || {};
          } else if (!defaultSlotProps) {
            output[propName] = slotProps;
          } else {
            output[propName] = __spreadValues({}, slotProps);
            for (const slotKey in defaultSlotProps) {
              if (Object.prototype.hasOwnProperty.call(defaultSlotProps, slotKey)) {
                const slotPropName = slotKey;
                output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
              }
            }
          }
        } else if (output[propName] === void 0) {
          output[propName] = defaultProps4[propName];
        }
      }
    }
    return output;
  }

  // node_modules/@mui/system/esm/useThemeProps/getThemeProps.js
  function getThemeProps(params) {
    const {
      theme,
      name,
      props
    } = params;
    if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
      return props;
    }
    return resolveProps(theme.components[name].defaultProps, props);
  }

  // node_modules/@mui/system/esm/useThemeProps/useThemeProps.js
  function useThemeProps({
    props,
    name,
    defaultTheme: defaultTheme5,
    themeId
  }) {
    let theme = useTheme_default(defaultTheme5);
    if (themeId) {
      theme = theme[themeId] || theme;
    }
    return getThemeProps({
      theme,
      name,
      props
    });
  }

  // node_modules/@mui/utils/esm/useEnhancedEffect/useEnhancedEffect.js
  var React9 = __toESM(require_react());
  var useEnhancedEffect = typeof window !== "undefined" ? React9.useLayoutEffect : React9.useEffect;
  var useEnhancedEffect_default = useEnhancedEffect;

  // node_modules/@mui/utils/esm/clamp/clamp.js
  function clamp(val, min2 = Number.MIN_SAFE_INTEGER, max2 = Number.MAX_SAFE_INTEGER) {
    return Math.max(min2, Math.min(val, max2));
  }
  var clamp_default = clamp;

  // node_modules/@mui/system/esm/colorManipulator/colorManipulator.js
  function clampWrapper(value, min2 = 0, max2 = 1) {
    if (false) {
      if (value < min2 || value > max2) {
        console.error(`MUI: The value provided ${value} is out of range [${min2}, ${max2}].`);
      }
    }
    return clamp_default(value, min2, max2);
  }
  function hexToRgb(color3) {
    color3 = color3.slice(1);
    const re2 = new RegExp(`.{1,${color3.length >= 6 ? 2 : 1}}`, "g");
    let colors3 = color3.match(re2);
    if (colors3 && colors3[0].length === 1) {
      colors3 = colors3.map((n) => n + n);
    }
    if (false) {
      if (color3.length !== color3.trim().length) {
        console.error(`MUI: The color: "${color3}" is invalid. Make sure the color input doesn't contain leading/trailing space.`);
      }
    }
    return colors3 ? `rgb${colors3.length === 4 ? "a" : ""}(${colors3.map((n, index) => {
      return index < 3 ? parseInt(n, 16) : Math.round(parseInt(n, 16) / 255 * 1e3) / 1e3;
    }).join(", ")})` : "";
  }
  function decomposeColor(color3) {
    if (color3.type) {
      return color3;
    }
    if (color3.charAt(0) === "#") {
      return decomposeColor(hexToRgb(color3));
    }
    const marker = color3.indexOf("(");
    const type = color3.substring(0, marker);
    if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(type)) {
      throw new Error(false ? `MUI: Unsupported \`${color3}\` color.
The following formats are supported: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().` : formatMuiErrorMessage(9, color3));
    }
    let values3 = color3.substring(marker + 1, color3.length - 1);
    let colorSpace;
    if (type === "color") {
      values3 = values3.split(" ");
      colorSpace = values3.shift();
      if (values3.length === 4 && values3[3].charAt(0) === "/") {
        values3[3] = values3[3].slice(1);
      }
      if (!["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(colorSpace)) {
        throw new Error(false ? `MUI: unsupported \`${colorSpace}\` color space.
The following color spaces are supported: srgb, display-p3, a98-rgb, prophoto-rgb, rec-2020.` : formatMuiErrorMessage(10, colorSpace));
      }
    } else {
      values3 = values3.split(",");
    }
    values3 = values3.map((value) => parseFloat(value));
    return {
      type,
      values: values3,
      colorSpace
    };
  }
  var colorChannel = (color3) => {
    const decomposedColor = decomposeColor(color3);
    return decomposedColor.values.slice(0, 3).map((val, idx) => decomposedColor.type.includes("hsl") && idx !== 0 ? `${val}%` : val).join(" ");
  };
  var private_safeColorChannel = (color3, warning) => {
    try {
      return colorChannel(color3);
    } catch (error) {
      if (warning && false) {
        console.warn(warning);
      }
      return color3;
    }
  };
  function recomposeColor(color3) {
    const {
      type,
      colorSpace
    } = color3;
    let {
      values: values3
    } = color3;
    if (type.includes("rgb")) {
      values3 = values3.map((n, i) => i < 3 ? parseInt(n, 10) : n);
    } else if (type.includes("hsl")) {
      values3[1] = `${values3[1]}%`;
      values3[2] = `${values3[2]}%`;
    }
    if (type.includes("color")) {
      values3 = `${colorSpace} ${values3.join(" ")}`;
    } else {
      values3 = `${values3.join(", ")}`;
    }
    return `${type}(${values3})`;
  }
  function hslToRgb(color3) {
    color3 = decomposeColor(color3);
    const {
      values: values3
    } = color3;
    const h = values3[0];
    const s = values3[1] / 100;
    const l = values3[2] / 100;
    const a = s * Math.min(l, 1 - l);
    const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    let type = "rgb";
    const rgb3 = [Math.round(f(0) * 255), Math.round(f(8) * 255), Math.round(f(4) * 255)];
    if (color3.type === "hsla") {
      type += "a";
      rgb3.push(values3[3]);
    }
    return recomposeColor({
      type,
      values: rgb3
    });
  }
  function getLuminance(color3) {
    color3 = decomposeColor(color3);
    let rgb3 = color3.type === "hsl" || color3.type === "hsla" ? decomposeColor(hslToRgb(color3)).values : color3.values;
    rgb3 = rgb3.map((val) => {
      if (color3.type !== "color") {
        val /= 255;
      }
      return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
    });
    return Number((0.2126 * rgb3[0] + 0.7152 * rgb3[1] + 0.0722 * rgb3[2]).toFixed(3));
  }
  function getContrastRatio(foreground, background) {
    const lumA = getLuminance(foreground);
    const lumB = getLuminance(background);
    return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
  }
  function alpha(color3, value) {
    color3 = decomposeColor(color3);
    value = clampWrapper(value);
    if (color3.type === "rgb" || color3.type === "hsl") {
      color3.type += "a";
    }
    if (color3.type === "color") {
      color3.values[3] = `/${value}`;
    } else {
      color3.values[3] = value;
    }
    return recomposeColor(color3);
  }
  function private_safeAlpha(color3, value, warning) {
    try {
      return alpha(color3, value);
    } catch (error) {
      if (warning && false) {
        console.warn(warning);
      }
      return color3;
    }
  }
  function darken(color3, coefficient) {
    color3 = decomposeColor(color3);
    coefficient = clampWrapper(coefficient);
    if (color3.type.includes("hsl")) {
      color3.values[2] *= 1 - coefficient;
    } else if (color3.type.includes("rgb") || color3.type.includes("color")) {
      for (let i = 0; i < 3; i += 1) {
        color3.values[i] *= 1 - coefficient;
      }
    }
    return recomposeColor(color3);
  }
  function private_safeDarken(color3, coefficient, warning) {
    try {
      return darken(color3, coefficient);
    } catch (error) {
      if (warning && false) {
        console.warn(warning);
      }
      return color3;
    }
  }
  function lighten(color3, coefficient) {
    color3 = decomposeColor(color3);
    coefficient = clampWrapper(coefficient);
    if (color3.type.includes("hsl")) {
      color3.values[2] += (100 - color3.values[2]) * coefficient;
    } else if (color3.type.includes("rgb")) {
      for (let i = 0; i < 3; i += 1) {
        color3.values[i] += (255 - color3.values[i]) * coefficient;
      }
    } else if (color3.type.includes("color")) {
      for (let i = 0; i < 3; i += 1) {
        color3.values[i] += (1 - color3.values[i]) * coefficient;
      }
    }
    return recomposeColor(color3);
  }
  function private_safeLighten(color3, coefficient, warning) {
    try {
      return lighten(color3, coefficient);
    } catch (error) {
      if (warning && false) {
        console.warn(warning);
      }
      return color3;
    }
  }
  function emphasize(color3, coefficient = 0.15) {
    return getLuminance(color3) > 0.5 ? darken(color3, coefficient) : lighten(color3, coefficient);
  }
  function private_safeEmphasize(color3, coefficient, warning) {
    try {
      return emphasize(color3, coefficient);
    } catch (error) {
      if (warning && false) {
        console.warn(warning);
      }
      return color3;
    }
  }

  // node_modules/@mui/system/esm/ThemeProvider/ThemeProvider.js
  var React23 = __toESM(require_react());

  // node_modules/@mui/private-theming/ThemeProvider/ThemeProvider.js
  var React20 = __toESM(require_react());

  // node_modules/@mui/utils/esm/createChainedFunction/createChainedFunction.js
  function createChainedFunction(...funcs) {
    return funcs.reduce((acc, func) => {
      if (func == null) {
        return acc;
      }
      return function chainedFunction(...args) {
        acc.apply(this, args);
        func.apply(this, args);
      };
    }, () => {
    });
  }

  // node_modules/@mui/utils/esm/isMuiElement/isMuiElement.js
  var React10 = __toESM(require_react());
  function isMuiElement(element, muiNames) {
    var _a, _b, _c, _d;
    return /* @__PURE__ */ React10.isValidElement(element) && muiNames.indexOf(
      // For server components `muiName` is avaialble in element.type._payload.value.muiName
      // relevant info - https://github.com/facebook/react/blob/2807d781a08db8e9873687fccc25c0f12b4fb3d4/packages/react/src/ReactLazy.js#L45
      // eslint-disable-next-line no-underscore-dangle
      (_d = element.type.muiName) != null ? _d : (_c = (_b = (_a = element.type) == null ? void 0 : _a._payload) == null ? void 0 : _b.value) == null ? void 0 : _c.muiName
    ) !== -1;
  }

  // node_modules/@mui/utils/esm/ownerDocument/ownerDocument.js
  function ownerDocument(node2) {
    return node2 && node2.ownerDocument || document;
  }

  // node_modules/@mui/utils/esm/ownerWindow/ownerWindow.js
  function ownerWindow(node2) {
    const doc = ownerDocument(node2);
    return doc.defaultView || window;
  }

  // node_modules/@mui/utils/esm/setRef/setRef.js
  function setRef(ref, value) {
    if (typeof ref === "function") {
      ref(value);
    } else if (ref) {
      ref.current = value;
    }
  }

  // node_modules/@mui/utils/esm/useId/useId.js
  var React11 = __toESM(require_react());
  var globalId = 0;
  function useGlobalId(idOverride) {
    const [defaultId, setDefaultId] = React11.useState(idOverride);
    const id = idOverride || defaultId;
    React11.useEffect(() => {
      if (defaultId == null) {
        globalId += 1;
        setDefaultId(`mui-${globalId}`);
      }
    }, [defaultId]);
    return id;
  }
  var safeReact = __spreadValues({}, React11);
  var maybeReactUseId = safeReact.useId;
  function useId(idOverride) {
    if (maybeReactUseId !== void 0) {
      const reactId = maybeReactUseId();
      return idOverride != null ? idOverride : reactId;
    }
    return useGlobalId(idOverride);
  }

  // node_modules/@mui/utils/esm/useEventCallback/useEventCallback.js
  var React12 = __toESM(require_react());
  function useEventCallback(fn2) {
    const ref = React12.useRef(fn2);
    useEnhancedEffect_default(() => {
      ref.current = fn2;
    });
    return React12.useRef((...args) => (
      // @ts-expect-error hide `this`
      (0, ref.current)(...args)
    )).current;
  }
  var useEventCallback_default = useEventCallback;

  // node_modules/@mui/utils/esm/useForkRef/useForkRef.js
  var React13 = __toESM(require_react());
  function useForkRef(...refs) {
    const cleanupRef = React13.useRef(void 0);
    const refEffect = React13.useCallback((instance2) => {
      const cleanups = refs.map((ref) => {
        if (ref == null) {
          return null;
        }
        if (typeof ref === "function") {
          const refCallback = ref;
          const refCleanup = refCallback(instance2);
          return typeof refCleanup === "function" ? refCleanup : () => {
            refCallback(null);
          };
        }
        ref.current = instance2;
        return () => {
          ref.current = null;
        };
      });
      return () => {
        cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
      };
    }, refs);
    return React13.useMemo(() => {
      if (refs.every((ref) => ref == null)) {
        return null;
      }
      return (value) => {
        if (cleanupRef.current) {
          cleanupRef.current();
          cleanupRef.current = void 0;
        }
        if (value != null) {
          cleanupRef.current = refEffect(value);
        }
      };
    }, refs);
  }

  // node_modules/@mui/utils/esm/useLazyRef/useLazyRef.js
  var React14 = __toESM(require_react());
  var UNINITIALIZED = {};
  function useLazyRef(init, initArg) {
    const ref = React14.useRef(UNINITIALIZED);
    if (ref.current === UNINITIALIZED) {
      ref.current = init(initArg);
    }
    return ref;
  }

  // node_modules/@mui/utils/esm/useOnMount/useOnMount.js
  var React15 = __toESM(require_react());
  var EMPTY = [];
  function useOnMount(fn2) {
    React15.useEffect(fn2, EMPTY);
  }

  // node_modules/@mui/utils/esm/useTimeout/useTimeout.js
  var Timeout = class _Timeout {
    constructor() {
      __publicField(this, "currentId", null);
      __publicField(this, "clear", () => {
        if (this.currentId !== null) {
          clearTimeout(this.currentId);
          this.currentId = null;
        }
      });
      __publicField(this, "disposeEffect", () => {
        return this.clear;
      });
    }
    static create() {
      return new _Timeout();
    }
    /**
     * Executes `fn` after `delay`, clearing any previously scheduled call.
     */
    start(delay, fn2) {
      this.clear();
      this.currentId = setTimeout(() => {
        this.currentId = null;
        fn2();
      }, delay);
    }
  };
  function useTimeout() {
    const timeout2 = useLazyRef(Timeout.create).current;
    useOnMount(timeout2.disposeEffect);
    return timeout2;
  }

  // node_modules/@mui/utils/esm/isFocusVisible/isFocusVisible.js
  function isFocusVisible(element) {
    try {
      return element.matches(":focus-visible");
    } catch (error) {
      if (false) {
        console.warn(["MUI: The `:focus-visible` pseudo class is not supported in this browser.", "Some components rely on this feature to work properly."].join("\n"));
      }
    }
    return false;
  }

  // node_modules/@mui/utils/esm/getScrollbarSize/getScrollbarSize.js
  function getScrollbarSize(win = window) {
    const documentWidth = win.document.documentElement.clientWidth;
    return win.innerWidth - documentWidth;
  }

  // node_modules/@mui/utils/esm/usePreviousProps/usePreviousProps.js
  var React16 = __toESM(require_react());
  var usePreviousProps = (value) => {
    const ref = React16.useRef({});
    React16.useEffect(() => {
      ref.current = value;
    });
    return ref.current;
  };
  var usePreviousProps_default = usePreviousProps;

  // node_modules/@mui/utils/esm/composeClasses/composeClasses.js
  function composeClasses(slots, getUtilityClass, classes = void 0) {
    const output = {};
    for (const slotName in slots) {
      const slot = slots[slotName];
      let buffer = "";
      let start3 = true;
      for (let i = 0; i < slot.length; i += 1) {
        const value = slot[i];
        if (value) {
          buffer += (start3 === true ? "" : " ") + getUtilityClass(value);
          start3 = false;
          if (classes && classes[value]) {
            buffer += " " + classes[value];
          }
        }
      }
      output[slotName] = buffer;
    }
    return output;
  }

  // node_modules/@mui/utils/esm/isHostComponent/isHostComponent.js
  function isHostComponent(element) {
    return typeof element === "string";
  }
  var isHostComponent_default = isHostComponent;

  // node_modules/@mui/utils/esm/appendOwnerState/appendOwnerState.js
  function appendOwnerState(elementType, otherProps, ownerState) {
    if (elementType === void 0 || isHostComponent_default(elementType)) {
      return otherProps;
    }
    return __spreadProps(__spreadValues({}, otherProps), {
      ownerState: __spreadValues(__spreadValues({}, otherProps.ownerState), ownerState)
    });
  }
  var appendOwnerState_default = appendOwnerState;

  // node_modules/@mui/utils/esm/extractEventHandlers/extractEventHandlers.js
  function extractEventHandlers(object, excludeKeys = []) {
    if (object === void 0) {
      return {};
    }
    const result = {};
    Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
      result[prop] = object[prop];
    });
    return result;
  }
  var extractEventHandlers_default = extractEventHandlers;

  // node_modules/@mui/utils/esm/omitEventHandlers/omitEventHandlers.js
  function omitEventHandlers(object) {
    if (object === void 0) {
      return {};
    }
    const result = {};
    Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
      result[prop] = object[prop];
    });
    return result;
  }
  var omitEventHandlers_default = omitEventHandlers;

  // node_modules/@mui/utils/esm/mergeSlotProps/mergeSlotProps.js
  function mergeSlotProps(parameters) {
    const {
      getSlotProps,
      additionalProps,
      externalSlotProps,
      externalForwardedProps,
      className
    } = parameters;
    if (!getSlotProps) {
      const joinedClasses2 = clsx_default(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
      const mergedStyle2 = __spreadValues(__spreadValues(__spreadValues({}, additionalProps == null ? void 0 : additionalProps.style), externalForwardedProps == null ? void 0 : externalForwardedProps.style), externalSlotProps == null ? void 0 : externalSlotProps.style);
      const props2 = __spreadValues(__spreadValues(__spreadValues({}, additionalProps), externalForwardedProps), externalSlotProps);
      if (joinedClasses2.length > 0) {
        props2.className = joinedClasses2;
      }
      if (Object.keys(mergedStyle2).length > 0) {
        props2.style = mergedStyle2;
      }
      return {
        props: props2,
        internalRef: void 0
      };
    }
    const eventHandlers = extractEventHandlers_default(__spreadValues(__spreadValues({}, externalForwardedProps), externalSlotProps));
    const componentsPropsWithoutEventHandlers = omitEventHandlers_default(externalSlotProps);
    const otherPropsWithoutEventHandlers = omitEventHandlers_default(externalForwardedProps);
    const internalSlotProps = getSlotProps(eventHandlers);
    const joinedClasses = clsx_default(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, internalSlotProps == null ? void 0 : internalSlotProps.style), additionalProps == null ? void 0 : additionalProps.style), externalForwardedProps == null ? void 0 : externalForwardedProps.style), externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, internalSlotProps), additionalProps), otherPropsWithoutEventHandlers), componentsPropsWithoutEventHandlers);
    if (joinedClasses.length > 0) {
      props.className = joinedClasses;
    }
    if (Object.keys(mergedStyle).length > 0) {
      props.style = mergedStyle;
    }
    return {
      props,
      internalRef: internalSlotProps.ref
    };
  }
  var mergeSlotProps_default = mergeSlotProps;

  // node_modules/@mui/utils/esm/resolveComponentProps/resolveComponentProps.js
  function resolveComponentProps(componentProps, ownerState, slotState) {
    if (typeof componentProps === "function") {
      return componentProps(ownerState, slotState);
    }
    return componentProps;
  }
  var resolveComponentProps_default = resolveComponentProps;

  // node_modules/@mui/utils/esm/useSlotProps/useSlotProps.js
  function useSlotProps(parameters) {
    var _b;
    const _a = parameters, {
      elementType,
      externalSlotProps,
      ownerState,
      skipResolvingSlotProps = false
    } = _a, other = __objRest(_a, [
      "elementType",
      "externalSlotProps",
      "ownerState",
      "skipResolvingSlotProps"
    ]);
    const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps_default(externalSlotProps, ownerState);
    const {
      props: mergedProps,
      internalRef
    } = mergeSlotProps_default(__spreadProps(__spreadValues({}, other), {
      externalSlotProps: resolvedComponentsProps
    }));
    const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_b = parameters.additionalProps) == null ? void 0 : _b.ref);
    const props = appendOwnerState_default(elementType, __spreadProps(__spreadValues({}, mergedProps), {
      ref
    }), ownerState);
    return props;
  }
  var useSlotProps_default = useSlotProps;

  // node_modules/@mui/utils/esm/getReactElementRef/getReactElementRef.js
  var React17 = __toESM(require_react());
  function getReactElementRef(element) {
    var _a;
    if (parseInt(React17.version, 10) >= 19) {
      return ((_a = element == null ? void 0 : element.props) == null ? void 0 : _a.ref) || null;
    }
    return (element == null ? void 0 : element.ref) || null;
  }

  // node_modules/@mui/private-theming/useTheme/ThemeContext.js
  var React18 = __toESM(require_react());
  var ThemeContext2 = /* @__PURE__ */ React18.createContext(null);
  if (false) {
    ThemeContext2.displayName = "ThemeContext";
  }
  var ThemeContext_default = ThemeContext2;

  // node_modules/@mui/private-theming/useTheme/useTheme.js
  var React19 = __toESM(require_react());
  function useTheme4() {
    const theme = React19.useContext(ThemeContext_default);
    if (false) {
      React19.useDebugValue(theme);
    }
    return theme;
  }

  // node_modules/@mui/private-theming/ThemeProvider/nested.js
  var hasSymbol = typeof Symbol === "function" && Symbol.for;
  var nested_default = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";

  // node_modules/@mui/private-theming/ThemeProvider/ThemeProvider.js
  var import_jsx_runtime4 = __toESM(require_jsx_runtime());
  function mergeOuterLocalTheme(outerTheme, localTheme) {
    if (typeof localTheme === "function") {
      const mergedTheme = localTheme(outerTheme);
      if (false) {
        if (!mergedTheme) {
          console.error(["MUI: You should return an object from your theme function, i.e.", "<ThemeProvider theme={() => ({})} />"].join("\n"));
        }
      }
      return mergedTheme;
    }
    return __spreadValues(__spreadValues({}, outerTheme), localTheme);
  }
  function ThemeProvider2(props) {
    const {
      children,
      theme: localTheme
    } = props;
    const outerTheme = useTheme4();
    if (false) {
      if (outerTheme === null && typeof localTheme === "function") {
        console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join("\n"));
      }
    }
    const theme = React20.useMemo(() => {
      const output = outerTheme === null ? __spreadValues({}, localTheme) : mergeOuterLocalTheme(outerTheme, localTheme);
      if (output != null) {
        output[nested_default] = outerTheme !== null;
      }
      return output;
    }, [localTheme, outerTheme]);
    return /* @__PURE__ */ (0, import_jsx_runtime4.jsx)(ThemeContext_default.Provider, {
      value: theme,
      children
    });
  }
  false ? ThemeProvider2.propTypes = {
    /**
     * Your component tree.
     */
    children: import_prop_types.default.node,
    /**
     * A theme object. You can provide a function to extend the outer theme.
     */
    theme: import_prop_types.default.oneOfType([import_prop_types.default.object, import_prop_types.default.func]).isRequired
  } : void 0;
  if (false) {
    false ? ThemeProvider2.propTypes = exactProp(ThemeProvider2.propTypes) : void 0;
  }
  var ThemeProvider_default = ThemeProvider2;

  // node_modules/@mui/system/esm/RtlProvider/index.js
  var React21 = __toESM(require_react());
  var import_jsx_runtime5 = __toESM(require_jsx_runtime());
  var RtlContext = /* @__PURE__ */ React21.createContext();
  function RtlProvider(_a) {
    var _b = _a, {
      value
    } = _b, props = __objRest(_b, [
      "value"
    ]);
    return /* @__PURE__ */ (0, import_jsx_runtime5.jsx)(RtlContext.Provider, __spreadValues({
      value: value != null ? value : true
    }, props));
  }
  false ? RtlProvider.propTypes = {
    children: import_prop_types.default.node,
    value: import_prop_types.default.bool
  } : void 0;
  var useRtl = () => {
    const value = React21.useContext(RtlContext);
    return value != null ? value : false;
  };
  var RtlProvider_default = RtlProvider;

  // node_modules/@mui/system/esm/DefaultPropsProvider/DefaultPropsProvider.js
  var React22 = __toESM(require_react());
  var import_jsx_runtime6 = __toESM(require_jsx_runtime());
  var PropsContext = /* @__PURE__ */ React22.createContext(void 0);
  function DefaultPropsProvider({
    value,
    children
  }) {
    return /* @__PURE__ */ (0, import_jsx_runtime6.jsx)(PropsContext.Provider, {
      value,
      children
    });
  }
  false ? DefaultPropsProvider.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * @ignore
     */
    children: import_prop_types.default.node,
    /**
     * @ignore
     */
    value: import_prop_types.default.object
  } : void 0;
  function getThemeProps2(params) {
    const {
      theme,
      name,
      props
    } = params;
    if (!theme || !theme.components || !theme.components[name]) {
      return props;
    }
    const config2 = theme.components[name];
    if (config2.defaultProps) {
      return resolveProps(config2.defaultProps, props);
    }
    if (!config2.styleOverrides && !config2.variants) {
      return resolveProps(config2, props);
    }
    return props;
  }
  function useDefaultProps({
    props,
    name
  }) {
    const ctx2 = React22.useContext(PropsContext);
    return getThemeProps2({
      props,
      name,
      theme: {
        components: ctx2
      }
    });
  }
  var DefaultPropsProvider_default = DefaultPropsProvider;

  // node_modules/@mui/system/esm/ThemeProvider/ThemeProvider.js
  var import_jsx_runtime7 = __toESM(require_jsx_runtime());
  var EMPTY_THEME = {};
  function useThemeScoping(themeId, upperTheme, localTheme, isPrivate = false) {
    return React23.useMemo(() => {
      const resolvedTheme = themeId ? upperTheme[themeId] || upperTheme : upperTheme;
      if (typeof localTheme === "function") {
        const mergedTheme = localTheme(resolvedTheme);
        const result = themeId ? __spreadProps(__spreadValues({}, upperTheme), {
          [themeId]: mergedTheme
        }) : mergedTheme;
        if (isPrivate) {
          return () => result;
        }
        return result;
      }
      return themeId ? __spreadProps(__spreadValues({}, upperTheme), {
        [themeId]: localTheme
      }) : __spreadValues(__spreadValues({}, upperTheme), localTheme);
    }, [themeId, upperTheme, localTheme, isPrivate]);
  }
  function ThemeProvider3(props) {
    const {
      children,
      theme: localTheme,
      themeId
    } = props;
    const upperTheme = useThemeWithoutDefault_default(EMPTY_THEME);
    const upperPrivateTheme = useTheme4() || EMPTY_THEME;
    if (false) {
      if (upperTheme === null && typeof localTheme === "function" || themeId && upperTheme && !upperTheme[themeId] && typeof localTheme === "function") {
        console.error(["MUI: You are providing a theme function prop to the ThemeProvider component:", "<ThemeProvider theme={outerTheme => outerTheme} />", "", "However, no outer theme is present.", "Make sure a theme is already injected higher in the React tree or provide a theme object."].join("\n"));
      }
    }
    const engineTheme = useThemeScoping(themeId, upperTheme, localTheme);
    const privateTheme = useThemeScoping(themeId, upperPrivateTheme, localTheme, true);
    const rtlValue = (themeId ? engineTheme[themeId] : engineTheme).direction === "rtl";
    return /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ThemeProvider_default, {
      theme: privateTheme,
      children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(ThemeContext.Provider, {
        value: engineTheme,
        children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(RtlProvider_default, {
          value: rtlValue,
          children: /* @__PURE__ */ (0, import_jsx_runtime7.jsx)(DefaultPropsProvider_default, {
            value: themeId ? engineTheme[themeId].components : engineTheme.components,
            children
          })
        })
      })
    });
  }
  false ? ThemeProvider3.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * Your component tree.
     */
    children: import_prop_types.default.node,
    /**
     * A theme object. You can provide a function to extend the outer theme.
     */
    theme: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]).isRequired,
    /**
     * The design system's unique id for getting the corresponded theme when there are multiple design systems.
     */
    themeId: import_prop_types.default.string
  } : void 0;
  if (false) {
    false ? ThemeProvider3.propTypes = exactProp(ThemeProvider3.propTypes) : void 0;
  }
  var ThemeProvider_default2 = ThemeProvider3;

  // node_modules/@mui/system/esm/memoTheme.js
  var arg = {
    theme: void 0
  };
  function unstable_memoTheme(styleFn) {
    let lastValue;
    let lastTheme;
    return function styleMemoized(props) {
      let value = lastValue;
      if (value === void 0 || props.theme !== lastTheme) {
        arg.theme = props.theme;
        value = preprocessStyles(styleFn(arg));
        lastValue = value;
        lastTheme = props.theme;
      }
      return value;
    };
  }

  // node_modules/@mui/system/esm/cssVars/createCssVarsProvider.js
  var React26 = __toESM(require_react());

  // node_modules/@mui/system/esm/InitColorSchemeScript/InitColorSchemeScript.js
  var React24 = __toESM(require_react());
  var import_jsx_runtime8 = __toESM(require_jsx_runtime());
  var DEFAULT_MODE_STORAGE_KEY = "mode";
  var DEFAULT_COLOR_SCHEME_STORAGE_KEY = "color-scheme";
  var DEFAULT_ATTRIBUTE = "data-color-scheme";
  function InitColorSchemeScript(options) {
    const {
      defaultMode = "system",
      defaultLightColorScheme = "light",
      defaultDarkColorScheme = "dark",
      modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
      colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
      attribute: initialAttribute = DEFAULT_ATTRIBUTE,
      colorSchemeNode = "document.documentElement",
      nonce
    } = options || {};
    let setter = "";
    let attribute = initialAttribute;
    if (initialAttribute === "class") {
      attribute = ".%s";
    }
    if (initialAttribute === "data") {
      attribute = "[data-%s]";
    }
    if (attribute.startsWith(".")) {
      const selector = attribute.substring(1);
      setter += `${colorSchemeNode}.classList.remove('${selector}'.replace('%s', light), '${selector}'.replace('%s', dark));
      ${colorSchemeNode}.classList.add('${selector}'.replace('%s', colorScheme));`;
    }
    const matches = attribute.match(/\[([^\]]+)\]/);
    if (matches) {
      const [attr, value] = matches[1].split("=");
      if (!value) {
        setter += `${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', light));
      ${colorSchemeNode}.removeAttribute('${attr}'.replace('%s', dark));`;
      }
      setter += `
      ${colorSchemeNode}.setAttribute('${attr}'.replace('%s', colorScheme), ${value ? `${value}.replace('%s', colorScheme)` : '""'});`;
    } else {
      setter += `${colorSchemeNode}.setAttribute('${attribute}', colorScheme);`;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime8.jsx)("script", {
      suppressHydrationWarning: true,
      nonce: typeof window === "undefined" ? nonce : "",
      dangerouslySetInnerHTML: {
        __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${modeStorageKey}') || '${defaultMode}';
  const dark = localStorage.getItem('${colorSchemeStorageKey}-dark') || '${defaultDarkColorScheme}';
  const light = localStorage.getItem('${colorSchemeStorageKey}-light') || '${defaultLightColorScheme}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${setter}
  }
} catch(e){}})();`
      }
    }, "mui-color-scheme-init");
  }

  // node_modules/@mui/system/esm/cssVars/useCurrentColorScheme.js
  var React25 = __toESM(require_react());

  // node_modules/@mui/system/esm/cssVars/localStorageManager.js
  function noop() {
  }
  var localStorageManager = ({
    key,
    storageWindow
  }) => {
    if (!storageWindow && typeof window !== "undefined") {
      storageWindow = window;
    }
    return {
      get(defaultValue) {
        if (typeof window === "undefined") {
          return void 0;
        }
        if (!storageWindow) {
          return defaultValue;
        }
        let value;
        try {
          value = storageWindow.localStorage.getItem(key);
        } catch (e) {
        }
        return value || defaultValue;
      },
      set: (value) => {
        if (storageWindow) {
          try {
            storageWindow.localStorage.setItem(key, value);
          } catch (e) {
          }
        }
      },
      subscribe: (handler) => {
        if (!storageWindow) {
          return noop;
        }
        const listener = (event) => {
          const value = event.newValue;
          if (event.key === key) {
            handler(value);
          }
        };
        storageWindow.addEventListener("storage", listener);
        return () => {
          storageWindow.removeEventListener("storage", listener);
        };
      }
    };
  };
  var localStorageManager_default = localStorageManager;

  // node_modules/@mui/system/esm/cssVars/useCurrentColorScheme.js
  function noop2() {
  }
  function getSystemMode(mode) {
    if (typeof window !== "undefined" && typeof window.matchMedia === "function" && mode === "system") {
      const mql = window.matchMedia("(prefers-color-scheme: dark)");
      if (mql.matches) {
        return "dark";
      }
      return "light";
    }
    return void 0;
  }
  function processState(state, callback) {
    if (state.mode === "light" || state.mode === "system" && state.systemMode === "light") {
      return callback("light");
    }
    if (state.mode === "dark" || state.mode === "system" && state.systemMode === "dark") {
      return callback("dark");
    }
    return void 0;
  }
  function getColorScheme(state) {
    return processState(state, (mode) => {
      if (mode === "light") {
        return state.lightColorScheme;
      }
      if (mode === "dark") {
        return state.darkColorScheme;
      }
      return void 0;
    });
  }
  function useCurrentColorScheme(options) {
    const {
      defaultMode = "light",
      defaultLightColorScheme,
      defaultDarkColorScheme,
      supportedColorSchemes = [],
      modeStorageKey = DEFAULT_MODE_STORAGE_KEY,
      colorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
      storageWindow = typeof window === "undefined" ? void 0 : window,
      storageManager = localStorageManager_default,
      noSsr = false
    } = options;
    const joinedColorSchemes = supportedColorSchemes.join(",");
    const isMultiSchemes = supportedColorSchemes.length > 1;
    const modeStorage = React25.useMemo(() => storageManager == null ? void 0 : storageManager({
      key: modeStorageKey,
      storageWindow
    }), [storageManager, modeStorageKey, storageWindow]);
    const lightStorage = React25.useMemo(() => storageManager == null ? void 0 : storageManager({
      key: `${colorSchemeStorageKey}-light`,
      storageWindow
    }), [storageManager, colorSchemeStorageKey, storageWindow]);
    const darkStorage = React25.useMemo(() => storageManager == null ? void 0 : storageManager({
      key: `${colorSchemeStorageKey}-dark`,
      storageWindow
    }), [storageManager, colorSchemeStorageKey, storageWindow]);
    const [state, setState] = React25.useState(() => {
      const initialMode = (modeStorage == null ? void 0 : modeStorage.get(defaultMode)) || defaultMode;
      const lightColorScheme = (lightStorage == null ? void 0 : lightStorage.get(defaultLightColorScheme)) || defaultLightColorScheme;
      const darkColorScheme = (darkStorage == null ? void 0 : darkStorage.get(defaultDarkColorScheme)) || defaultDarkColorScheme;
      return {
        mode: initialMode,
        systemMode: getSystemMode(initialMode),
        lightColorScheme,
        darkColorScheme
      };
    });
    const [isClient, setIsClient] = React25.useState(noSsr || !isMultiSchemes);
    React25.useEffect(() => {
      setIsClient(true);
    }, []);
    const colorScheme = getColorScheme(state);
    const setMode = React25.useCallback((mode) => {
      setState((currentState) => {
        if (mode === currentState.mode) {
          return currentState;
        }
        const newMode = mode != null ? mode : defaultMode;
        modeStorage == null ? void 0 : modeStorage.set(newMode);
        return __spreadProps(__spreadValues({}, currentState), {
          mode: newMode,
          systemMode: getSystemMode(newMode)
        });
      });
    }, [modeStorage, defaultMode]);
    const setColorScheme = React25.useCallback((value) => {
      if (!value) {
        setState((currentState) => {
          lightStorage == null ? void 0 : lightStorage.set(defaultLightColorScheme);
          darkStorage == null ? void 0 : darkStorage.set(defaultDarkColorScheme);
          return __spreadProps(__spreadValues({}, currentState), {
            lightColorScheme: defaultLightColorScheme,
            darkColorScheme: defaultDarkColorScheme
          });
        });
      } else if (typeof value === "string") {
        if (value && !joinedColorSchemes.includes(value)) {
          console.error(`\`${value}\` does not exist in \`theme.colorSchemes\`.`);
        } else {
          setState((currentState) => {
            const newState = __spreadValues({}, currentState);
            processState(currentState, (mode) => {
              if (mode === "light") {
                lightStorage == null ? void 0 : lightStorage.set(value);
                newState.lightColorScheme = value;
              }
              if (mode === "dark") {
                darkStorage == null ? void 0 : darkStorage.set(value);
                newState.darkColorScheme = value;
              }
            });
            return newState;
          });
        }
      } else {
        setState((currentState) => {
          const newState = __spreadValues({}, currentState);
          const newLightColorScheme = value.light === null ? defaultLightColorScheme : value.light;
          const newDarkColorScheme = value.dark === null ? defaultDarkColorScheme : value.dark;
          if (newLightColorScheme) {
            if (!joinedColorSchemes.includes(newLightColorScheme)) {
              console.error(`\`${newLightColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
            } else {
              newState.lightColorScheme = newLightColorScheme;
              lightStorage == null ? void 0 : lightStorage.set(newLightColorScheme);
            }
          }
          if (newDarkColorScheme) {
            if (!joinedColorSchemes.includes(newDarkColorScheme)) {
              console.error(`\`${newDarkColorScheme}\` does not exist in \`theme.colorSchemes\`.`);
            } else {
              newState.darkColorScheme = newDarkColorScheme;
              darkStorage == null ? void 0 : darkStorage.set(newDarkColorScheme);
            }
          }
          return newState;
        });
      }
    }, [joinedColorSchemes, lightStorage, darkStorage, defaultLightColorScheme, defaultDarkColorScheme]);
    const handleMediaQuery = React25.useCallback((event) => {
      if (state.mode === "system") {
        setState((currentState) => {
          const systemMode = (event == null ? void 0 : event.matches) ? "dark" : "light";
          if (currentState.systemMode === systemMode) {
            return currentState;
          }
          return __spreadProps(__spreadValues({}, currentState), {
            systemMode
          });
        });
      }
    }, [state.mode]);
    const mediaListener = React25.useRef(handleMediaQuery);
    mediaListener.current = handleMediaQuery;
    React25.useEffect(() => {
      if (typeof window.matchMedia !== "function" || !isMultiSchemes) {
        return void 0;
      }
      const handler = (...args) => mediaListener.current(...args);
      const media = window.matchMedia("(prefers-color-scheme: dark)");
      media.addListener(handler);
      handler(media);
      return () => {
        media.removeListener(handler);
      };
    }, [isMultiSchemes]);
    React25.useEffect(() => {
      if (isMultiSchemes) {
        const unsubscribeMode = (modeStorage == null ? void 0 : modeStorage.subscribe((value) => {
          if (!value || ["light", "dark", "system"].includes(value)) {
            setMode(value || defaultMode);
          }
        })) || noop2;
        const unsubscribeLight = (lightStorage == null ? void 0 : lightStorage.subscribe((value) => {
          if (!value || joinedColorSchemes.match(value)) {
            setColorScheme({
              light: value
            });
          }
        })) || noop2;
        const unsubscribeDark = (darkStorage == null ? void 0 : darkStorage.subscribe((value) => {
          if (!value || joinedColorSchemes.match(value)) {
            setColorScheme({
              dark: value
            });
          }
        })) || noop2;
        return () => {
          unsubscribeMode();
          unsubscribeLight();
          unsubscribeDark();
        };
      }
      return void 0;
    }, [setColorScheme, setMode, joinedColorSchemes, defaultMode, storageWindow, isMultiSchemes, modeStorage, lightStorage, darkStorage]);
    return __spreadProps(__spreadValues({}, state), {
      mode: isClient ? state.mode : void 0,
      systemMode: isClient ? state.systemMode : void 0,
      colorScheme: isClient ? colorScheme : void 0,
      setMode,
      setColorScheme
    });
  }

  // node_modules/@mui/system/esm/cssVars/createCssVarsProvider.js
  var import_jsx_runtime9 = __toESM(require_jsx_runtime());
  var DISABLE_CSS_TRANSITION = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
  function createCssVarsProvider(options) {
    const {
      themeId,
      /**
       * This `theme` object needs to follow a certain structure to
       * be used correctly by the finel `CssVarsProvider`. It should have a
       * `colorSchemes` key with the light and dark (and any other) palette.
       * It should also ideally have a vars object created using `prepareCssVars`.
       */
      theme: defaultTheme5 = {},
      modeStorageKey: defaultModeStorageKey = DEFAULT_MODE_STORAGE_KEY,
      colorSchemeStorageKey: defaultColorSchemeStorageKey = DEFAULT_COLOR_SCHEME_STORAGE_KEY,
      disableTransitionOnChange: designSystemTransitionOnChange = false,
      defaultColorScheme,
      resolveTheme
    } = options;
    const defaultContext = {
      allColorSchemes: [],
      colorScheme: void 0,
      darkColorScheme: void 0,
      lightColorScheme: void 0,
      mode: void 0,
      setColorScheme: () => {
      },
      setMode: () => {
      },
      systemMode: void 0
    };
    const ColorSchemeContext = /* @__PURE__ */ React26.createContext(void 0);
    if (false) {
      ColorSchemeContext.displayName = "ColorSchemeContext";
    }
    const useColorScheme2 = () => React26.useContext(ColorSchemeContext) || defaultContext;
    const defaultColorSchemes = {};
    const defaultComponents = {};
    function CssVarsProvider2(props) {
      var _a, _b, _c, _d;
      const {
        children,
        theme: themeProp,
        modeStorageKey = defaultModeStorageKey,
        colorSchemeStorageKey = defaultColorSchemeStorageKey,
        disableTransitionOnChange = designSystemTransitionOnChange,
        storageManager,
        storageWindow = typeof window === "undefined" ? void 0 : window,
        documentNode = typeof document === "undefined" ? void 0 : document,
        colorSchemeNode = typeof document === "undefined" ? void 0 : document.documentElement,
        disableNestedContext = false,
        disableStyleSheetGeneration = false,
        defaultMode: initialMode = "system",
        noSsr
      } = props;
      const hasMounted = React26.useRef(false);
      const upperTheme = useTheme4();
      const ctx2 = React26.useContext(ColorSchemeContext);
      const nested = !!ctx2 && !disableNestedContext;
      const initialTheme = React26.useMemo(() => {
        if (themeProp) {
          return themeProp;
        }
        return typeof defaultTheme5 === "function" ? defaultTheme5() : defaultTheme5;
      }, [themeProp]);
      const scopedTheme = initialTheme[themeId];
      const restThemeProp = scopedTheme || initialTheme;
      const {
        colorSchemes = defaultColorSchemes,
        components = defaultComponents,
        cssVarPrefix
      } = restThemeProp;
      const joinedColorSchemes = Object.keys(colorSchemes).filter((k) => !!colorSchemes[k]).join(",");
      const allColorSchemes = React26.useMemo(() => joinedColorSchemes.split(","), [joinedColorSchemes]);
      const defaultLightColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
      const defaultDarkColorScheme2 = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
      const defaultMode = colorSchemes[defaultLightColorScheme2] && colorSchemes[defaultDarkColorScheme2] ? initialMode : ((_b = (_a = colorSchemes[restThemeProp.defaultColorScheme]) == null ? void 0 : _a.palette) == null ? void 0 : _b.mode) || ((_c = restThemeProp.palette) == null ? void 0 : _c.mode);
      const {
        mode: stateMode,
        setMode,
        systemMode,
        lightColorScheme,
        darkColorScheme,
        colorScheme: stateColorScheme,
        setColorScheme
      } = useCurrentColorScheme({
        supportedColorSchemes: allColorSchemes,
        defaultLightColorScheme: defaultLightColorScheme2,
        defaultDarkColorScheme: defaultDarkColorScheme2,
        modeStorageKey,
        colorSchemeStorageKey,
        defaultMode,
        storageManager,
        storageWindow,
        noSsr
      });
      let mode = stateMode;
      let colorScheme = stateColorScheme;
      if (nested) {
        mode = ctx2.mode;
        colorScheme = ctx2.colorScheme;
      }
      const memoTheme2 = React26.useMemo(() => {
        var _a2;
        const calculatedColorScheme = colorScheme || restThemeProp.defaultColorScheme;
        const themeVars = ((_a2 = restThemeProp.generateThemeVars) == null ? void 0 : _a2.call(restThemeProp)) || restThemeProp.vars;
        const theme = __spreadProps(__spreadValues({}, restThemeProp), {
          components,
          colorSchemes,
          cssVarPrefix,
          vars: themeVars
        });
        if (typeof theme.generateSpacing === "function") {
          theme.spacing = theme.generateSpacing();
        }
        if (calculatedColorScheme) {
          const scheme = colorSchemes[calculatedColorScheme];
          if (scheme && typeof scheme === "object") {
            Object.keys(scheme).forEach((schemeKey) => {
              if (scheme[schemeKey] && typeof scheme[schemeKey] === "object") {
                theme[schemeKey] = __spreadValues(__spreadValues({}, theme[schemeKey]), scheme[schemeKey]);
              } else {
                theme[schemeKey] = scheme[schemeKey];
              }
            });
          }
        }
        return resolveTheme ? resolveTheme(theme) : theme;
      }, [restThemeProp, colorScheme, components, colorSchemes, cssVarPrefix]);
      const colorSchemeSelector = restThemeProp.colorSchemeSelector;
      useEnhancedEffect_default(() => {
        if (colorScheme && colorSchemeNode && colorSchemeSelector && colorSchemeSelector !== "media") {
          const selector = colorSchemeSelector;
          let rule = colorSchemeSelector;
          if (selector === "class") {
            rule = `.%s`;
          }
          if (selector === "data") {
            rule = `[data-%s]`;
          }
          if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
            rule = `[${selector}="%s"]`;
          }
          if (rule.startsWith(".")) {
            colorSchemeNode.classList.remove(...allColorSchemes.map((scheme) => rule.substring(1).replace("%s", scheme)));
            colorSchemeNode.classList.add(rule.substring(1).replace("%s", colorScheme));
          } else {
            const matches = rule.replace("%s", colorScheme).match(/\[([^\]]+)\]/);
            if (matches) {
              const [attr, value] = matches[1].split("=");
              if (!value) {
                allColorSchemes.forEach((scheme) => {
                  colorSchemeNode.removeAttribute(attr.replace(colorScheme, scheme));
                });
              }
              colorSchemeNode.setAttribute(attr, value ? value.replace(/"|'/g, "") : "");
            } else {
              colorSchemeNode.setAttribute(rule, colorScheme);
            }
          }
        }
      }, [colorScheme, colorSchemeSelector, colorSchemeNode, allColorSchemes]);
      React26.useEffect(() => {
        let timer;
        if (disableTransitionOnChange && hasMounted.current && documentNode) {
          const css2 = documentNode.createElement("style");
          css2.appendChild(documentNode.createTextNode(DISABLE_CSS_TRANSITION));
          documentNode.head.appendChild(css2);
          (() => window.getComputedStyle(documentNode.body))();
          timer = setTimeout(() => {
            documentNode.head.removeChild(css2);
          }, 1);
        }
        return () => {
          clearTimeout(timer);
        };
      }, [colorScheme, disableTransitionOnChange, documentNode]);
      React26.useEffect(() => {
        hasMounted.current = true;
        return () => {
          hasMounted.current = false;
        };
      }, []);
      const contextValue = React26.useMemo(() => ({
        allColorSchemes,
        colorScheme,
        darkColorScheme,
        lightColorScheme,
        mode,
        setColorScheme,
        setMode: true ? setMode : (newMode) => {
          if (memoTheme2.colorSchemeSelector === "media") {
            console.error(["MUI: The `setMode` function has no effect if `colorSchemeSelector` is `media` (`media` is the default value).", "To toggle the mode manually, please configure `colorSchemeSelector` to use a class or data attribute.", "To learn more, visit https://mui.com/material-ui/customization/css-theme-variables/configuration/#toggling-dark-mode-manually"].join("\n"));
          }
          setMode(newMode);
        },
        systemMode
      }), [allColorSchemes, colorScheme, darkColorScheme, lightColorScheme, mode, setColorScheme, setMode, systemMode, memoTheme2.colorSchemeSelector]);
      let shouldGenerateStyleSheet = true;
      if (disableStyleSheetGeneration || restThemeProp.cssVariables === false || nested && (upperTheme == null ? void 0 : upperTheme.cssVarPrefix) === cssVarPrefix) {
        shouldGenerateStyleSheet = false;
      }
      const element = /* @__PURE__ */ (0, import_jsx_runtime9.jsxs)(React26.Fragment, {
        children: [/* @__PURE__ */ (0, import_jsx_runtime9.jsx)(ThemeProvider_default2, {
          themeId: scopedTheme ? themeId : void 0,
          theme: memoTheme2,
          children
        }), shouldGenerateStyleSheet && /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(GlobalStyles, {
          styles: ((_d = memoTheme2.generateStyleSheets) == null ? void 0 : _d.call(memoTheme2)) || []
        })]
      });
      if (nested) {
        return element;
      }
      return /* @__PURE__ */ (0, import_jsx_runtime9.jsx)(ColorSchemeContext.Provider, {
        value: contextValue,
        children: element
      });
    }
    false ? CssVarsProvider2.propTypes = {
      /**
       * The component tree.
       */
      children: import_prop_types.default.node,
      /**
       * The node used to attach the color-scheme attribute
       */
      colorSchemeNode: import_prop_types.default.any,
      /**
       * localStorage key used to store `colorScheme`
       */
      colorSchemeStorageKey: import_prop_types.default.string,
      /**
       * The default mode when the storage is empty,
       * require the theme to have `colorSchemes` with light and dark.
       */
      defaultMode: import_prop_types.default.string,
      /**
       * If `true`, the provider creates its own context and generate stylesheet as if it is a root `CssVarsProvider`.
       */
      disableNestedContext: import_prop_types.default.bool,
      /**
       * If `true`, the style sheet won't be generated.
       *
       * This is useful for controlling nested CssVarsProvider behavior.
       */
      disableStyleSheetGeneration: import_prop_types.default.bool,
      /**
       * Disable CSS transitions when switching between modes or color schemes.
       */
      disableTransitionOnChange: import_prop_types.default.bool,
      /**
       * The document to attach the attribute to.
       */
      documentNode: import_prop_types.default.any,
      /**
       * The key in the local storage used to store current color scheme.
       */
      modeStorageKey: import_prop_types.default.string,
      /**
       * If `true`, the mode will be the same value as the storage without an extra rerendering after the hydration.
       * You should use this option in conjuction with `InitColorSchemeScript` component.
       */
      noSsr: import_prop_types.default.bool,
      /**
       * The storage manager to be used for storing the mode and color scheme
       * @default using `window.localStorage`
       */
      storageManager: import_prop_types.default.func,
      /**
       * The window that attaches the 'storage' event listener.
       * @default window
       */
      storageWindow: import_prop_types.default.any,
      /**
       * The calculated theme object that will be passed through context.
       */
      theme: import_prop_types.default.object
    } : void 0;
    const defaultLightColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.light;
    const defaultDarkColorScheme = typeof defaultColorScheme === "string" ? defaultColorScheme : defaultColorScheme.dark;
    const getInitColorSchemeScript = (params) => InitColorSchemeScript(__spreadValues({
      colorSchemeStorageKey: defaultColorSchemeStorageKey,
      defaultLightColorScheme,
      defaultDarkColorScheme,
      modeStorageKey: defaultModeStorageKey
    }, params));
    return {
      CssVarsProvider: CssVarsProvider2,
      useColorScheme: useColorScheme2,
      getInitColorSchemeScript
    };
  }

  // node_modules/@mui/system/esm/cssVars/createGetCssVar.js
  function createGetCssVar(prefix3 = "") {
    function appendVar(...vars) {
      if (!vars.length) {
        return "";
      }
      const value = vars[0];
      if (typeof value === "string" && !value.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/)) {
        return `, var(--${prefix3 ? `${prefix3}-` : ""}${value}${appendVar(...vars.slice(1))})`;
      }
      return `, ${value}`;
    }
    const getCssVar = (field, ...fallbacks) => {
      return `var(--${prefix3 ? `${prefix3}-` : ""}${field}${appendVar(...fallbacks)})`;
    };
    return getCssVar;
  }

  // node_modules/@mui/system/esm/cssVars/cssVarsParser.js
  var assignNestedKeys = (obj, keys, value, arrayKeys = []) => {
    let temp = obj;
    keys.forEach((k, index) => {
      if (index === keys.length - 1) {
        if (Array.isArray(temp)) {
          temp[Number(k)] = value;
        } else if (temp && typeof temp === "object") {
          temp[k] = value;
        }
      } else if (temp && typeof temp === "object") {
        if (!temp[k]) {
          temp[k] = arrayKeys.includes(k) ? [] : {};
        }
        temp = temp[k];
      }
    });
  };
  var walkObjectDeep = (obj, callback, shouldSkipPaths) => {
    function recurse(object, parentKeys = [], arrayKeys = []) {
      Object.entries(object).forEach(([key, value]) => {
        if (!shouldSkipPaths || shouldSkipPaths && !shouldSkipPaths([...parentKeys, key])) {
          if (value !== void 0 && value !== null) {
            if (typeof value === "object" && Object.keys(value).length > 0) {
              recurse(value, [...parentKeys, key], Array.isArray(value) ? [...arrayKeys, key] : arrayKeys);
            } else {
              callback([...parentKeys, key], value, arrayKeys);
            }
          }
        }
      });
    }
    recurse(obj);
  };
  var getCssValue = (keys, value) => {
    if (typeof value === "number") {
      if (["lineHeight", "fontWeight", "opacity", "zIndex"].some((prop) => keys.includes(prop))) {
        return value;
      }
      const lastKey = keys[keys.length - 1];
      if (lastKey.toLowerCase().includes("opacity")) {
        return value;
      }
      return `${value}px`;
    }
    return value;
  };
  function cssVarsParser(theme, options) {
    const {
      prefix: prefix3,
      shouldSkipGeneratingVar: shouldSkipGeneratingVar2
    } = options || {};
    const css2 = {};
    const vars = {};
    const varsWithDefaults = {};
    walkObjectDeep(
      theme,
      (keys, value, arrayKeys) => {
        if (typeof value === "string" || typeof value === "number") {
          if (!shouldSkipGeneratingVar2 || !shouldSkipGeneratingVar2(keys, value)) {
            const cssVar = `--${prefix3 ? `${prefix3}-` : ""}${keys.join("-")}`;
            const resolvedValue = getCssValue(keys, value);
            Object.assign(css2, {
              [cssVar]: resolvedValue
            });
            assignNestedKeys(vars, keys, `var(${cssVar})`, arrayKeys);
            assignNestedKeys(varsWithDefaults, keys, `var(${cssVar}, ${resolvedValue})`, arrayKeys);
          }
        }
      },
      (keys) => keys[0] === "vars"
      // skip 'vars/*' paths
    );
    return {
      css: css2,
      vars,
      varsWithDefaults
    };
  }

  // node_modules/@mui/system/esm/cssVars/prepareCssVars.js
  function prepareCssVars(theme, parserConfig = {}) {
    const {
      getSelector = defaultGetSelector,
      disableCssColorScheme,
      colorSchemeSelector: selector
    } = parserConfig;
    const _a = theme, {
      colorSchemes = {},
      components,
      defaultColorScheme = "light"
    } = _a, otherTheme = __objRest(_a, [
      "colorSchemes",
      "components",
      "defaultColorScheme"
    ]);
    const {
      vars: rootVars,
      css: rootCss,
      varsWithDefaults: rootVarsWithDefaults
    } = cssVarsParser(otherTheme, parserConfig);
    let themeVars = rootVarsWithDefaults;
    const colorSchemesMap = {};
    const _b = colorSchemes, {
      [defaultColorScheme]: defaultScheme
    } = _b, otherColorSchemes = __objRest(_b, [
      __restKey(defaultColorScheme)
    ]);
    Object.entries(otherColorSchemes || {}).forEach(([key, scheme]) => {
      const {
        vars,
        css: css2,
        varsWithDefaults
      } = cssVarsParser(scheme, parserConfig);
      themeVars = deepmerge(themeVars, varsWithDefaults);
      colorSchemesMap[key] = {
        css: css2,
        vars
      };
    });
    if (defaultScheme) {
      const {
        css: css2,
        vars,
        varsWithDefaults
      } = cssVarsParser(defaultScheme, parserConfig);
      themeVars = deepmerge(themeVars, varsWithDefaults);
      colorSchemesMap[defaultColorScheme] = {
        css: css2,
        vars
      };
    }
    function defaultGetSelector(colorScheme, cssObject) {
      var _a2, _b2;
      let rule = selector;
      if (selector === "class") {
        rule = ".%s";
      }
      if (selector === "data") {
        rule = "[data-%s]";
      }
      if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
        rule = `[${selector}="%s"]`;
      }
      if (colorScheme) {
        if (rule === "media") {
          if (theme.defaultColorScheme === colorScheme) {
            return ":root";
          }
          const mode = ((_b2 = (_a2 = colorSchemes[colorScheme]) == null ? void 0 : _a2.palette) == null ? void 0 : _b2.mode) || colorScheme;
          return {
            [`@media (prefers-color-scheme: ${mode})`]: {
              ":root": cssObject
            }
          };
        }
        if (rule) {
          if (theme.defaultColorScheme === colorScheme) {
            return `:root, ${rule.replace("%s", String(colorScheme))}`;
          }
          return rule.replace("%s", String(colorScheme));
        }
      }
      return ":root";
    }
    const generateThemeVars = () => {
      let vars = __spreadValues({}, rootVars);
      Object.entries(colorSchemesMap).forEach(([, {
        vars: schemeVars
      }]) => {
        vars = deepmerge(vars, schemeVars);
      });
      return vars;
    };
    const generateStyleSheets = () => {
      var _b2, _c;
      const stylesheets = [];
      const colorScheme = theme.defaultColorScheme || "light";
      function insertStyleSheet(key, css2) {
        if (Object.keys(css2).length) {
          stylesheets.push(typeof key === "string" ? {
            [key]: __spreadValues({}, css2)
          } : key);
        }
      }
      insertStyleSheet(getSelector(void 0, __spreadValues({}, rootCss)), rootCss);
      const _a2 = colorSchemesMap, {
        [colorScheme]: defaultSchemeVal
      } = _a2, other = __objRest(_a2, [
        __restKey(colorScheme)
      ]);
      if (defaultSchemeVal) {
        const {
          css: css2
        } = defaultSchemeVal;
        const cssColorSheme = (_c = (_b2 = colorSchemes[colorScheme]) == null ? void 0 : _b2.palette) == null ? void 0 : _c.mode;
        const finalCss = !disableCssColorScheme && cssColorSheme ? __spreadValues({
          colorScheme: cssColorSheme
        }, css2) : __spreadValues({}, css2);
        insertStyleSheet(getSelector(colorScheme, __spreadValues({}, finalCss)), finalCss);
      }
      Object.entries(other).forEach(([key, {
        css: css2
      }]) => {
        var _a3, _b3;
        const cssColorSheme = (_b3 = (_a3 = colorSchemes[key]) == null ? void 0 : _a3.palette) == null ? void 0 : _b3.mode;
        const finalCss = !disableCssColorScheme && cssColorSheme ? __spreadValues({
          colorScheme: cssColorSheme
        }, css2) : __spreadValues({}, css2);
        insertStyleSheet(getSelector(key, __spreadValues({}, finalCss)), finalCss);
      });
      return stylesheets;
    };
    return {
      vars: themeVars,
      generateThemeVars,
      generateStyleSheets
    };
  }
  var prepareCssVars_default = prepareCssVars;

  // node_modules/@mui/system/esm/cssVars/getColorSchemeSelector.js
  function createGetColorSchemeSelector(selector) {
    return function getColorSchemeSelector(colorScheme) {
      if (selector === "media") {
        if (false) {
          if (colorScheme !== "light" && colorScheme !== "dark") {
            console.error(`MUI: @media (prefers-color-scheme) supports only 'light' or 'dark', but receive '${colorScheme}'.`);
          }
        }
        return `@media (prefers-color-scheme: ${colorScheme})`;
      }
      if (selector) {
        if (selector.startsWith("data-") && !selector.includes("%s")) {
          return `[${selector}="${colorScheme}"] &`;
        }
        if (selector === "class") {
          return `.${colorScheme} &`;
        }
        if (selector === "data") {
          return `[data-${colorScheme}] &`;
        }
        return `${selector.replace("%s", colorScheme)} &`;
      }
      return "&";
    };
  }

  // node_modules/@mui/system/esm/Grid/createGrid.js
  var React27 = __toESM(require_react());

  // node_modules/@mui/system/esm/Grid/traverseBreakpoints.js
  var filterBreakpointKeys = (breakpointsKeys, responsiveKeys) => breakpointsKeys.filter((key) => responsiveKeys.includes(key));
  var traverseBreakpoints = (breakpoints, responsive, iterator) => {
    const smallestBreakpoint = breakpoints.keys[0];
    if (Array.isArray(responsive)) {
      responsive.forEach((breakpointValue, index) => {
        iterator((responsiveStyles, style4) => {
          if (index <= breakpoints.keys.length - 1) {
            if (index === 0) {
              Object.assign(responsiveStyles, style4);
            } else {
              responsiveStyles[breakpoints.up(breakpoints.keys[index])] = style4;
            }
          }
        }, breakpointValue);
      });
    } else if (responsive && typeof responsive === "object") {
      const keys = Object.keys(responsive).length > breakpoints.keys.length ? breakpoints.keys : filterBreakpointKeys(breakpoints.keys, Object.keys(responsive));
      keys.forEach((key) => {
        if (breakpoints.keys.includes(key)) {
          const breakpointValue = responsive[key];
          if (breakpointValue !== void 0) {
            iterator((responsiveStyles, style4) => {
              if (smallestBreakpoint === key) {
                Object.assign(responsiveStyles, style4);
              } else {
                responsiveStyles[breakpoints.up(key)] = style4;
              }
            }, breakpointValue);
          }
        }
      });
    } else if (typeof responsive === "number" || typeof responsive === "string") {
      iterator((responsiveStyles, style4) => {
        Object.assign(responsiveStyles, style4);
      }, responsive);
    }
  };

  // node_modules/@mui/system/esm/Grid/gridGenerator.js
  function getSelfSpacingVar(axis) {
    return `--Grid-${axis}Spacing`;
  }
  function getParentSpacingVar(axis) {
    return `--Grid-parent-${axis}Spacing`;
  }
  var selfColumnsVar = "--Grid-columns";
  var parentColumnsVar = "--Grid-parent-columns";
  var generateGridSizeStyles = ({
    theme,
    ownerState
  }) => {
    const styles2 = {};
    traverseBreakpoints(theme.breakpoints, ownerState.size, (appendStyle, value) => {
      let style4 = {};
      if (value === "grow") {
        style4 = {
          flexBasis: 0,
          flexGrow: 1,
          maxWidth: "100%"
        };
      }
      if (value === "auto") {
        style4 = {
          flexBasis: "auto",
          flexGrow: 0,
          flexShrink: 0,
          maxWidth: "none",
          width: "auto"
        };
      }
      if (typeof value === "number") {
        style4 = {
          flexGrow: 0,
          flexBasis: "auto",
          width: `calc(100% * ${value} / var(${parentColumnsVar}) - (var(${parentColumnsVar}) - ${value}) * (var(${getParentSpacingVar("column")}) / var(${parentColumnsVar})))`
        };
      }
      appendStyle(styles2, style4);
    });
    return styles2;
  };
  var generateGridOffsetStyles = ({
    theme,
    ownerState
  }) => {
    const styles2 = {};
    traverseBreakpoints(theme.breakpoints, ownerState.offset, (appendStyle, value) => {
      let style4 = {};
      if (value === "auto") {
        style4 = {
          marginLeft: "auto"
        };
      }
      if (typeof value === "number") {
        style4 = {
          marginLeft: value === 0 ? "0px" : `calc(100% * ${value} / var(${parentColumnsVar}) + var(${getParentSpacingVar("column")}) * ${value} / var(${parentColumnsVar}))`
        };
      }
      appendStyle(styles2, style4);
    });
    return styles2;
  };
  var generateGridColumnsStyles = ({
    theme,
    ownerState
  }) => {
    if (!ownerState.container) {
      return {};
    }
    const styles2 = {
      [selfColumnsVar]: 12
    };
    traverseBreakpoints(theme.breakpoints, ownerState.columns, (appendStyle, value) => {
      const columns = value != null ? value : 12;
      appendStyle(styles2, {
        [selfColumnsVar]: columns,
        "> *": {
          [parentColumnsVar]: columns
        }
      });
    });
    return styles2;
  };
  var generateGridRowSpacingStyles = ({
    theme,
    ownerState
  }) => {
    if (!ownerState.container) {
      return {};
    }
    const styles2 = {};
    traverseBreakpoints(theme.breakpoints, ownerState.rowSpacing, (appendStyle, value) => {
      var _a;
      const spacing2 = typeof value === "string" ? value : (_a = theme.spacing) == null ? void 0 : _a.call(theme, value);
      appendStyle(styles2, {
        [getSelfSpacingVar("row")]: spacing2,
        "> *": {
          [getParentSpacingVar("row")]: spacing2
        }
      });
    });
    return styles2;
  };
  var generateGridColumnSpacingStyles = ({
    theme,
    ownerState
  }) => {
    if (!ownerState.container) {
      return {};
    }
    const styles2 = {};
    traverseBreakpoints(theme.breakpoints, ownerState.columnSpacing, (appendStyle, value) => {
      var _a;
      const spacing2 = typeof value === "string" ? value : (_a = theme.spacing) == null ? void 0 : _a.call(theme, value);
      appendStyle(styles2, {
        [getSelfSpacingVar("column")]: spacing2,
        "> *": {
          [getParentSpacingVar("column")]: spacing2
        }
      });
    });
    return styles2;
  };
  var generateGridDirectionStyles = ({
    theme,
    ownerState
  }) => {
    if (!ownerState.container) {
      return {};
    }
    const styles2 = {};
    traverseBreakpoints(theme.breakpoints, ownerState.direction, (appendStyle, value) => {
      appendStyle(styles2, {
        flexDirection: value
      });
    });
    return styles2;
  };
  var generateGridStyles = ({
    ownerState
  }) => {
    return __spreadValues({
      minWidth: 0,
      boxSizing: "border-box"
    }, ownerState.container && __spreadProps(__spreadValues({
      display: "flex",
      flexWrap: "wrap"
    }, ownerState.wrap && ownerState.wrap !== "wrap" && {
      flexWrap: ownerState.wrap
    }), {
      gap: `var(${getSelfSpacingVar("row")}) var(${getSelfSpacingVar("column")})`
    }));
  };
  var generateSizeClassNames = (size) => {
    const classNames = [];
    Object.entries(size).forEach(([key, value]) => {
      if (value !== false && value !== void 0) {
        classNames.push(`grid-${key}-${String(value)}`);
      }
    });
    return classNames;
  };
  var generateSpacingClassNames = (spacing2, smallestBreakpoint = "xs") => {
    function isValidSpacing(val) {
      if (val === void 0) {
        return false;
      }
      return typeof val === "string" && !Number.isNaN(Number(val)) || typeof val === "number" && val > 0;
    }
    if (isValidSpacing(spacing2)) {
      return [`spacing-${smallestBreakpoint}-${String(spacing2)}`];
    }
    if (typeof spacing2 === "object" && !Array.isArray(spacing2)) {
      const classNames = [];
      Object.entries(spacing2).forEach(([key, value]) => {
        if (isValidSpacing(value)) {
          classNames.push(`spacing-${key}-${String(value)}`);
        }
      });
      return classNames;
    }
    return [];
  };
  var generateDirectionClasses = (direction) => {
    if (direction === void 0) {
      return [];
    }
    if (typeof direction === "object") {
      return Object.entries(direction).map(([key, value]) => `direction-${key}-${value}`);
    }
    return [`direction-xs-${String(direction)}`];
  };

  // node_modules/@mui/system/esm/Grid/deleteLegacyGridProps.js
  function deleteLegacyGridProps(props, breakpoints) {
    const propsToWarn = [];
    if (props.item !== void 0) {
      delete props.item;
      propsToWarn.push("item");
    }
    if (props.zeroMinWidth !== void 0) {
      delete props.zeroMinWidth;
      propsToWarn.push("zeroMinWidth");
    }
    breakpoints.keys.forEach((breakpoint) => {
      if (props[breakpoint] !== void 0) {
        propsToWarn.push(breakpoint);
        delete props[breakpoint];
      }
    });
    if (false) {
      propsToWarn.forEach((prop) => {
        if (!warnedAboutProps.includes(prop)) {
          warnedAboutProps.push(prop);
          console.warn(`MUI Grid2: ${getLegacyGridWarning(prop)}
`);
        }
      });
    }
  }

  // node_modules/@mui/system/esm/Grid/createGrid.js
  var import_jsx_runtime10 = __toESM(require_jsx_runtime());
  var defaultTheme = createTheme_default();
  var defaultCreateStyledComponent = styled_default("div", {
    name: "MuiGrid",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  });
  function useThemePropsDefault(props) {
    return useThemeProps({
      props,
      name: "MuiGrid",
      defaultTheme
    });
  }
  function createGrid(options = {}) {
    const {
      // This will allow adding custom styled fn (for example for custom sx style function)
      createStyledComponent = defaultCreateStyledComponent,
      useThemeProps: useThemeProps3 = useThemePropsDefault,
      useTheme: useTheme6 = useTheme_default,
      componentName = "MuiGrid"
    } = options;
    const useUtilityClasses30 = (ownerState, theme) => {
      const {
        container: container2,
        direction,
        spacing: spacing2,
        wrap,
        size
      } = ownerState;
      const slots = {
        root: ["root", container2 && "container", wrap !== "wrap" && `wrap-xs-${String(wrap)}`, ...generateDirectionClasses(direction), ...generateSizeClassNames(size), ...container2 ? generateSpacingClassNames(spacing2, theme.breakpoints.keys[0]) : []]
      };
      return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
    };
    function parseResponsiveProp(propValue, breakpoints, shouldUseValue = () => true) {
      const parsedProp = {};
      if (propValue === null) {
        return parsedProp;
      }
      if (Array.isArray(propValue)) {
        propValue.forEach((value, index) => {
          if (value !== null && shouldUseValue(value) && breakpoints.keys[index]) {
            parsedProp[breakpoints.keys[index]] = value;
          }
        });
      } else if (typeof propValue === "object") {
        Object.keys(propValue).forEach((key) => {
          const value = propValue[key];
          if (value !== null && value !== void 0 && shouldUseValue(value)) {
            parsedProp[key] = value;
          }
        });
      } else {
        parsedProp[breakpoints.keys[0]] = propValue;
      }
      return parsedProp;
    }
    const GridRoot2 = createStyledComponent(generateGridColumnsStyles, generateGridColumnSpacingStyles, generateGridRowSpacingStyles, generateGridSizeStyles, generateGridDirectionStyles, generateGridStyles, generateGridOffsetStyles);
    const Grid = /* @__PURE__ */ React27.forwardRef(function Grid3(inProps, ref) {
      var _b, _c, _d, _e, _f, _g;
      const theme = useTheme6();
      const themeProps = useThemeProps3(inProps);
      const props = extendSxProp(themeProps);
      deleteLegacyGridProps(props, theme.breakpoints);
      const _a = props, {
        className,
        children,
        columns: columnsProp = 12,
        container: container2 = false,
        component = "div",
        direction = "row",
        wrap = "wrap",
        size: sizeProp = {},
        offset: offsetProp = {},
        spacing: spacingProp = 0,
        rowSpacing: rowSpacingProp = spacingProp,
        columnSpacing: columnSpacingProp = spacingProp,
        unstable_level: level = 0
      } = _a, other = __objRest(_a, [
        "className",
        "children",
        "columns",
        "container",
        "component",
        "direction",
        "wrap",
        "size",
        "offset",
        "spacing",
        "rowSpacing",
        "columnSpacing",
        "unstable_level"
      ]);
      const size = parseResponsiveProp(sizeProp, theme.breakpoints, (val) => val !== false);
      const offset2 = parseResponsiveProp(offsetProp, theme.breakpoints);
      const columns = (_b = inProps.columns) != null ? _b : level ? void 0 : columnsProp;
      const spacing2 = (_c = inProps.spacing) != null ? _c : level ? void 0 : spacingProp;
      const rowSpacing = (_e = (_d = inProps.rowSpacing) != null ? _d : inProps.spacing) != null ? _e : level ? void 0 : rowSpacingProp;
      const columnSpacing = (_g = (_f = inProps.columnSpacing) != null ? _f : inProps.spacing) != null ? _g : level ? void 0 : columnSpacingProp;
      const ownerState = __spreadProps(__spreadValues({}, props), {
        level,
        columns,
        container: container2,
        direction,
        wrap,
        spacing: spacing2,
        rowSpacing,
        columnSpacing,
        size,
        offset: offset2
      });
      const classes = useUtilityClasses30(ownerState, theme);
      return /* @__PURE__ */ (0, import_jsx_runtime10.jsx)(GridRoot2, __spreadProps(__spreadValues({
        ref,
        as: component,
        ownerState,
        className: clsx_default(classes.root, className)
      }, other), {
        children: React27.Children.map(children, (child) => {
          var _a2, _b2;
          if (/* @__PURE__ */ React27.isValidElement(child) && isMuiElement(child, ["Grid"]) && container2 && child.props.container) {
            return /* @__PURE__ */ React27.cloneElement(child, {
              unstable_level: (_b2 = (_a2 = child.props) == null ? void 0 : _a2.unstable_level) != null ? _b2 : level + 1
            });
          }
          return child;
        })
      }));
    });
    false ? Grid.propTypes = {
      children: import_prop_types.default.node,
      className: import_prop_types.default.string,
      columns: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.number), import_prop_types.default.number, import_prop_types.default.object]),
      columnSpacing: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])), import_prop_types.default.number, import_prop_types.default.object, import_prop_types.default.string]),
      component: import_prop_types.default.elementType,
      container: import_prop_types.default.bool,
      direction: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types.default.arrayOf(import_prop_types.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types.default.object]),
      offset: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.number, import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.number])), import_prop_types.default.object]),
      rowSpacing: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])), import_prop_types.default.number, import_prop_types.default.object, import_prop_types.default.string]),
      size: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.bool, import_prop_types.default.number, import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.bool, import_prop_types.default.number])), import_prop_types.default.object]),
      spacing: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])), import_prop_types.default.number, import_prop_types.default.object, import_prop_types.default.string]),
      sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
      wrap: import_prop_types.default.oneOf(["nowrap", "wrap-reverse", "wrap"])
    } : void 0;
    Grid.muiName = "Grid";
    return Grid;
  }

  // node_modules/@mui/system/esm/Stack/createStack.js
  var React28 = __toESM(require_react());
  var import_jsx_runtime11 = __toESM(require_jsx_runtime());
  var defaultTheme2 = createTheme_default();
  var defaultCreateStyledComponent2 = styled_default("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  });
  function useThemePropsDefault2(props) {
    return useThemeProps({
      props,
      name: "MuiStack",
      defaultTheme: defaultTheme2
    });
  }
  function joinChildren(children, separator) {
    const childrenArray = React28.Children.toArray(children).filter(Boolean);
    return childrenArray.reduce((output, child, index) => {
      output.push(child);
      if (index < childrenArray.length - 1) {
        output.push(/* @__PURE__ */ React28.cloneElement(separator, {
          key: `separator-${index}`
        }));
      }
      return output;
    }, []);
  }
  var getSideFromDirection = (direction) => {
    return {
      row: "Left",
      "row-reverse": "Right",
      column: "Top",
      "column-reverse": "Bottom"
    }[direction];
  };
  var style3 = ({
    ownerState,
    theme
  }) => {
    let styles2 = __spreadValues({
      display: "flex",
      flexDirection: "column"
    }, handleBreakpoints({
      theme
    }, resolveBreakpointValues({
      values: ownerState.direction,
      breakpoints: theme.breakpoints.values
    }), (propValue) => ({
      flexDirection: propValue
    })));
    if (ownerState.spacing) {
      const transformer3 = createUnarySpacing(theme);
      const base = Object.keys(theme.breakpoints.values).reduce((acc, breakpoint) => {
        if (typeof ownerState.spacing === "object" && ownerState.spacing[breakpoint] != null || typeof ownerState.direction === "object" && ownerState.direction[breakpoint] != null) {
          acc[breakpoint] = true;
        }
        return acc;
      }, {});
      const directionValues = resolveBreakpointValues({
        values: ownerState.direction,
        base
      });
      const spacingValues = resolveBreakpointValues({
        values: ownerState.spacing,
        base
      });
      if (typeof directionValues === "object") {
        Object.keys(directionValues).forEach((breakpoint, index, breakpoints) => {
          const directionValue = directionValues[breakpoint];
          if (!directionValue) {
            const previousDirectionValue = index > 0 ? directionValues[breakpoints[index - 1]] : "column";
            directionValues[breakpoint] = previousDirectionValue;
          }
        });
      }
      const styleFromPropValue = (propValue, breakpoint) => {
        if (ownerState.useFlexGap) {
          return {
            gap: getValue(transformer3, propValue)
          };
        }
        return {
          // The useFlexGap={false} implement relies on each child to give up control of the margin.
          // We need to reset the margin to avoid double spacing.
          "& > :not(style):not(style)": {
            margin: 0
          },
          "& > :not(style) ~ :not(style)": {
            [`margin${getSideFromDirection(breakpoint ? directionValues[breakpoint] : ownerState.direction)}`]: getValue(transformer3, propValue)
          }
        };
      };
      styles2 = deepmerge(styles2, handleBreakpoints({
        theme
      }, spacingValues, styleFromPropValue));
    }
    styles2 = mergeBreakpointsInOrder(theme.breakpoints, styles2);
    return styles2;
  };
  function createStack(options = {}) {
    const {
      // This will allow adding custom styled fn (for example for custom sx style function)
      createStyledComponent = defaultCreateStyledComponent2,
      useThemeProps: useThemeProps3 = useThemePropsDefault2,
      componentName = "MuiStack"
    } = options;
    const useUtilityClasses30 = () => {
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, (slot) => generateUtilityClass(componentName, slot), {});
    };
    const StackRoot = createStyledComponent(style3);
    const Stack2 = /* @__PURE__ */ React28.forwardRef(function Grid(inProps, ref) {
      const themeProps = useThemeProps3(inProps);
      const props = extendSxProp(themeProps);
      const _a = props, {
        component = "div",
        direction = "column",
        spacing: spacing2 = 0,
        divider,
        children,
        className,
        useFlexGap = false
      } = _a, other = __objRest(_a, [
        "component",
        "direction",
        "spacing",
        "divider",
        "children",
        "className",
        "useFlexGap"
      ]);
      const ownerState = {
        direction,
        spacing: spacing2,
        useFlexGap
      };
      const classes = useUtilityClasses30();
      return /* @__PURE__ */ (0, import_jsx_runtime11.jsx)(StackRoot, __spreadProps(__spreadValues({
        as: component,
        ownerState,
        ref,
        className: clsx_default(classes.root, className)
      }, other), {
        children: divider ? joinChildren(children, divider) : children
      }));
    });
    false ? Stack2.propTypes = {
      children: import_prop_types.default.node,
      direction: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types.default.arrayOf(import_prop_types.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types.default.object]),
      divider: import_prop_types.default.node,
      spacing: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])), import_prop_types.default.number, import_prop_types.default.object, import_prop_types.default.string]),
      sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
    } : void 0;
    return Stack2;
  }

  // node_modules/@mui/material/styles/createPalette.js
  function getLight() {
    return {
      // The colors used to style the text.
      text: {
        // The most important text.
        primary: "rgba(0, 0, 0, 0.87)",
        // Secondary text.
        secondary: "rgba(0, 0, 0, 0.6)",
        // Disabled text have even lower visual prominence.
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      // The color used to divide different elements.
      divider: "rgba(0, 0, 0, 0.12)",
      // The background colors used to style the surfaces.
      // Consistency between these values is important.
      background: {
        paper: common_default.white,
        default: common_default.white
      },
      // The colors used to style the action elements.
      action: {
        // The color of an active action like an icon button.
        active: "rgba(0, 0, 0, 0.54)",
        // The color of an hovered action.
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: "rgba(0, 0, 0, 0.26)",
        // The background color of a disabled action.
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    };
  }
  var light = getLight();
  function getDark() {
    return {
      text: {
        primary: common_default.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: common_default.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
  }
  var dark = getDark();
  function addLightOrDark(intent, direction, shade, tonalOffset) {
    const tonalOffsetLight = tonalOffset.light || tonalOffset;
    const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
    if (!intent[direction]) {
      if (intent.hasOwnProperty(shade)) {
        intent[direction] = intent[shade];
      } else if (direction === "light") {
        intent.light = lighten(intent.main, tonalOffsetLight);
      } else if (direction === "dark") {
        intent.dark = darken(intent.main, tonalOffsetDark);
      }
    }
  }
  function getDefaultPrimary(mode = "light") {
    if (mode === "dark") {
      return {
        main: blue_default[200],
        light: blue_default[50],
        dark: blue_default[400]
      };
    }
    return {
      main: blue_default[700],
      light: blue_default[400],
      dark: blue_default[800]
    };
  }
  function getDefaultSecondary(mode = "light") {
    if (mode === "dark") {
      return {
        main: purple_default[200],
        light: purple_default[50],
        dark: purple_default[400]
      };
    }
    return {
      main: purple_default[500],
      light: purple_default[300],
      dark: purple_default[700]
    };
  }
  function getDefaultError(mode = "light") {
    if (mode === "dark") {
      return {
        main: red_default[500],
        light: red_default[300],
        dark: red_default[700]
      };
    }
    return {
      main: red_default[700],
      light: red_default[400],
      dark: red_default[800]
    };
  }
  function getDefaultInfo(mode = "light") {
    if (mode === "dark") {
      return {
        main: lightBlue_default[400],
        light: lightBlue_default[300],
        dark: lightBlue_default[700]
      };
    }
    return {
      main: lightBlue_default[700],
      light: lightBlue_default[500],
      dark: lightBlue_default[900]
    };
  }
  function getDefaultSuccess(mode = "light") {
    if (mode === "dark") {
      return {
        main: green_default[400],
        light: green_default[300],
        dark: green_default[700]
      };
    }
    return {
      main: green_default[800],
      light: green_default[500],
      dark: green_default[900]
    };
  }
  function getDefaultWarning(mode = "light") {
    if (mode === "dark") {
      return {
        main: orange_default[400],
        light: orange_default[300],
        dark: orange_default[700]
      };
    }
    return {
      main: "#ed6c02",
      // closest to orange[800] that pass 3:1.
      light: orange_default[500],
      dark: orange_default[900]
    };
  }
  function createPalette(palette2) {
    const _a = palette2, {
      mode = "light",
      contrastThreshold = 3,
      tonalOffset = 0.2
    } = _a, other = __objRest(_a, [
      "mode",
      "contrastThreshold",
      "tonalOffset"
    ]);
    const primary = palette2.primary || getDefaultPrimary(mode);
    const secondary = palette2.secondary || getDefaultSecondary(mode);
    const error = palette2.error || getDefaultError(mode);
    const info = palette2.info || getDefaultInfo(mode);
    const success = palette2.success || getDefaultSuccess(mode);
    const warning = palette2.warning || getDefaultWarning(mode);
    function getContrastText(background) {
      const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
      if (false) {
        const contrast = getContrastRatio(background, contrastText);
        if (contrast < 3) {
          console.error([`MUI: The contrast ratio of ${contrast}:1 for ${contrastText} on ${background}`, "falls below the WCAG recommended absolute minimum contrast ratio of 3:1.", "https://www.w3.org/TR/2008/REC-WCAG20-20081211/#visual-audio-contrast-contrast"].join("\n"));
        }
      }
      return contrastText;
    }
    const augmentColor = ({
      color: color3,
      name,
      mainShade = 500,
      lightShade = 300,
      darkShade = 700
    }) => {
      color3 = __spreadValues({}, color3);
      if (!color3.main && color3[mainShade]) {
        color3.main = color3[mainShade];
      }
      if (!color3.hasOwnProperty("main")) {
        throw new Error(false ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
The color object needs to have a \`main\` property or a \`${mainShade}\` property.` : formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
      }
      if (typeof color3.main !== "string") {
        throw new Error(false ? `MUI: The color${name ? ` (${name})` : ""} provided to augmentColor(color) is invalid.
\`color.main\` should be a string, but \`${JSON.stringify(color3.main)}\` was provided instead.

Did you intend to use one of the following approaches?

import { green } from "@mui/material/colors";

const theme1 = createTheme({ palette: {
  primary: green,
} });

const theme2 = createTheme({ palette: {
  primary: { main: green[500] },
} });` : formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color3.main)));
      }
      addLightOrDark(color3, "light", lightShade, tonalOffset);
      addLightOrDark(color3, "dark", darkShade, tonalOffset);
      if (!color3.contrastText) {
        color3.contrastText = getContrastText(color3.main);
      }
      return color3;
    };
    let modeHydrated;
    if (mode === "light") {
      modeHydrated = getLight();
    } else if (mode === "dark") {
      modeHydrated = getDark();
    }
    if (false) {
      if (!modeHydrated) {
        console.error(`MUI: The palette mode \`${mode}\` is not supported.`);
      }
    }
    const paletteOutput = deepmerge(__spreadValues({
      // A collection of common colors.
      common: __spreadValues({}, common_default),
      // prevent mutable object.
      // The palette mode, can be light or dark.
      mode,
      // The colors used to represent primary interface elements for a user.
      primary: augmentColor({
        color: primary,
        name: "primary"
      }),
      // The colors used to represent secondary interface elements for a user.
      secondary: augmentColor({
        color: secondary,
        name: "secondary",
        mainShade: "A400",
        lightShade: "A200",
        darkShade: "A700"
      }),
      // The colors used to represent interface elements that the user should be made aware of.
      error: augmentColor({
        color: error,
        name: "error"
      }),
      // The colors used to represent potentially dangerous actions or important messages.
      warning: augmentColor({
        color: warning,
        name: "warning"
      }),
      // The colors used to present information to the user that is neutral and not necessarily important.
      info: augmentColor({
        color: info,
        name: "info"
      }),
      // The colors used to indicate the successful completion of an action that user triggered.
      success: augmentColor({
        color: success,
        name: "success"
      }),
      // The grey colors.
      grey: grey_default,
      // Used by `getContrastText()` to maximize the contrast between
      // the background and the text.
      contrastThreshold,
      // Takes a background color and returns the text color that maximizes the contrast.
      getContrastText,
      // Generate a rich color object.
      augmentColor,
      // Used by the functions below to shift a color's luminance by approximately
      // two indexes within its tonal palette.
      // E.g., shift from Red 500 to Red 300 or Red 700.
      tonalOffset
    }, modeHydrated), other);
    return paletteOutput;
  }

  // node_modules/@mui/system/esm/cssVars/prepareTypographyVars.js
  function prepareTypographyVars(typography) {
    const vars = {};
    const entries = Object.entries(typography);
    entries.forEach((entry) => {
      const [key, value] = entry;
      if (typeof value === "object") {
        vars[key] = `${value.fontStyle ? `${value.fontStyle} ` : ""}${value.fontVariant ? `${value.fontVariant} ` : ""}${value.fontWeight ? `${value.fontWeight} ` : ""}${value.fontStretch ? `${value.fontStretch} ` : ""}${value.fontSize || ""}${value.lineHeight ? `/${value.lineHeight} ` : ""}${value.fontFamily || ""}`;
      }
    });
    return vars;
  }

  // node_modules/@mui/material/styles/createMixins.js
  function createMixins(breakpoints, mixins) {
    return __spreadValues({
      toolbar: {
        minHeight: 56,
        [breakpoints.up("xs")]: {
          "@media (orientation: landscape)": {
            minHeight: 48
          }
        },
        [breakpoints.up("sm")]: {
          minHeight: 64
        }
      }
    }, mixins);
  }

  // node_modules/@mui/material/styles/createTypography.js
  function round(value) {
    return Math.round(value * 1e5) / 1e5;
  }
  var caseAllCaps = {
    textTransform: "uppercase"
  };
  var defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
  function createTypography(palette2, typography) {
    const _a = typeof typography === "function" ? typography(palette2) : typography, {
      fontFamily = defaultFontFamily,
      fontSize: fontSize = 14,
      fontWeightLight: fontWeightLight = 300,
      fontWeightRegular = 400,
      fontWeightMedium = 500,
      fontWeightBold = 700,
      htmlFontSize: htmlFontSize = 16,
      allVariants: allVariants,
      pxToRem: pxToRem2
    } = _a, other = __objRest(_a, [
      "fontFamily",
      // The default font size of the Material Specification.
      "fontSize",
      // px
      "fontWeightLight",
      "fontWeightRegular",
      "fontWeightMedium",
      "fontWeightBold",
      // Tell MUI what's the font-size on the html element.
      // 16px is the default font-size used by browsers.
      "htmlFontSize",
      // Apply the CSS properties to all the variants.
      "allVariants",
      "pxToRem"
    ]);
    if (false) {
      if (typeof fontSize !== "number") {
        console.error("MUI: `fontSize` is required to be a number.");
      }
      if (typeof htmlFontSize !== "number") {
        console.error("MUI: `htmlFontSize` is required to be a number.");
      }
    }
    const coef = fontSize / 14;
    const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
    const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => __spreadValues(__spreadValues(__spreadValues({
      fontFamily,
      fontWeight,
      fontSize: pxToRem(size),
      // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
      lineHeight
    }, fontFamily === defaultFontFamily ? {
      letterSpacing: `${round(letterSpacing / size)}em`
    } : {}), casing), allVariants);
    const variants = {
      h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
      h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
      h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
      h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
      h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
      h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
      subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
      subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
      body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
      body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
      button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
      caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
      overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
      // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
      inherit: {
        fontFamily: "inherit",
        fontWeight: "inherit",
        fontSize: "inherit",
        lineHeight: "inherit",
        letterSpacing: "inherit"
      }
    };
    return deepmerge(__spreadValues({
      htmlFontSize,
      pxToRem,
      fontFamily,
      fontSize,
      fontWeightLight,
      fontWeightRegular,
      fontWeightMedium,
      fontWeightBold
    }, variants), other, {
      clone: false
      // No need to clone deep
    });
  }

  // node_modules/@mui/material/styles/shadows.js
  var shadowKeyUmbraOpacity = 0.2;
  var shadowKeyPenumbraOpacity = 0.14;
  var shadowAmbientShadowOpacity = 0.12;
  function createShadow(...px) {
    return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
  }
  var shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
  var shadows_default = shadows;

  // node_modules/@mui/material/styles/createTransitions.js
  var easing = {
    // This is the most common easing curve.
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    // Objects enter the screen at full velocity from off-screen and
    // slowly decelerate to a resting point.
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    // Objects leave the screen at full velocity. They do not decelerate when off-screen.
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    // The sharp curve is used by objects that may return to the screen at any time.
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
  };
  var duration = {
    shortest: 150,
    shorter: 200,
    short: 250,
    // most basic recommended timing
    standard: 300,
    // this is to be used in complex animations
    complex: 375,
    // recommended when something is entering screen
    enteringScreen: 225,
    // recommended when something is leaving screen
    leavingScreen: 195
  };
  function formatMs(milliseconds2) {
    return `${Math.round(milliseconds2)}ms`;
  }
  function getAutoHeightDuration(height2) {
    if (!height2) {
      return 0;
    }
    const constant = height2 / 36;
    return Math.min(Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10), 3e3);
  }
  function createTransitions(inputTransitions) {
    const mergedEasing = __spreadValues(__spreadValues({}, easing), inputTransitions.easing);
    const mergedDuration = __spreadValues(__spreadValues({}, duration), inputTransitions.duration);
    const create = (props = ["all"], options = {}) => {
      const _a = options, {
        duration: durationOption = mergedDuration.standard,
        easing: easingOption = mergedEasing.easeInOut,
        delay = 0
      } = _a, other = __objRest(_a, [
        "duration",
        "easing",
        "delay"
      ]);
      if (false) {
        const isString = (value) => typeof value === "string";
        const isNumber = (value) => !Number.isNaN(parseFloat(value));
        if (!isString(props) && !Array.isArray(props)) {
          console.error('MUI: Argument "props" must be a string or Array.');
        }
        if (!isNumber(durationOption) && !isString(durationOption)) {
          console.error(`MUI: Argument "duration" must be a number or a string but found ${durationOption}.`);
        }
        if (!isString(easingOption)) {
          console.error('MUI: Argument "easing" must be a string.');
        }
        if (!isNumber(delay) && !isString(delay)) {
          console.error('MUI: Argument "delay" must be a number or a string.');
        }
        if (typeof options !== "object") {
          console.error(["MUI: Secong argument of transition.create must be an object.", "Arguments should be either `create('prop1', options)` or `create(['prop1', 'prop2'], options)`"].join("\n"));
        }
        if (Object.keys(other).length !== 0) {
          console.error(`MUI: Unrecognized argument(s) [${Object.keys(other).join(",")}].`);
        }
      }
      return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
    };
    return __spreadProps(__spreadValues({
      getAutoHeightDuration,
      create
    }, inputTransitions), {
      easing: mergedEasing,
      duration: mergedDuration
    });
  }

  // node_modules/@mui/material/styles/zIndex.js
  var zIndex = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
  };
  var zIndex_default = zIndex;

  // node_modules/@mui/material/styles/stringifyTheme.js
  function isSerializable(val) {
    return isPlainObject(val) || typeof val === "undefined" || typeof val === "string" || typeof val === "boolean" || typeof val === "number" || Array.isArray(val);
  }
  function stringifyTheme(baseTheme = {}) {
    const serializableTheme = __spreadValues({}, baseTheme);
    function serializeTheme(object) {
      const array = Object.entries(object);
      for (let index = 0; index < array.length; index++) {
        const [key, value] = array[index];
        if (!isSerializable(value) || key.startsWith("unstable_")) {
          delete object[key];
        } else if (isPlainObject(value)) {
          object[key] = __spreadValues({}, value);
          serializeTheme(object[key]);
        }
      }
    }
    serializeTheme(serializableTheme);
    return `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify(serializableTheme, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`;
  }

  // node_modules/@mui/material/styles/createThemeNoVars.js
  function createThemeNoVars(options = {}, ...args) {
    const _a = options, {
      breakpoints: breakpointsInput,
      mixins: mixinsInput = {},
      spacing: spacingInput,
      palette: paletteInput = {},
      transitions: transitionsInput = {},
      typography: typographyInput = {},
      shape: shapeInput
    } = _a, other = __objRest(_a, [
      "breakpoints",
      "mixins",
      "spacing",
      "palette",
      "transitions",
      "typography",
      "shape"
    ]);
    if (options.vars && // The error should throw only for the root theme creation because user is not allowed to use a custom node `vars`.
    // `generateThemeVars` is the closest identifier for checking that the `options` is a result of `createTheme` with CSS variables so that user can create new theme for nested ThemeProvider.
    options.generateThemeVars === void 0) {
      throw new Error(false ? "MUI: `vars` is a private field used for CSS variables support.\nPlease use another name or follow the [docs](https://mui.com/material-ui/customization/css-theme-variables/usage/) to enable the feature." : formatMuiErrorMessage(20));
    }
    const palette2 = createPalette(paletteInput);
    const systemTheme = createTheme_default(options);
    let muiTheme = deepmerge(systemTheme, {
      mixins: createMixins(systemTheme.breakpoints, mixinsInput),
      palette: palette2,
      // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
      shadows: shadows_default.slice(),
      typography: createTypography(palette2, typographyInput),
      transitions: createTransitions(transitionsInput),
      zIndex: __spreadValues({}, zIndex_default)
    });
    muiTheme = deepmerge(muiTheme, other);
    muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
    if (false) {
      const stateClasses = ["active", "checked", "completed", "disabled", "error", "expanded", "focused", "focusVisible", "required", "selected"];
      const traverse = (node2, component) => {
        let key;
        for (key in node2) {
          const child = node2[key];
          if (stateClasses.includes(key) && Object.keys(child).length > 0) {
            if (false) {
              const stateClass = generateUtilityClass("", key);
              console.error([`MUI: The \`${component}\` component increases the CSS specificity of the \`${key}\` internal state.`, "You can not override it like this: ", JSON.stringify(node2, null, 2), "", `Instead, you need to use the '&.${stateClass}' syntax:`, JSON.stringify({
                root: {
                  [`&.${stateClass}`]: child
                }
              }, null, 2), "", "https://mui.com/r/state-classes-guide"].join("\n"));
            }
            node2[key] = {};
          }
        }
      };
      Object.keys(muiTheme.components).forEach((component) => {
        const styleOverrides = muiTheme.components[component].styleOverrides;
        if (styleOverrides && component.startsWith("Mui")) {
          traverse(styleOverrides, component);
        }
      });
    }
    muiTheme.unstable_sxConfig = __spreadValues(__spreadValues({}, defaultSxConfig_default), other == null ? void 0 : other.unstable_sxConfig);
    muiTheme.unstable_sx = function sx(props) {
      return styleFunctionSx_default({
        sx: props,
        theme: this
      });
    };
    muiTheme.toRuntimeSource = stringifyTheme;
    return muiTheme;
  }
  var createThemeNoVars_default = createThemeNoVars;

  // node_modules/@mui/material/styles/getOverlayAlpha.js
  function getOverlayAlpha(elevation) {
    let alphaValue;
    if (elevation < 1) {
      alphaValue = 5.11916 * elevation ** 2;
    } else {
      alphaValue = 4.5 * Math.log(elevation + 1) + 2;
    }
    return Math.round(alphaValue * 10) / 1e3;
  }

  // node_modules/@mui/material/styles/createColorScheme.js
  var defaultDarkOverlays = [...Array(25)].map((_2, index) => {
    if (index === 0) {
      return "none";
    }
    const overlay = getOverlayAlpha(index);
    return `linear-gradient(rgba(255 255 255 / ${overlay}), rgba(255 255 255 / ${overlay}))`;
  });
  function getOpacity(mode) {
    return {
      inputPlaceholder: mode === "dark" ? 0.5 : 0.42,
      inputUnderline: mode === "dark" ? 0.7 : 0.42,
      switchTrackDisabled: mode === "dark" ? 0.2 : 0.12,
      switchTrack: mode === "dark" ? 0.3 : 0.38
    };
  }
  function getOverlays(mode) {
    return mode === "dark" ? defaultDarkOverlays : [];
  }
  function createColorScheme(options) {
    const _a = options, {
      palette: paletteInput = {
        mode: "light"
      },
      opacity: opacity,
      overlays
    } = _a, rest = __objRest(_a, [
      "palette",
      // need to cast to avoid module augmentation test
      "opacity",
      "overlays"
    ]);
    const palette2 = createPalette(paletteInput);
    return __spreadValues({
      palette: palette2,
      opacity: __spreadValues(__spreadValues({}, getOpacity(palette2.mode)), opacity),
      overlays: overlays || getOverlays(palette2.mode)
    }, rest);
  }

  // node_modules/@mui/material/styles/shouldSkipGeneratingVar.js
  function shouldSkipGeneratingVar(keys) {
    var _a;
    return !!keys[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!keys[0].match(/sxConfig$/) || // ends with sxConfig
    keys[0] === "palette" && !!((_a = keys[1]) == null ? void 0 : _a.match(/(mode|contrastThreshold|tonalOffset)/));
  }

  // node_modules/@mui/material/styles/excludeVariablesFromRoot.js
  var excludeVariablesFromRoot = (cssVarPrefix) => [...[...Array(25)].map((_2, index) => `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}overlays-${index}`), `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkBg`, `--${cssVarPrefix ? `${cssVarPrefix}-` : ""}palette-AppBar-darkColor`];
  var excludeVariablesFromRoot_default = excludeVariablesFromRoot;

  // node_modules/@mui/material/styles/createGetSelector.js
  var createGetSelector_default = (theme) => (colorScheme, css2) => {
    const root2 = theme.rootSelector || ":root";
    const selector = theme.colorSchemeSelector;
    let rule = selector;
    if (selector === "class") {
      rule = ".%s";
    }
    if (selector === "data") {
      rule = "[data-%s]";
    }
    if ((selector == null ? void 0 : selector.startsWith("data-")) && !selector.includes("%s")) {
      rule = `[${selector}="%s"]`;
    }
    if (theme.defaultColorScheme === colorScheme) {
      if (colorScheme === "dark") {
        const excludedVariables = {};
        excludeVariablesFromRoot_default(theme.cssVarPrefix).forEach((cssVar) => {
          excludedVariables[cssVar] = css2[cssVar];
          delete css2[cssVar];
        });
        if (rule === "media") {
          return {
            [root2]: css2,
            [`@media (prefers-color-scheme: dark)`]: {
              [root2]: excludedVariables
            }
          };
        }
        if (rule) {
          return {
            [rule.replace("%s", colorScheme)]: excludedVariables,
            [`${root2}, ${rule.replace("%s", colorScheme)}`]: css2
          };
        }
        return {
          [root2]: __spreadValues(__spreadValues({}, css2), excludedVariables)
        };
      }
      if (rule && rule !== "media") {
        return `${root2}, ${rule.replace("%s", String(colorScheme))}`;
      }
    } else if (colorScheme) {
      if (rule === "media") {
        return {
          [`@media (prefers-color-scheme: ${String(colorScheme)})`]: {
            [root2]: css2
          }
        };
      }
      if (rule) {
        return rule.replace("%s", String(colorScheme));
      }
    }
    return root2;
  };

  // node_modules/@mui/material/styles/createThemeWithVars.js
  function assignNode(obj, keys) {
    keys.forEach((k) => {
      if (!obj[k]) {
        obj[k] = {};
      }
    });
  }
  function setColor(obj, key, defaultValue) {
    if (!obj[key] && defaultValue) {
      obj[key] = defaultValue;
    }
  }
  function toRgb(color3) {
    if (typeof color3 !== "string" || !color3.startsWith("hsl")) {
      return color3;
    }
    return hslToRgb(color3);
  }
  function setColorChannel(obj, key) {
    if (!(`${key}Channel` in obj)) {
      obj[`${key}Channel`] = private_safeColorChannel(toRgb(obj[key]), `MUI: Can't create \`palette.${key}Channel\` because \`palette.${key}\` is not one of these formats: #nnn, #nnnnnn, rgb(), rgba(), hsl(), hsla(), color().
To suppress this warning, you need to explicitly provide the \`palette.${key}Channel\` as a string (in rgb format, for example "12 12 12") or undefined if you want to remove the channel token.`);
    }
  }
  function getSpacingVal(spacingInput) {
    if (typeof spacingInput === "number") {
      return `${spacingInput}px`;
    }
    if (typeof spacingInput === "string" || typeof spacingInput === "function" || Array.isArray(spacingInput)) {
      return spacingInput;
    }
    return "8px";
  }
  var silent = (fn2) => {
    try {
      return fn2();
    } catch (error) {
    }
    return void 0;
  };
  var createGetCssVar2 = (cssVarPrefix = "mui") => createGetCssVar(cssVarPrefix);
  function attachColorScheme(colorSchemes, scheme, restTheme, colorScheme) {
    if (!scheme) {
      return void 0;
    }
    scheme = scheme === true ? {} : scheme;
    const mode = colorScheme === "dark" ? "dark" : "light";
    if (!restTheme) {
      colorSchemes[colorScheme] = createColorScheme(__spreadProps(__spreadValues({}, scheme), {
        palette: __spreadValues({
          mode
        }, scheme == null ? void 0 : scheme.palette)
      }));
      return void 0;
    }
    const _a = createThemeNoVars_default(__spreadProps(__spreadValues({}, restTheme), {
      palette: __spreadValues({
        mode
      }, scheme == null ? void 0 : scheme.palette)
    })), {
      palette: palette2
    } = _a, muiTheme = __objRest(_a, [
      "palette"
    ]);
    colorSchemes[colorScheme] = __spreadProps(__spreadValues({}, scheme), {
      palette: palette2,
      opacity: __spreadValues(__spreadValues({}, getOpacity(mode)), scheme == null ? void 0 : scheme.opacity),
      overlays: (scheme == null ? void 0 : scheme.overlays) || getOverlays(mode)
    });
    return muiTheme;
  }
  function createThemeWithVars(options = {}, ...args) {
    const _a = options, {
      colorSchemes: colorSchemesInput = {
        light: true
      },
      defaultColorScheme: defaultColorSchemeInput,
      disableCssColorScheme = false,
      cssVarPrefix = "mui",
      shouldSkipGeneratingVar: shouldSkipGeneratingVar2 = shouldSkipGeneratingVar,
      colorSchemeSelector: selector = colorSchemesInput.light && colorSchemesInput.dark ? "media" : void 0,
      rootSelector = ":root"
    } = _a, input = __objRest(_a, [
      "colorSchemes",
      "defaultColorScheme",
      "disableCssColorScheme",
      "cssVarPrefix",
      "shouldSkipGeneratingVar",
      "colorSchemeSelector",
      "rootSelector"
    ]);
    const firstColorScheme = Object.keys(colorSchemesInput)[0];
    const defaultColorScheme = defaultColorSchemeInput || (colorSchemesInput.light && firstColorScheme !== "light" ? "light" : firstColorScheme);
    const getCssVar = createGetCssVar2(cssVarPrefix);
    const _b = colorSchemesInput, {
      [defaultColorScheme]: defaultSchemeInput,
      light: builtInLight,
      dark: builtInDark
    } = _b, customColorSchemes = __objRest(_b, [
      __restKey(defaultColorScheme),
      "light",
      "dark"
    ]);
    const colorSchemes = __spreadValues({}, customColorSchemes);
    let defaultScheme = defaultSchemeInput;
    if (defaultColorScheme === "dark" && !("dark" in colorSchemesInput) || defaultColorScheme === "light" && !("light" in colorSchemesInput)) {
      defaultScheme = true;
    }
    if (!defaultScheme) {
      throw new Error(false ? `MUI: The \`colorSchemes.${defaultColorScheme}\` option is either missing or invalid.` : formatMuiErrorMessage(21, defaultColorScheme));
    }
    const muiTheme = attachColorScheme(colorSchemes, defaultScheme, input, defaultColorScheme);
    if (builtInLight && !colorSchemes.light) {
      attachColorScheme(colorSchemes, builtInLight, void 0, "light");
    }
    if (builtInDark && !colorSchemes.dark) {
      attachColorScheme(colorSchemes, builtInDark, void 0, "dark");
    }
    let theme = __spreadProps(__spreadValues({
      defaultColorScheme
    }, muiTheme), {
      cssVarPrefix,
      colorSchemeSelector: selector,
      rootSelector,
      getCssVar,
      colorSchemes,
      font: __spreadValues(__spreadValues({}, prepareTypographyVars(muiTheme.typography)), muiTheme.font),
      spacing: getSpacingVal(input.spacing)
    });
    Object.keys(theme.colorSchemes).forEach((key) => {
      const palette2 = theme.colorSchemes[key].palette;
      const setCssVarColor = (cssVar) => {
        const tokens = cssVar.split("-");
        const color3 = tokens[1];
        const colorToken = tokens[2];
        return getCssVar(cssVar, palette2[color3][colorToken]);
      };
      if (palette2.mode === "light") {
        setColor(palette2.common, "background", "#fff");
        setColor(palette2.common, "onBackground", "#000");
      }
      if (palette2.mode === "dark") {
        setColor(palette2.common, "background", "#000");
        setColor(palette2.common, "onBackground", "#fff");
      }
      assignNode(palette2, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]);
      if (palette2.mode === "light") {
        setColor(palette2.Alert, "errorColor", private_safeDarken(palette2.error.light, 0.6));
        setColor(palette2.Alert, "infoColor", private_safeDarken(palette2.info.light, 0.6));
        setColor(palette2.Alert, "successColor", private_safeDarken(palette2.success.light, 0.6));
        setColor(palette2.Alert, "warningColor", private_safeDarken(palette2.warning.light, 0.6));
        setColor(palette2.Alert, "errorFilledBg", setCssVarColor("palette-error-main"));
        setColor(palette2.Alert, "infoFilledBg", setCssVarColor("palette-info-main"));
        setColor(palette2.Alert, "successFilledBg", setCssVarColor("palette-success-main"));
        setColor(palette2.Alert, "warningFilledBg", setCssVarColor("palette-warning-main"));
        setColor(palette2.Alert, "errorFilledColor", silent(() => palette2.getContrastText(palette2.error.main)));
        setColor(palette2.Alert, "infoFilledColor", silent(() => palette2.getContrastText(palette2.info.main)));
        setColor(palette2.Alert, "successFilledColor", silent(() => palette2.getContrastText(palette2.success.main)));
        setColor(palette2.Alert, "warningFilledColor", silent(() => palette2.getContrastText(palette2.warning.main)));
        setColor(palette2.Alert, "errorStandardBg", private_safeLighten(palette2.error.light, 0.9));
        setColor(palette2.Alert, "infoStandardBg", private_safeLighten(palette2.info.light, 0.9));
        setColor(palette2.Alert, "successStandardBg", private_safeLighten(palette2.success.light, 0.9));
        setColor(palette2.Alert, "warningStandardBg", private_safeLighten(palette2.warning.light, 0.9));
        setColor(palette2.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
        setColor(palette2.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
        setColor(palette2.Alert, "successIconColor", setCssVarColor("palette-success-main"));
        setColor(palette2.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
        setColor(palette2.AppBar, "defaultBg", setCssVarColor("palette-grey-100"));
        setColor(palette2.Avatar, "defaultBg", setCssVarColor("palette-grey-400"));
        setColor(palette2.Button, "inheritContainedBg", setCssVarColor("palette-grey-300"));
        setColor(palette2.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-A100"));
        setColor(palette2.Chip, "defaultBorder", setCssVarColor("palette-grey-400"));
        setColor(palette2.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-700"));
        setColor(palette2.Chip, "defaultIconColor", setCssVarColor("palette-grey-700"));
        setColor(palette2.FilledInput, "bg", "rgba(0, 0, 0, 0.06)");
        setColor(palette2.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)");
        setColor(palette2.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)");
        setColor(palette2.LinearProgress, "primaryBg", private_safeLighten(palette2.primary.main, 0.62));
        setColor(palette2.LinearProgress, "secondaryBg", private_safeLighten(palette2.secondary.main, 0.62));
        setColor(palette2.LinearProgress, "errorBg", private_safeLighten(palette2.error.main, 0.62));
        setColor(palette2.LinearProgress, "infoBg", private_safeLighten(palette2.info.main, 0.62));
        setColor(palette2.LinearProgress, "successBg", private_safeLighten(palette2.success.main, 0.62));
        setColor(palette2.LinearProgress, "warningBg", private_safeLighten(palette2.warning.main, 0.62));
        setColor(palette2.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.11)`);
        setColor(palette2.Slider, "primaryTrack", private_safeLighten(palette2.primary.main, 0.62));
        setColor(palette2.Slider, "secondaryTrack", private_safeLighten(palette2.secondary.main, 0.62));
        setColor(palette2.Slider, "errorTrack", private_safeLighten(palette2.error.main, 0.62));
        setColor(palette2.Slider, "infoTrack", private_safeLighten(palette2.info.main, 0.62));
        setColor(palette2.Slider, "successTrack", private_safeLighten(palette2.success.main, 0.62));
        setColor(palette2.Slider, "warningTrack", private_safeLighten(palette2.warning.main, 0.62));
        const snackbarContentBackground = private_safeEmphasize(palette2.background.default, 0.8);
        setColor(palette2.SnackbarContent, "bg", snackbarContentBackground);
        setColor(palette2.SnackbarContent, "color", silent(() => palette2.getContrastText(snackbarContentBackground)));
        setColor(palette2.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette2.background.paper, 0.15));
        setColor(palette2.StepConnector, "border", setCssVarColor("palette-grey-400"));
        setColor(palette2.StepContent, "border", setCssVarColor("palette-grey-400"));
        setColor(palette2.Switch, "defaultColor", setCssVarColor("palette-common-white"));
        setColor(palette2.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-100"));
        setColor(palette2.Switch, "primaryDisabledColor", private_safeLighten(palette2.primary.main, 0.62));
        setColor(palette2.Switch, "secondaryDisabledColor", private_safeLighten(palette2.secondary.main, 0.62));
        setColor(palette2.Switch, "errorDisabledColor", private_safeLighten(palette2.error.main, 0.62));
        setColor(palette2.Switch, "infoDisabledColor", private_safeLighten(palette2.info.main, 0.62));
        setColor(palette2.Switch, "successDisabledColor", private_safeLighten(palette2.success.main, 0.62));
        setColor(palette2.Switch, "warningDisabledColor", private_safeLighten(palette2.warning.main, 0.62));
        setColor(palette2.TableCell, "border", private_safeLighten(private_safeAlpha(palette2.divider, 1), 0.88));
        setColor(palette2.Tooltip, "bg", private_safeAlpha(palette2.grey[700], 0.92));
      }
      if (palette2.mode === "dark") {
        setColor(palette2.Alert, "errorColor", private_safeLighten(palette2.error.light, 0.6));
        setColor(palette2.Alert, "infoColor", private_safeLighten(palette2.info.light, 0.6));
        setColor(palette2.Alert, "successColor", private_safeLighten(palette2.success.light, 0.6));
        setColor(palette2.Alert, "warningColor", private_safeLighten(palette2.warning.light, 0.6));
        setColor(palette2.Alert, "errorFilledBg", setCssVarColor("palette-error-dark"));
        setColor(palette2.Alert, "infoFilledBg", setCssVarColor("palette-info-dark"));
        setColor(palette2.Alert, "successFilledBg", setCssVarColor("palette-success-dark"));
        setColor(palette2.Alert, "warningFilledBg", setCssVarColor("palette-warning-dark"));
        setColor(palette2.Alert, "errorFilledColor", silent(() => palette2.getContrastText(palette2.error.dark)));
        setColor(palette2.Alert, "infoFilledColor", silent(() => palette2.getContrastText(palette2.info.dark)));
        setColor(palette2.Alert, "successFilledColor", silent(() => palette2.getContrastText(palette2.success.dark)));
        setColor(palette2.Alert, "warningFilledColor", silent(() => palette2.getContrastText(palette2.warning.dark)));
        setColor(palette2.Alert, "errorStandardBg", private_safeDarken(palette2.error.light, 0.9));
        setColor(palette2.Alert, "infoStandardBg", private_safeDarken(palette2.info.light, 0.9));
        setColor(palette2.Alert, "successStandardBg", private_safeDarken(palette2.success.light, 0.9));
        setColor(palette2.Alert, "warningStandardBg", private_safeDarken(palette2.warning.light, 0.9));
        setColor(palette2.Alert, "errorIconColor", setCssVarColor("palette-error-main"));
        setColor(palette2.Alert, "infoIconColor", setCssVarColor("palette-info-main"));
        setColor(palette2.Alert, "successIconColor", setCssVarColor("palette-success-main"));
        setColor(palette2.Alert, "warningIconColor", setCssVarColor("palette-warning-main"));
        setColor(palette2.AppBar, "defaultBg", setCssVarColor("palette-grey-900"));
        setColor(palette2.AppBar, "darkBg", setCssVarColor("palette-background-paper"));
        setColor(palette2.AppBar, "darkColor", setCssVarColor("palette-text-primary"));
        setColor(palette2.Avatar, "defaultBg", setCssVarColor("palette-grey-600"));
        setColor(palette2.Button, "inheritContainedBg", setCssVarColor("palette-grey-800"));
        setColor(palette2.Button, "inheritContainedHoverBg", setCssVarColor("palette-grey-700"));
        setColor(palette2.Chip, "defaultBorder", setCssVarColor("palette-grey-700"));
        setColor(palette2.Chip, "defaultAvatarColor", setCssVarColor("palette-grey-300"));
        setColor(palette2.Chip, "defaultIconColor", setCssVarColor("palette-grey-300"));
        setColor(palette2.FilledInput, "bg", "rgba(255, 255, 255, 0.09)");
        setColor(palette2.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)");
        setColor(palette2.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)");
        setColor(palette2.LinearProgress, "primaryBg", private_safeDarken(palette2.primary.main, 0.5));
        setColor(palette2.LinearProgress, "secondaryBg", private_safeDarken(palette2.secondary.main, 0.5));
        setColor(palette2.LinearProgress, "errorBg", private_safeDarken(palette2.error.main, 0.5));
        setColor(palette2.LinearProgress, "infoBg", private_safeDarken(palette2.info.main, 0.5));
        setColor(palette2.LinearProgress, "successBg", private_safeDarken(palette2.success.main, 0.5));
        setColor(palette2.LinearProgress, "warningBg", private_safeDarken(palette2.warning.main, 0.5));
        setColor(palette2.Skeleton, "bg", `rgba(${setCssVarColor("palette-text-primaryChannel")} / 0.13)`);
        setColor(palette2.Slider, "primaryTrack", private_safeDarken(palette2.primary.main, 0.5));
        setColor(palette2.Slider, "secondaryTrack", private_safeDarken(palette2.secondary.main, 0.5));
        setColor(palette2.Slider, "errorTrack", private_safeDarken(palette2.error.main, 0.5));
        setColor(palette2.Slider, "infoTrack", private_safeDarken(palette2.info.main, 0.5));
        setColor(palette2.Slider, "successTrack", private_safeDarken(palette2.success.main, 0.5));
        setColor(palette2.Slider, "warningTrack", private_safeDarken(palette2.warning.main, 0.5));
        const snackbarContentBackground = private_safeEmphasize(palette2.background.default, 0.98);
        setColor(palette2.SnackbarContent, "bg", snackbarContentBackground);
        setColor(palette2.SnackbarContent, "color", silent(() => palette2.getContrastText(snackbarContentBackground)));
        setColor(palette2.SpeedDialAction, "fabHoverBg", private_safeEmphasize(palette2.background.paper, 0.15));
        setColor(palette2.StepConnector, "border", setCssVarColor("palette-grey-600"));
        setColor(palette2.StepContent, "border", setCssVarColor("palette-grey-600"));
        setColor(palette2.Switch, "defaultColor", setCssVarColor("palette-grey-300"));
        setColor(palette2.Switch, "defaultDisabledColor", setCssVarColor("palette-grey-600"));
        setColor(palette2.Switch, "primaryDisabledColor", private_safeDarken(palette2.primary.main, 0.55));
        setColor(palette2.Switch, "secondaryDisabledColor", private_safeDarken(palette2.secondary.main, 0.55));
        setColor(palette2.Switch, "errorDisabledColor", private_safeDarken(palette2.error.main, 0.55));
        setColor(palette2.Switch, "infoDisabledColor", private_safeDarken(palette2.info.main, 0.55));
        setColor(palette2.Switch, "successDisabledColor", private_safeDarken(palette2.success.main, 0.55));
        setColor(palette2.Switch, "warningDisabledColor", private_safeDarken(palette2.warning.main, 0.55));
        setColor(palette2.TableCell, "border", private_safeDarken(private_safeAlpha(palette2.divider, 1), 0.68));
        setColor(palette2.Tooltip, "bg", private_safeAlpha(palette2.grey[700], 0.92));
      }
      setColorChannel(palette2.background, "default");
      setColorChannel(palette2.background, "paper");
      setColorChannel(palette2.common, "background");
      setColorChannel(palette2.common, "onBackground");
      setColorChannel(palette2, "divider");
      Object.keys(palette2).forEach((color3) => {
        const colors3 = palette2[color3];
        if (color3 !== "tonalOffset" && colors3 && typeof colors3 === "object") {
          if (colors3.main) {
            setColor(palette2[color3], "mainChannel", private_safeColorChannel(toRgb(colors3.main)));
          }
          if (colors3.light) {
            setColor(palette2[color3], "lightChannel", private_safeColorChannel(toRgb(colors3.light)));
          }
          if (colors3.dark) {
            setColor(palette2[color3], "darkChannel", private_safeColorChannel(toRgb(colors3.dark)));
          }
          if (colors3.contrastText) {
            setColor(palette2[color3], "contrastTextChannel", private_safeColorChannel(toRgb(colors3.contrastText)));
          }
          if (color3 === "text") {
            setColorChannel(palette2[color3], "primary");
            setColorChannel(palette2[color3], "secondary");
          }
          if (color3 === "action") {
            if (colors3.active) {
              setColorChannel(palette2[color3], "active");
            }
            if (colors3.selected) {
              setColorChannel(palette2[color3], "selected");
            }
          }
        }
      });
    });
    theme = args.reduce((acc, argument) => deepmerge(acc, argument), theme);
    const parserConfig = {
      prefix: cssVarPrefix,
      disableCssColorScheme,
      shouldSkipGeneratingVar: shouldSkipGeneratingVar2,
      getSelector: createGetSelector_default(theme)
    };
    const {
      vars,
      generateThemeVars,
      generateStyleSheets
    } = prepareCssVars_default(theme, parserConfig);
    theme.vars = vars;
    Object.entries(theme.colorSchemes[theme.defaultColorScheme]).forEach(([key, value]) => {
      theme[key] = value;
    });
    theme.generateThemeVars = generateThemeVars;
    theme.generateStyleSheets = generateStyleSheets;
    theme.generateSpacing = function generateSpacing() {
      return createSpacing(input.spacing, createUnarySpacing(this));
    };
    theme.getColorSchemeSelector = createGetColorSchemeSelector(selector);
    theme.spacing = theme.generateSpacing();
    theme.shouldSkipGeneratingVar = shouldSkipGeneratingVar2;
    theme.unstable_sxConfig = __spreadValues(__spreadValues({}, defaultSxConfig_default), input == null ? void 0 : input.unstable_sxConfig);
    theme.unstable_sx = function sx(props) {
      return styleFunctionSx_default({
        sx: props,
        theme: this
      });
    };
    theme.toRuntimeSource = stringifyTheme;
    return theme;
  }

  // node_modules/@mui/material/styles/createTheme.js
  function attachColorScheme2(theme, scheme, colorScheme) {
    if (!theme.colorSchemes) {
      return void 0;
    }
    if (colorScheme) {
      theme.colorSchemes[scheme] = __spreadProps(__spreadValues({}, colorScheme !== true && colorScheme), {
        palette: createPalette(__spreadProps(__spreadValues({}, colorScheme === true ? {} : colorScheme.palette), {
          mode: scheme
        }))
        // cast type to skip module augmentation test
      });
    }
  }
  function createTheme2(options = {}, ...args) {
    const _a = options, {
      palette: palette2,
      cssVariables = false,
      colorSchemes: initialColorSchemes = !palette2 ? {
        light: true
      } : void 0,
      defaultColorScheme: initialDefaultColorScheme = palette2 == null ? void 0 : palette2.mode
    } = _a, rest = __objRest(_a, [
      "palette",
      "cssVariables",
      "colorSchemes",
      "defaultColorScheme"
    ]);
    const defaultColorSchemeInput = initialDefaultColorScheme || "light";
    const defaultScheme = initialColorSchemes == null ? void 0 : initialColorSchemes[defaultColorSchemeInput];
    const colorSchemesInput = __spreadValues(__spreadValues({}, initialColorSchemes), palette2 ? {
      [defaultColorSchemeInput]: __spreadProps(__spreadValues({}, typeof defaultScheme !== "boolean" && defaultScheme), {
        palette: palette2
      })
    } : void 0);
    if (cssVariables === false) {
      if (!("colorSchemes" in options)) {
        return createThemeNoVars_default(options, ...args);
      }
      let paletteOptions = palette2;
      if (!("palette" in options)) {
        if (colorSchemesInput[defaultColorSchemeInput]) {
          if (colorSchemesInput[defaultColorSchemeInput] !== true) {
            paletteOptions = colorSchemesInput[defaultColorSchemeInput].palette;
          } else if (defaultColorSchemeInput === "dark") {
            paletteOptions = {
              mode: "dark"
            };
          }
        }
      }
      const theme = createThemeNoVars_default(__spreadProps(__spreadValues({}, options), {
        palette: paletteOptions
      }), ...args);
      theme.defaultColorScheme = defaultColorSchemeInput;
      theme.colorSchemes = colorSchemesInput;
      if (theme.palette.mode === "light") {
        theme.colorSchemes.light = __spreadProps(__spreadValues({}, colorSchemesInput.light !== true && colorSchemesInput.light), {
          palette: theme.palette
        });
        attachColorScheme2(theme, "dark", colorSchemesInput.dark);
      }
      if (theme.palette.mode === "dark") {
        theme.colorSchemes.dark = __spreadProps(__spreadValues({}, colorSchemesInput.dark !== true && colorSchemesInput.dark), {
          palette: theme.palette
        });
        attachColorScheme2(theme, "light", colorSchemesInput.light);
      }
      return theme;
    }
    if (!palette2 && !("light" in colorSchemesInput) && defaultColorSchemeInput === "light") {
      colorSchemesInput.light = true;
    }
    return createThemeWithVars(__spreadValues(__spreadProps(__spreadValues({}, rest), {
      colorSchemes: colorSchemesInput,
      defaultColorScheme: defaultColorSchemeInput
    }), typeof cssVariables !== "boolean" && cssVariables), ...args);
  }

  // node_modules/@mui/material/styles/useTheme.js
  var React29 = __toESM(require_react());

  // node_modules/@mui/material/styles/defaultTheme.js
  var defaultTheme3 = createTheme2();
  var defaultTheme_default = defaultTheme3;

  // node_modules/@mui/material/styles/useTheme.js
  function useTheme5() {
    const theme = useTheme_default(defaultTheme_default);
    if (false) {
      React29.useDebugValue(theme);
    }
    return theme[identifier_default] || theme;
  }

  // node_modules/@mui/material/styles/useThemeProps.js
  function useThemeProps2({
    props,
    name
  }) {
    return useThemeProps({
      props,
      name,
      defaultTheme: defaultTheme_default,
      themeId: identifier_default
    });
  }

  // node_modules/@mui/material/styles/slotShouldForwardProp.js
  function slotShouldForwardProp(prop) {
    return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
  }
  var slotShouldForwardProp_default = slotShouldForwardProp;

  // node_modules/@mui/material/styles/rootShouldForwardProp.js
  var rootShouldForwardProp = (prop) => slotShouldForwardProp_default(prop) && prop !== "classes";
  var rootShouldForwardProp_default = rootShouldForwardProp;

  // node_modules/@mui/material/styles/styled.js
  var styled3 = createStyled3({
    themeId: identifier_default,
    defaultTheme: defaultTheme_default,
    rootShouldForwardProp: rootShouldForwardProp_default
  });
  var styled_default2 = styled3;

  // node_modules/@mui/material/styles/ThemeProvider.js
  var React33 = __toESM(require_react());

  // node_modules/@mui/material/styles/ThemeProviderNoVars.js
  var React30 = __toESM(require_react());
  var import_jsx_runtime12 = __toESM(require_jsx_runtime());
  function ThemeProviderNoVars(_a) {
    var _b = _a, {
      theme: themeInput
    } = _b, props = __objRest(_b, [
      "theme"
    ]);
    const scopedTheme = identifier_default in themeInput ? themeInput[identifier_default] : void 0;
    return /* @__PURE__ */ (0, import_jsx_runtime12.jsx)(ThemeProvider_default2, __spreadProps(__spreadValues({}, props), {
      themeId: scopedTheme ? identifier_default : void 0,
      theme: scopedTheme || themeInput
    }));
  }

  // node_modules/@mui/material/styles/ThemeProviderWithVars.js
  var React32 = __toESM(require_react());

  // node_modules/@mui/material/InitColorSchemeScript/InitColorSchemeScript.js
  var React31 = __toESM(require_react());
  var import_jsx_runtime13 = __toESM(require_jsx_runtime());
  var defaultConfig = {
    attribute: "data-mui-color-scheme",
    colorSchemeStorageKey: "mui-color-scheme",
    defaultLightColorScheme: "light",
    defaultDarkColorScheme: "dark",
    modeStorageKey: "mui-mode"
  };

  // node_modules/@mui/material/styles/ThemeProviderWithVars.js
  var import_jsx_runtime14 = __toESM(require_jsx_runtime());
  var {
    CssVarsProvider: InternalCssVarsProvider,
    useColorScheme,
    getInitColorSchemeScript: deprecatedGetInitColorSchemeScript
  } = createCssVarsProvider({
    themeId: identifier_default,
    // @ts-ignore ignore module augmentation tests
    theme: () => createTheme2({
      cssVariables: true
    }),
    colorSchemeStorageKey: defaultConfig.colorSchemeStorageKey,
    modeStorageKey: defaultConfig.modeStorageKey,
    defaultColorScheme: {
      light: defaultConfig.defaultLightColorScheme,
      dark: defaultConfig.defaultDarkColorScheme
    },
    resolveTheme: (theme) => {
      const newTheme = __spreadProps(__spreadValues({}, theme), {
        typography: createTypography(theme.palette, theme.typography)
      });
      newTheme.unstable_sx = function sx(props) {
        return styleFunctionSx_default({
          sx: props,
          theme: this
        });
      };
      return newTheme;
    }
  });
  var CssVarsProvider = InternalCssVarsProvider;

  // node_modules/@mui/material/styles/ThemeProvider.js
  var import_jsx_runtime15 = __toESM(require_jsx_runtime());
  function ThemeProvider4(_a) {
    var _b = _a, {
      theme
    } = _b, props = __objRest(_b, [
      "theme"
    ]);
    if (typeof theme === "function") {
      return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ThemeProviderNoVars, __spreadValues({
        theme
      }, props));
    }
    const muiTheme = identifier_default in theme ? theme[identifier_default] : theme;
    if (!("colorSchemes" in muiTheme)) {
      if (!("vars" in muiTheme)) {
        return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ThemeProviderNoVars, __spreadValues({
          theme: __spreadProps(__spreadValues({}, theme), {
            vars: null
          })
        }, props));
      }
      return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(ThemeProviderNoVars, __spreadValues({
        theme
      }, props));
    }
    return /* @__PURE__ */ (0, import_jsx_runtime15.jsx)(CssVarsProvider, __spreadValues({
      theme
    }, props));
  }

  // node_modules/@mui/material/utils/capitalize.js
  var capitalize_default = capitalize;

  // node_modules/@mui/material/utils/createSvgIcon.js
  var React37 = __toESM(require_react());

  // node_modules/@mui/material/SvgIcon/SvgIcon.js
  var React36 = __toESM(require_react());

  // node_modules/@mui/material/zero-styled/index.js
  var React34 = __toESM(require_react());
  var import_jsx_runtime16 = __toESM(require_jsx_runtime());
  function internal_createExtendSxProp() {
    return extendSxProp;
  }

  // node_modules/@mui/material/utils/memoTheme.js
  var memoTheme = unstable_memoTheme;
  var memoTheme_default = memoTheme;

  // node_modules/@mui/material/DefaultPropsProvider/DefaultPropsProvider.js
  var React35 = __toESM(require_react());
  var import_jsx_runtime17 = __toESM(require_jsx_runtime());
  false ? DefaultPropsProvider.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * @ignore
     */
    children: import_prop_types.default.node,
    /**
     * @ignore
     */
    value: import_prop_types.default.object.isRequired
  } : void 0;
  function useDefaultProps2(params) {
    return useDefaultProps(params);
  }

  // node_modules/@mui/material/SvgIcon/svgIconClasses.js
  function getSvgIconUtilityClass(slot) {
    return generateUtilityClass("MuiSvgIcon", slot);
  }
  var svgIconClasses = generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);

  // node_modules/@mui/material/SvgIcon/SvgIcon.js
  var import_jsx_runtime18 = __toESM(require_jsx_runtime());
  var useUtilityClasses = (ownerState) => {
    const {
      color: color3,
      fontSize,
      classes
    } = ownerState;
    const slots = {
      root: ["root", color3 !== "inherit" && `color${capitalize_default(color3)}`, `fontSize${capitalize_default(fontSize)}`]
    };
    return composeClasses(slots, getSvgIconUtilityClass, classes);
  };
  var SvgIconRoot = styled_default2("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize_default(ownerState.color)}`], styles2[`fontSize${capitalize_default(ownerState.fontSize)}`]];
    }
  })(memoTheme_default(({
    theme
  }) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    return {
      userSelect: "none",
      width: "1em",
      height: "1em",
      display: "inline-block",
      flexShrink: 0,
      transition: (_e = (_a = theme.transitions) == null ? void 0 : _a.create) == null ? void 0 : _e.call(_a, "fill", {
        duration: (_d = (_c = ((_b = theme.vars) != null ? _b : theme).transitions) == null ? void 0 : _c.duration) == null ? void 0 : _d.shorter
      }),
      variants: [
        {
          props: (props) => !props.hasSvgAsChild,
          style: {
            // the <svg> will define the property that has `currentColor`
            // for example heroicons uses fill="none" and stroke="currentColor"
            fill: "currentColor"
          }
        },
        {
          props: {
            fontSize: "inherit"
          },
          style: {
            fontSize: "inherit"
          }
        },
        {
          props: {
            fontSize: "small"
          },
          style: {
            fontSize: ((_g = (_f = theme.typography) == null ? void 0 : _f.pxToRem) == null ? void 0 : _g.call(_f, 20)) || "1.25rem"
          }
        },
        {
          props: {
            fontSize: "medium"
          },
          style: {
            fontSize: ((_i = (_h = theme.typography) == null ? void 0 : _h.pxToRem) == null ? void 0 : _i.call(_h, 24)) || "1.5rem"
          }
        },
        {
          props: {
            fontSize: "large"
          },
          style: {
            fontSize: ((_k = (_j = theme.typography) == null ? void 0 : _j.pxToRem) == null ? void 0 : _k.call(_j, 35)) || "2.1875rem"
          }
        },
        // TODO v5 deprecate color prop, v6 remove for sx
        ...Object.entries(((_l = theme.vars) != null ? _l : theme).palette).filter(([, value]) => value && value.main).map(([color3]) => {
          var _a2, _b2, _c2;
          return {
            props: {
              color: color3
            },
            style: {
              color: (_c2 = (_b2 = ((_a2 = theme.vars) != null ? _a2 : theme).palette) == null ? void 0 : _b2[color3]) == null ? void 0 : _c2.main
            }
          };
        }),
        {
          props: {
            color: "action"
          },
          style: {
            color: (_o = (_n = ((_m = theme.vars) != null ? _m : theme).palette) == null ? void 0 : _n.action) == null ? void 0 : _o.active
          }
        },
        {
          props: {
            color: "disabled"
          },
          style: {
            color: (_r = (_q = ((_p = theme.vars) != null ? _p : theme).palette) == null ? void 0 : _q.action) == null ? void 0 : _r.disabled
          }
        },
        {
          props: {
            color: "inherit"
          },
          style: {
            color: void 0
          }
        }
      ]
    };
  }));
  var SvgIcon = /* @__PURE__ */ React36.forwardRef(function SvgIcon2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiSvgIcon"
    });
    const _a = props, {
      children,
      className,
      color: color3 = "inherit",
      component = "svg",
      fontSize = "medium",
      htmlColor,
      inheritViewBox = false,
      titleAccess,
      viewBox = "0 0 24 24"
    } = _a, other = __objRest(_a, [
      "children",
      "className",
      "color",
      "component",
      "fontSize",
      "htmlColor",
      "inheritViewBox",
      "titleAccess",
      "viewBox"
    ]);
    const hasSvgAsChild = /* @__PURE__ */ React36.isValidElement(children) && children.type === "svg";
    const ownerState = __spreadProps(__spreadValues({}, props), {
      color: color3,
      component,
      fontSize,
      instanceFontSize: inProps.fontSize,
      inheritViewBox,
      viewBox,
      hasSvgAsChild
    });
    const more = {};
    if (!inheritViewBox) {
      more.viewBox = viewBox;
    }
    const classes = useUtilityClasses(ownerState);
    return /* @__PURE__ */ (0, import_jsx_runtime18.jsxs)(SvgIconRoot, __spreadProps(__spreadValues(__spreadValues(__spreadValues({
      as: component,
      className: clsx_default(classes.root, className),
      focusable: "false",
      color: htmlColor,
      "aria-hidden": titleAccess ? void 0 : true,
      role: titleAccess ? "img" : void 0,
      ref
    }, more), other), hasSvgAsChild && children.props), {
      ownerState,
      children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ (0, import_jsx_runtime18.jsx)("title", {
        children: titleAccess
      }) : null]
    }));
  });
  false ? SvgIcon.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * Node passed into the SVG element.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
     * You can use the `htmlColor` prop to apply a color attribute to the SVG element.
     * @default 'inherit'
     */
    color: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["inherit", "action", "disabled", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types.default.string]),
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * The fontSize applied to the icon. Defaults to 24px, but can be configure to inherit font size.
     * @default 'medium'
     */
    fontSize: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["inherit", "large", "medium", "small"]), import_prop_types.default.string]),
    /**
     * Applies a color attribute to the SVG element.
     */
    htmlColor: import_prop_types.default.string,
    /**
     * If `true`, the root node will inherit the custom `component`'s viewBox and the `viewBox`
     * prop will be ignored.
     * Useful when you want to reference a custom `component` and have `SvgIcon` pass that
     * `component`'s viewBox to the root node.
     * @default false
     */
    inheritViewBox: import_prop_types.default.bool,
    /**
     * The shape-rendering attribute. The behavior of the different options is described on the
     * [MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/shape-rendering).
     * If you are having issues with blurry icons you should investigate this prop.
     */
    shapeRendering: import_prop_types.default.string,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * Provides a human-readable title for the element that contains it.
     * https://www.w3.org/TR/SVG-access/#Equivalent
     */
    titleAccess: import_prop_types.default.string,
    /**
     * Allows you to redefine what the coordinates without units mean inside an SVG element.
     * For example, if the SVG element is 500 (width) by 200 (height),
     * and you pass viewBox="0 0 50 20",
     * this means that the coordinates inside the SVG will go from the top left corner (0,0)
     * to bottom right (50,20) and each unit will be worth 10px.
     * @default '0 0 24 24'
     */
    viewBox: import_prop_types.default.string
  } : void 0;
  SvgIcon.muiName = "SvgIcon";
  var SvgIcon_default = SvgIcon;

  // node_modules/@mui/material/utils/createSvgIcon.js
  var import_jsx_runtime19 = __toESM(require_jsx_runtime());
  function createSvgIcon(path, displayName) {
    function Component(props, ref) {
      return /* @__PURE__ */ (0, import_jsx_runtime19.jsx)(SvgIcon_default, __spreadProps(__spreadValues({
        "data-testid": `${displayName}Icon`,
        ref
      }, props), {
        children: path
      }));
    }
    if (false) {
      Component.displayName = `${displayName}Icon`;
    }
    Component.muiName = SvgIcon_default.muiName;
    return /* @__PURE__ */ React37.memo(/* @__PURE__ */ React37.forwardRef(Component));
  }

  // node_modules/@mui/material/utils/useId.js
  var useId_default = useId;

  // node_modules/@mui/material/utils/useEventCallback.js
  var useEventCallback_default2 = useEventCallback_default;

  // node_modules/@mui/material/utils/useForkRef.js
  var useForkRef_default = useForkRef;

  // node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
  function _objectWithoutPropertiesLoose(r2, e) {
    if (null == r2) return {};
    var t = {};
    for (var n in r2) if ({}.hasOwnProperty.call(r2, n)) {
      if (-1 !== e.indexOf(n)) continue;
      t[n] = r2[n];
    }
    return t;
  }

  // node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
  function _setPrototypeOf(t, e) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
      return t2.__proto__ = e3, t2;
    }, _setPrototypeOf(t, e);
  }

  // node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
  function _inheritsLoose(t, o) {
    t.prototype = Object.create(o.prototype), t.prototype.constructor = t, _setPrototypeOf(t, o);
  }

  // node_modules/react-transition-group/esm/Transition.js
  var import_react9 = __toESM(require_react());
  var import_react_dom = __toESM(require_react_dom());

  // node_modules/react-transition-group/esm/config.js
  var config_default = {
    disabled: false
  };

  // node_modules/react-transition-group/esm/TransitionGroupContext.js
  var import_react8 = __toESM(require_react());
  var TransitionGroupContext_default = import_react8.default.createContext(null);

  // node_modules/react-transition-group/esm/utils/reflow.js
  var forceReflow = function forceReflow2(node2) {
    return node2.scrollTop;
  };

  // node_modules/react-transition-group/esm/Transition.js
  var UNMOUNTED = "unmounted";
  var EXITED = "exited";
  var ENTERING = "entering";
  var ENTERED = "entered";
  var EXITING = "exiting";
  var Transition = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(Transition2, _React$Component);
    function Transition2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var parentGroup = context;
      var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
      var initialStatus;
      _this.appearStatus = null;
      if (props.in) {
        if (appear) {
          initialStatus = EXITED;
          _this.appearStatus = ENTERING;
        } else {
          initialStatus = ENTERED;
        }
      } else {
        if (props.unmountOnExit || props.mountOnEnter) {
          initialStatus = UNMOUNTED;
        } else {
          initialStatus = EXITED;
        }
      }
      _this.state = {
        status: initialStatus
      };
      _this.nextCallback = null;
      return _this;
    }
    Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
      var nextIn = _ref.in;
      if (nextIn && prevState.status === UNMOUNTED) {
        return {
          status: EXITED
        };
      }
      return null;
    };
    var _proto = Transition2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.updateStatus(true, this.appearStatus);
    };
    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
      var nextStatus = null;
      if (prevProps !== this.props) {
        var status = this.state.status;
        if (this.props.in) {
          if (status !== ENTERING && status !== ENTERED) {
            nextStatus = ENTERING;
          }
        } else {
          if (status === ENTERING || status === ENTERED) {
            nextStatus = EXITING;
          }
        }
      }
      this.updateStatus(false, nextStatus);
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.cancelNextCallback();
    };
    _proto.getTimeouts = function getTimeouts() {
      var timeout2 = this.props.timeout;
      var exit, enter, appear;
      exit = enter = appear = timeout2;
      if (timeout2 != null && typeof timeout2 !== "number") {
        exit = timeout2.exit;
        enter = timeout2.enter;
        appear = timeout2.appear !== void 0 ? timeout2.appear : enter;
      }
      return {
        exit,
        enter,
        appear
      };
    };
    _proto.updateStatus = function updateStatus(mounting, nextStatus) {
      if (mounting === void 0) {
        mounting = false;
      }
      if (nextStatus !== null) {
        this.cancelNextCallback();
        if (nextStatus === ENTERING) {
          if (this.props.unmountOnExit || this.props.mountOnEnter) {
            var node2 = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
            if (node2) forceReflow(node2);
          }
          this.performEnter(mounting);
        } else {
          this.performExit();
        }
      } else if (this.props.unmountOnExit && this.state.status === EXITED) {
        this.setState({
          status: UNMOUNTED
        });
      }
    };
    _proto.performEnter = function performEnter(mounting) {
      var _this2 = this;
      var enter = this.props.enter;
      var appearing = this.context ? this.context.isMounting : mounting;
      var _ref2 = this.props.nodeRef ? [appearing] : [import_react_dom.default.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
      var timeouts2 = this.getTimeouts();
      var enterTimeout = appearing ? timeouts2.appear : timeouts2.enter;
      if (!mounting && !enter || config_default.disabled) {
        this.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode);
        });
        return;
      }
      this.props.onEnter(maybeNode, maybeAppearing);
      this.safeSetState({
        status: ENTERING
      }, function() {
        _this2.props.onEntering(maybeNode, maybeAppearing);
        _this2.onTransitionEnd(enterTimeout, function() {
          _this2.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode, maybeAppearing);
          });
        });
      });
    };
    _proto.performExit = function performExit() {
      var _this3 = this;
      var exit = this.props.exit;
      var timeouts2 = this.getTimeouts();
      var maybeNode = this.props.nodeRef ? void 0 : import_react_dom.default.findDOMNode(this);
      if (!exit || config_default.disabled) {
        this.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
        return;
      }
      this.props.onExit(maybeNode);
      this.safeSetState({
        status: EXITING
      }, function() {
        _this3.props.onExiting(maybeNode);
        _this3.onTransitionEnd(timeouts2.exit, function() {
          _this3.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
        });
      });
    };
    _proto.cancelNextCallback = function cancelNextCallback() {
      if (this.nextCallback !== null) {
        this.nextCallback.cancel();
        this.nextCallback = null;
      }
    };
    _proto.safeSetState = function safeSetState(nextState, callback) {
      callback = this.setNextCallback(callback);
      this.setState(nextState, callback);
    };
    _proto.setNextCallback = function setNextCallback(callback) {
      var _this4 = this;
      var active = true;
      this.nextCallback = function(event) {
        if (active) {
          active = false;
          _this4.nextCallback = null;
          callback(event);
        }
      };
      this.nextCallback.cancel = function() {
        active = false;
      };
      return this.nextCallback;
    };
    _proto.onTransitionEnd = function onTransitionEnd(timeout2, handler) {
      this.setNextCallback(handler);
      var node2 = this.props.nodeRef ? this.props.nodeRef.current : import_react_dom.default.findDOMNode(this);
      var doesNotHaveTimeoutOrListener = timeout2 == null && !this.props.addEndListener;
      if (!node2 || doesNotHaveTimeoutOrListener) {
        setTimeout(this.nextCallback, 0);
        return;
      }
      if (this.props.addEndListener) {
        var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
        this.props.addEndListener(maybeNode, maybeNextCallback);
      }
      if (timeout2 != null) {
        setTimeout(this.nextCallback, timeout2);
      }
    };
    _proto.render = function render() {
      var status = this.state.status;
      if (status === UNMOUNTED) {
        return null;
      }
      var _this$props = this.props, children = _this$props.children, _in = _this$props.in, _mountOnEnter = _this$props.mountOnEnter, _unmountOnExit = _this$props.unmountOnExit, _appear = _this$props.appear, _enter = _this$props.enter, _exit = _this$props.exit, _timeout = _this$props.timeout, _addEndListener = _this$props.addEndListener, _onEnter = _this$props.onEnter, _onEntering = _this$props.onEntering, _onEntered = _this$props.onEntered, _onExit = _this$props.onExit, _onExiting = _this$props.onExiting, _onExited = _this$props.onExited, _nodeRef = _this$props.nodeRef, childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
      return (
        // allows for nested Transitions
        /* @__PURE__ */ import_react9.default.createElement(TransitionGroupContext_default.Provider, {
          value: null
        }, typeof children === "function" ? children(status, childProps) : import_react9.default.cloneElement(import_react9.default.Children.only(children), childProps))
      );
    };
    return Transition2;
  }(import_react9.default.Component);
  Transition.contextType = TransitionGroupContext_default;
  Transition.propTypes = false ? {
    /**
     * A React reference to DOM element that need to transition:
     * https://stackoverflow.com/a/51127130/4671932
     *
     *   - When `nodeRef` prop is used, `node` is not passed to callback functions
     *      (e.g. `onEnter`) because user already has direct access to the node.
     *   - When changing `key` prop of `Transition` in a `TransitionGroup` a new
     *     `nodeRef` need to be provided to `Transition` with changed `key` prop
     *     (see
     *     [test/CSSTransition-test.js](https://github.com/reactjs/react-transition-group/blob/13435f897b3ab71f6e19d724f145596f5910581c/test/CSSTransition-test.js#L362-L437)).
     */
    nodeRef: import_prop_types.default.shape({
      current: typeof Element === "undefined" ? import_prop_types.default.any : function(propValue, key, componentName, location2, propFullName, secret) {
        var value = propValue[key];
        return import_prop_types.default.instanceOf(value && "ownerDocument" in value ? value.ownerDocument.defaultView.Element : Element)(propValue, key, componentName, location2, propFullName, secret);
      }
    }),
    /**
     * A `function` child can be used instead of a React element. This function is
     * called with the current transition status (`'entering'`, `'entered'`,
     * `'exiting'`, `'exited'`), which can be used to apply context
     * specific props to a component.
     *
     * ```jsx
     * <Transition in={this.state.in} timeout={150}>
     *   {state => (
     *     <MyComponent className={`fade fade-${state}`} />
     *   )}
     * </Transition>
     * ```
     */
    children: import_prop_types.default.oneOfType([import_prop_types.default.func.isRequired, import_prop_types.default.element.isRequired]).isRequired,
    /**
     * Show the component; triggers the enter or exit states
     */
    in: import_prop_types.default.bool,
    /**
     * By default the child component is mounted immediately along with
     * the parent `Transition` component. If you want to "lazy mount" the component on the
     * first `in={true}` you can set `mountOnEnter`. After the first enter transition the component will stay
     * mounted, even on "exited", unless you also specify `unmountOnExit`.
     */
    mountOnEnter: import_prop_types.default.bool,
    /**
     * By default the child component stays mounted after it reaches the `'exited'` state.
     * Set `unmountOnExit` if you'd prefer to unmount the component after it finishes exiting.
     */
    unmountOnExit: import_prop_types.default.bool,
    /**
     * By default the child component does not perform the enter transition when
     * it first mounts, regardless of the value of `in`. If you want this
     * behavior, set both `appear` and `in` to `true`.
     *
     * > **Note**: there are no special appear states like `appearing`/`appeared`, this prop
     * > only adds an additional enter transition. However, in the
     * > `<CSSTransition>` component that first enter transition does result in
     * > additional `.appear-*` classes, that way you can choose to style it
     * > differently.
     */
    appear: import_prop_types.default.bool,
    /**
     * Enable or disable enter transitions.
     */
    enter: import_prop_types.default.bool,
    /**
     * Enable or disable exit transitions.
     */
    exit: import_prop_types.default.bool,
    /**
     * The duration of the transition, in milliseconds.
     * Required unless `addEndListener` is provided.
     *
     * You may specify a single timeout for all transitions:
     *
     * ```jsx
     * timeout={500}
     * ```
     *
     * or individually:
     *
     * ```jsx
     * timeout={{
     *  appear: 500,
     *  enter: 300,
     *  exit: 500,
     * }}
     * ```
     *
     * - `appear` defaults to the value of `enter`
     * - `enter` defaults to `0`
     * - `exit` defaults to `0`
     *
     * @type {number | { enter?: number, exit?: number, appear?: number }}
     */
    timeout: function timeout(props) {
      var pt = timeoutsShape;
      if (!props.addEndListener) pt = pt.isRequired;
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      return pt.apply(void 0, [props].concat(args));
    },
    /**
     * Add a custom transition end trigger. Called with the transitioning
     * DOM node and a `done` callback. Allows for more fine grained transition end
     * logic. Timeouts are still used as a fallback if provided.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * ```jsx
     * addEndListener={(node, done) => {
     *   // use the css transitionend event to mark the finish of a transition
     *   node.addEventListener('transitionend', done, false);
     * }}
     * ```
     */
    addEndListener: import_prop_types.default.func,
    /**
     * Callback fired before the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEnter: import_prop_types.default.func,
    /**
     * Callback fired after the "entering" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool)
     */
    onEntering: import_prop_types.default.func,
    /**
     * Callback fired after the "entered" status is applied. An extra parameter
     * `isAppearing` is supplied to indicate if the enter stage is occurring on the initial mount
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement, isAppearing: bool) -> void
     */
    onEntered: import_prop_types.default.func,
    /**
     * Callback fired before the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExit: import_prop_types.default.func,
    /**
     * Callback fired after the "exiting" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed.
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExiting: import_prop_types.default.func,
    /**
     * Callback fired after the "exited" status is applied.
     *
     * **Note**: when `nodeRef` prop is passed, `node` is not passed
     *
     * @type Function(node: HtmlElement) -> void
     */
    onExited: import_prop_types.default.func
  } : {};
  function noop3() {
  }
  Transition.defaultProps = {
    in: false,
    mountOnEnter: false,
    unmountOnExit: false,
    appear: false,
    enter: true,
    exit: true,
    onEnter: noop3,
    onEntering: noop3,
    onEntered: noop3,
    onExit: noop3,
    onExiting: noop3,
    onExited: noop3
  };
  Transition.UNMOUNTED = UNMOUNTED;
  Transition.EXITED = EXITED;
  Transition.ENTERING = ENTERING;
  Transition.ENTERED = ENTERED;
  Transition.EXITING = EXITING;
  var Transition_default = Transition;

  // node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
  function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }

  // node_modules/react-transition-group/esm/TransitionGroup.js
  var import_react11 = __toESM(require_react());

  // node_modules/react-transition-group/esm/utils/ChildMapping.js
  var import_react10 = __toESM(require_react());
  function getChildMapping(children, mapFn) {
    var mapper = function mapper2(child) {
      return mapFn && (0, import_react10.isValidElement)(child) ? mapFn(child) : child;
    };
    var result = /* @__PURE__ */ Object.create(null);
    if (children) import_react10.Children.map(children, function(c) {
      return c;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
    return result;
  }
  function mergeChildMappings(prev2, next2) {
    prev2 = prev2 || {};
    next2 = next2 || {};
    function getValueForKey(key) {
      return key in next2 ? next2[key] : prev2[key];
    }
    var nextKeysPending = /* @__PURE__ */ Object.create(null);
    var pendingKeys = [];
    for (var prevKey in prev2) {
      if (prevKey in next2) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }
    var i;
    var childMapping = {};
    for (var nextKey2 in next2) {
      if (nextKeysPending[nextKey2]) {
        for (i = 0; i < nextKeysPending[nextKey2].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey2][i];
          childMapping[nextKeysPending[nextKey2][i]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey2] = getValueForKey(nextKey2);
    }
    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }
    return childMapping;
  }
  function getProp(child, prop, props) {
    return props[prop] != null ? props[prop] : child.props[prop];
  }
  function getInitialChildMapping(props, onExited) {
    return getChildMapping(props.children, function(child) {
      return (0, import_react10.cloneElement)(child, {
        onExited: onExited.bind(null, child),
        in: true,
        appear: getProp(child, "appear", props),
        enter: getProp(child, "enter", props),
        exit: getProp(child, "exit", props)
      });
    });
  }
  function getNextChildMapping(nextProps, prevChildMapping, onExited) {
    var nextChildMapping = getChildMapping(nextProps.children);
    var children = mergeChildMappings(prevChildMapping, nextChildMapping);
    Object.keys(children).forEach(function(key) {
      var child = children[key];
      if (!(0, import_react10.isValidElement)(child)) return;
      var hasPrev = key in prevChildMapping;
      var hasNext = key in nextChildMapping;
      var prevChild = prevChildMapping[key];
      var isLeaving = (0, import_react10.isValidElement)(prevChild) && !prevChild.props.in;
      if (hasNext && (!hasPrev || isLeaving)) {
        children[key] = (0, import_react10.cloneElement)(child, {
          onExited: onExited.bind(null, child),
          in: true,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      } else if (!hasNext && hasPrev && !isLeaving) {
        children[key] = (0, import_react10.cloneElement)(child, {
          in: false
        });
      } else if (hasNext && hasPrev && (0, import_react10.isValidElement)(prevChild)) {
        children[key] = (0, import_react10.cloneElement)(child, {
          onExited: onExited.bind(null, child),
          in: prevChild.props.in,
          exit: getProp(child, "exit", nextProps),
          enter: getProp(child, "enter", nextProps)
        });
      }
    });
    return children;
  }

  // node_modules/react-transition-group/esm/TransitionGroup.js
  var values2 = Object.values || function(obj) {
    return Object.keys(obj).map(function(k) {
      return obj[k];
    });
  };
  var defaultProps = {
    component: "div",
    childFactory: function childFactory(child) {
      return child;
    }
  };
  var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
    _inheritsLoose(TransitionGroup2, _React$Component);
    function TransitionGroup2(props, context) {
      var _this;
      _this = _React$Component.call(this, props, context) || this;
      var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
      _this.state = {
        contextValue: {
          isMounting: true
        },
        handleExited,
        firstRender: true
      };
      return _this;
    }
    var _proto = TransitionGroup2.prototype;
    _proto.componentDidMount = function componentDidMount() {
      this.mounted = true;
      this.setState({
        contextValue: {
          isMounting: false
        }
      });
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.mounted = false;
    };
    TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
      var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
      return {
        children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
        firstRender: false
      };
    };
    _proto.handleExited = function handleExited(child, node2) {
      var currentChildMapping = getChildMapping(this.props.children);
      if (child.key in currentChildMapping) return;
      if (child.props.onExited) {
        child.props.onExited(node2);
      }
      if (this.mounted) {
        this.setState(function(state) {
          var children = _extends({}, state.children);
          delete children[child.key];
          return {
            children
          };
        });
      }
    };
    _proto.render = function render() {
      var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
      var contextValue = this.state.contextValue;
      var children = values2(this.state.children).map(childFactory2);
      delete props.appear;
      delete props.enter;
      delete props.exit;
      if (Component === null) {
        return /* @__PURE__ */ import_react11.default.createElement(TransitionGroupContext_default.Provider, {
          value: contextValue
        }, children);
      }
      return /* @__PURE__ */ import_react11.default.createElement(TransitionGroupContext_default.Provider, {
        value: contextValue
      }, /* @__PURE__ */ import_react11.default.createElement(Component, props, children));
    };
    return TransitionGroup2;
  }(import_react11.default.Component);
  TransitionGroup.propTypes = false ? {
    /**
     * `<TransitionGroup>` renders a `<div>` by default. You can change this
     * behavior by providing a `component` prop.
     * If you use React v16+ and would like to avoid a wrapping `<div>` element
     * you can pass in `component={null}`. This is useful if the wrapping div
     * borks your css styles.
     */
    component: import_prop_types.default.any,
    /**
     * A set of `<Transition>` components, that are toggled `in` and out as they
     * leave. the `<TransitionGroup>` will inject specific transition props, so
     * remember to spread them through if you are wrapping the `<Transition>` as
     * with our `<Fade>` example.
     *
     * While this component is meant for multiple `Transition` or `CSSTransition`
     * children, sometimes you may want to have a single transition child with
     * content that you want to be transitioned out and in when you change it
     * (e.g. routes, images etc.) In that case you can change the `key` prop of
     * the transition child as you change its content, this will cause
     * `TransitionGroup` to transition the child out and back in.
     */
    children: import_prop_types.default.node,
    /**
     * A convenience prop that enables or disables appear animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    appear: import_prop_types.default.bool,
    /**
     * A convenience prop that enables or disables enter animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    enter: import_prop_types.default.bool,
    /**
     * A convenience prop that enables or disables exit animations
     * for all children. Note that specifying this will override any defaults set
     * on individual children Transitions.
     */
    exit: import_prop_types.default.bool,
    /**
     * You may need to apply reactive updates to a child as it is exiting.
     * This is generally done by using `cloneElement` however in the case of an exiting
     * child the element has already been removed and not accessible to the consumer.
     *
     * If you do need to update a child as it leaves you can provide a `childFactory`
     * to wrap every child, even the ones that are leaving.
     *
     * @type Function(child: ReactElement) -> ReactElement
     */
    childFactory: import_prop_types.default.func
  } : {};
  TransitionGroup.defaultProps = defaultProps;
  var TransitionGroup_default = TransitionGroup;

  // node_modules/@mui/material/transitions/utils.js
  var reflow = (node2) => node2.scrollTop;
  function getTransitionProps(props, options) {
    var _a, _b;
    const {
      timeout: timeout2,
      easing: easing2,
      style: style4 = {}
    } = props;
    return {
      duration: (_a = style4.transitionDuration) != null ? _a : typeof timeout2 === "number" ? timeout2 : timeout2[options.mode] || 0,
      easing: (_b = style4.transitionTimingFunction) != null ? _b : typeof easing2 === "object" ? easing2[options.mode] : easing2,
      delay: style4.transitionDelay
    };
  }

  // node_modules/@mui/material/Paper/Paper.js
  var React41 = __toESM(require_react());

  // node_modules/@mui/material/Paper/paperClasses.js
  function getPaperUtilityClass(slot) {
    return generateUtilityClass("MuiPaper", slot);
  }
  var paperClasses = generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);

  // node_modules/@mui/material/Paper/Paper.js
  var import_jsx_runtime20 = __toESM(require_jsx_runtime());
  var useUtilityClasses2 = (ownerState) => {
    const {
      square,
      elevation,
      variant,
      classes
    } = ownerState;
    const slots = {
      root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
    };
    return composeClasses(slots, getPaperUtilityClass, classes);
  };
  var PaperRoot = styled_default2("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    transition: theme.transitions.create("box-shadow"),
    variants: [{
      props: ({
        ownerState
      }) => !ownerState.square,
      style: {
        borderRadius: theme.shape.borderRadius
      }
    }, {
      props: {
        variant: "outlined"
      },
      style: {
        border: `1px solid ${(theme.vars || theme).palette.divider}`
      }
    }, {
      props: {
        variant: "elevation"
      },
      style: {
        boxShadow: "var(--Paper-shadow)",
        backgroundImage: "var(--Paper-overlay)"
      }
    }]
  })));
  var Paper = /* @__PURE__ */ React41.forwardRef(function Paper2(inProps, ref) {
    var _b;
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiPaper"
    });
    const theme = useTheme5();
    const _a = props, {
      className,
      component = "div",
      elevation = 1,
      square = false,
      variant = "elevation"
    } = _a, other = __objRest(_a, [
      "className",
      "component",
      "elevation",
      "square",
      "variant"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      component,
      elevation,
      square,
      variant
    });
    const classes = useUtilityClasses2(ownerState);
    if (false) {
      if (theme.shadows[elevation] === void 0) {
        console.error([`MUI: The elevation provided <Paper elevation={${elevation}}> is not available in the theme.`, `Please make sure that \`theme.shadows[${elevation}]\` is defined.`].join("\n"));
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime20.jsx)(PaperRoot, __spreadProps(__spreadValues({
      as: component,
      ownerState,
      className: clsx_default(classes.root, className),
      ref
    }, other), {
      style: __spreadValues(__spreadValues({}, variant === "elevation" && __spreadValues(__spreadValues({
        "--Paper-shadow": (theme.vars || theme).shadows[elevation]
      }, theme.vars && {
        "--Paper-overlay": (_b = theme.vars.overlays) == null ? void 0 : _b[elevation]
      }), !theme.vars && theme.palette.mode === "dark" && {
        "--Paper-overlay": `linear-gradient(${alpha("#fff", getOverlayAlpha(elevation))}, ${alpha("#fff", getOverlayAlpha(elevation))})`
      })), other.style)
    }));
  });
  false ? Paper.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the component.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * Shadow depth, corresponds to `dp` in the spec.
     * It accepts values between 0 and 24 inclusive.
     * @default 1
     */
    elevation: chainPropTypes(integerPropType_default, (props) => {
      const {
        elevation,
        variant
      } = props;
      if (elevation > 0 && variant === "outlined") {
        return new Error(`MUI: Combining \`elevation={${elevation}}\` with \`variant="${variant}"\` has no effect. Either use \`elevation={0}\` or use a different \`variant\`.`);
      }
      return null;
    }),
    /**
     * If `true`, rounded corners are disabled.
     * @default false
     */
    square: import_prop_types.default.bool,
    /**
     * @ignore
     */
    style: import_prop_types.default.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * The variant to use.
     * @default 'elevation'
     */
    variant: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["elevation", "outlined"]), import_prop_types.default.string])
  } : void 0;
  var Paper_default = Paper;

  // node_modules/@mui/material/utils/useSlot.js
  function useSlot(name, parameters) {
    const _a = parameters, {
      className,
      elementType: initialElementType,
      ownerState,
      externalForwardedProps,
      internalForwardedProps,
      shouldForwardComponentProp = false
    } = _a, useSlotPropsParams = __objRest(_a, [
      "className",
      "elementType",
      "ownerState",
      "externalForwardedProps",
      "internalForwardedProps",
      "shouldForwardComponentProp"
    ]);
    const _b = externalForwardedProps, {
      component: rootComponent,
      slots = {
        [name]: void 0
      },
      slotProps = {
        [name]: void 0
      }
    } = _b, other = __objRest(_b, [
      "component",
      "slots",
      "slotProps"
    ]);
    const elementType = slots[name] || initialElementType;
    const resolvedComponentsProps = resolveComponentProps_default(slotProps[name], ownerState);
    const _c = mergeSlotProps_default(__spreadProps(__spreadValues({
      className
    }, useSlotPropsParams), {
      externalForwardedProps: name === "root" ? other : void 0,
      externalSlotProps: resolvedComponentsProps
    })), {
      props: _d
    } = _c, _e = _d, {
      component: slotComponent
    } = _e, mergedProps = __objRest(_e, [
      "component"
    ]), {
      internalRef
    } = _c;
    const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, parameters.ref);
    const LeafComponent = name === "root" ? slotComponent || rootComponent : slotComponent;
    const props = appendOwnerState_default(elementType, __spreadProps(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, name === "root" && !rootComponent && !slots[name] && internalForwardedProps), name !== "root" && !slots[name] && internalForwardedProps), mergedProps), LeafComponent && !shouldForwardComponentProp && {
      as: LeafComponent
    }), LeafComponent && shouldForwardComponentProp && {
      component: LeafComponent
    }), {
      ref
    }), ownerState);
    return [elementType, props];
  }

  // node_modules/@mui/material/ButtonBase/ButtonBase.js
  var React45 = __toESM(require_react());

  // node_modules/@mui/material/useLazyRipple/useLazyRipple.js
  var React42 = __toESM(require_react());
  var LazyRipple = class _LazyRipple {
    constructor() {
      __publicField(this, "mountEffect", () => {
        if (this.shouldMount && !this.didMount) {
          if (this.ref.current !== null) {
            this.didMount = true;
            this.mounted.resolve();
          }
        }
      });
      this.ref = {
        current: null
      };
      this.mounted = null;
      this.didMount = false;
      this.shouldMount = false;
      this.setShouldMount = null;
    }
    /** React ref to the ripple instance */
    /** If the ripple component should be mounted */
    /** Promise that resolves when the ripple component is mounted */
    /** If the ripple component has been mounted */
    /** React state hook setter */
    static create() {
      return new _LazyRipple();
    }
    static use() {
      const ripple = useLazyRef(_LazyRipple.create).current;
      const [shouldMount, setShouldMount] = React42.useState(false);
      ripple.shouldMount = shouldMount;
      ripple.setShouldMount = setShouldMount;
      React42.useEffect(ripple.mountEffect, [shouldMount]);
      return ripple;
    }
    mount() {
      if (!this.mounted) {
        this.mounted = createControlledPromise();
        this.shouldMount = true;
        this.setShouldMount(this.shouldMount);
      }
      return this.mounted;
    }
    /* Ripple API */
    start(...args) {
      this.mount().then(() => {
        var _a;
        return (_a = this.ref.current) == null ? void 0 : _a.start(...args);
      });
    }
    stop(...args) {
      this.mount().then(() => {
        var _a;
        return (_a = this.ref.current) == null ? void 0 : _a.stop(...args);
      });
    }
    pulsate(...args) {
      this.mount().then(() => {
        var _a;
        return (_a = this.ref.current) == null ? void 0 : _a.pulsate(...args);
      });
    }
  };
  function useLazyRipple() {
    return LazyRipple.use();
  }
  function createControlledPromise() {
    let resolve;
    let reject;
    const p = new Promise((resolveFn, rejectFn) => {
      resolve = resolveFn;
      reject = rejectFn;
    });
    p.resolve = resolve;
    p.reject = reject;
    return p;
  }

  // node_modules/@mui/material/ButtonBase/TouchRipple.js
  var React44 = __toESM(require_react());

  // node_modules/@mui/material/ButtonBase/Ripple.js
  var React43 = __toESM(require_react());
  var import_jsx_runtime21 = __toESM(require_jsx_runtime());
  function Ripple(props) {
    const {
      className,
      classes,
      pulsate = false,
      rippleX,
      rippleY,
      rippleSize,
      in: inProp,
      onExited,
      timeout: timeout2
    } = props;
    const [leaving, setLeaving] = React43.useState(false);
    const rippleClassName = clsx_default(className, classes.ripple, classes.rippleVisible, pulsate && classes.ripplePulsate);
    const rippleStyles = {
      width: rippleSize,
      height: rippleSize,
      top: -(rippleSize / 2) + rippleY,
      left: -(rippleSize / 2) + rippleX
    };
    const childClassName = clsx_default(classes.child, leaving && classes.childLeaving, pulsate && classes.childPulsate);
    if (!inProp && !leaving) {
      setLeaving(true);
    }
    React43.useEffect(() => {
      if (!inProp && onExited != null) {
        const timeoutId = setTimeout(onExited, timeout2);
        return () => {
          clearTimeout(timeoutId);
        };
      }
      return void 0;
    }, [onExited, inProp, timeout2]);
    return /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("span", {
      className: rippleClassName,
      style: rippleStyles,
      children: /* @__PURE__ */ (0, import_jsx_runtime21.jsx)("span", {
        className: childClassName
      })
    });
  }
  false ? Ripple.propTypes = {
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object.isRequired,
    className: import_prop_types.default.string,
    /**
     * @ignore - injected from TransitionGroup
     */
    in: import_prop_types.default.bool,
    /**
     * @ignore - injected from TransitionGroup
     */
    onExited: import_prop_types.default.func,
    /**
     * If `true`, the ripple pulsates, typically indicating the keyboard focus state of an element.
     */
    pulsate: import_prop_types.default.bool,
    /**
     * Diameter of the ripple.
     */
    rippleSize: import_prop_types.default.number,
    /**
     * Horizontal position of the ripple center.
     */
    rippleX: import_prop_types.default.number,
    /**
     * Vertical position of the ripple center.
     */
    rippleY: import_prop_types.default.number,
    /**
     * exit delay
     */
    timeout: import_prop_types.default.number.isRequired
  } : void 0;
  var Ripple_default = Ripple;

  // node_modules/@mui/material/ButtonBase/touchRippleClasses.js
  var touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
  var touchRippleClasses_default = touchRippleClasses;

  // node_modules/@mui/material/ButtonBase/TouchRipple.js
  var import_jsx_runtime22 = __toESM(require_jsx_runtime());
  var DURATION = 550;
  var DELAY_RIPPLE = 80;
  var enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`;
  var exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`;
  var pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`;
  var TouchRippleRoot = styled_default2("span", {
    name: "MuiTouchRipple",
    slot: "Root"
  })({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
  });
  var TouchRippleRipple = styled_default2(Ripple_default, {
    name: "MuiTouchRipple",
    slot: "Ripple"
  })`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses_default.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
    theme
  }) => theme.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses_default.ripplePulsate} {
    animation-duration: ${({
    theme
  }) => theme.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses_default.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses_default.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${({
    theme
  }) => theme.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses_default.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${({
    theme
  }) => theme.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`;
  var TouchRipple = /* @__PURE__ */ React44.forwardRef(function TouchRipple2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiTouchRipple"
    });
    const _a = props, {
      center: centerProp = false,
      classes = {},
      className
    } = _a, other = __objRest(_a, [
      "center",
      "classes",
      "className"
    ]);
    const [ripples, setRipples] = React44.useState([]);
    const nextKey2 = React44.useRef(0);
    const rippleCallback = React44.useRef(null);
    React44.useEffect(() => {
      if (rippleCallback.current) {
        rippleCallback.current();
        rippleCallback.current = null;
      }
    }, [ripples]);
    const ignoringMouseDown = React44.useRef(false);
    const startTimer = useTimeout();
    const startTimerCommit = React44.useRef(null);
    const container2 = React44.useRef(null);
    const startCommit = React44.useCallback((params) => {
      const {
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb
      } = params;
      setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(TouchRippleRipple, {
        classes: {
          ripple: clsx_default(classes.ripple, touchRippleClasses_default.ripple),
          rippleVisible: clsx_default(classes.rippleVisible, touchRippleClasses_default.rippleVisible),
          ripplePulsate: clsx_default(classes.ripplePulsate, touchRippleClasses_default.ripplePulsate),
          child: clsx_default(classes.child, touchRippleClasses_default.child),
          childLeaving: clsx_default(classes.childLeaving, touchRippleClasses_default.childLeaving),
          childPulsate: clsx_default(classes.childPulsate, touchRippleClasses_default.childPulsate)
        },
        timeout: DURATION,
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize
      }, nextKey2.current)]);
      nextKey2.current += 1;
      rippleCallback.current = cb;
    }, [classes]);
    const start3 = React44.useCallback((event = {}, options = {}, cb = () => {
    }) => {
      const {
        pulsate: pulsate2 = false,
        center = centerProp || options.pulsate,
        fakeElement = false
        // For test purposes
      } = options;
      if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
        ignoringMouseDown.current = false;
        return;
      }
      if ((event == null ? void 0 : event.type) === "touchstart") {
        ignoringMouseDown.current = true;
      }
      const element = fakeElement ? null : container2.current;
      const rect = element ? element.getBoundingClientRect() : {
        width: 0,
        height: 0,
        left: 0,
        top: 0
      };
      let rippleX;
      let rippleY;
      let rippleSize;
      if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
        rippleX = Math.round(rect.width / 2);
        rippleY = Math.round(rect.height / 2);
      } else {
        const {
          clientX,
          clientY
        } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
        rippleX = Math.round(clientX - rect.left);
        rippleY = Math.round(clientY - rect.top);
      }
      if (center) {
        rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
        if (rippleSize % 2 === 0) {
          rippleSize += 1;
        }
      } else {
        const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
        const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
        rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
      }
      if (event == null ? void 0 : event.touches) {
        if (startTimerCommit.current === null) {
          startTimerCommit.current = () => {
            startCommit({
              pulsate: pulsate2,
              rippleX,
              rippleY,
              rippleSize,
              cb
            });
          };
          startTimer.start(DELAY_RIPPLE, () => {
            if (startTimerCommit.current) {
              startTimerCommit.current();
              startTimerCommit.current = null;
            }
          });
        }
      } else {
        startCommit({
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize,
          cb
        });
      }
    }, [centerProp, startCommit, startTimer]);
    const pulsate = React44.useCallback(() => {
      start3({}, {
        pulsate: true
      });
    }, [start3]);
    const stop2 = React44.useCallback((event, cb) => {
      startTimer.clear();
      if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
        startTimerCommit.current();
        startTimerCommit.current = null;
        startTimer.start(0, () => {
          stop2(event, cb);
        });
        return;
      }
      startTimerCommit.current = null;
      setRipples((oldRipples) => {
        if (oldRipples.length > 0) {
          return oldRipples.slice(1);
        }
        return oldRipples;
      });
      rippleCallback.current = cb;
    }, [startTimer]);
    React44.useImperativeHandle(ref, () => ({
      pulsate,
      start: start3,
      stop: stop2
    }), [pulsate, start3, stop2]);
    return /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(TouchRippleRoot, __spreadProps(__spreadValues({
      className: clsx_default(touchRippleClasses_default.root, classes.root, className),
      ref: container2
    }, other), {
      children: /* @__PURE__ */ (0, import_jsx_runtime22.jsx)(TransitionGroup_default, {
        component: null,
        exit: true,
        children: ripples
      })
    }));
  });
  false ? TouchRipple.propTypes = {
    /**
     * If `true`, the ripple starts at the center of the component
     * rather than at the point of interaction.
     */
    center: import_prop_types.default.bool,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string
  } : void 0;
  var TouchRipple_default = TouchRipple;

  // node_modules/@mui/material/ButtonBase/buttonBaseClasses.js
  function getButtonBaseUtilityClass(slot) {
    return generateUtilityClass("MuiButtonBase", slot);
  }
  var buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
  var buttonBaseClasses_default = buttonBaseClasses;

  // node_modules/@mui/material/ButtonBase/ButtonBase.js
  var import_jsx_runtime23 = __toESM(require_jsx_runtime());
  var useUtilityClasses3 = (ownerState) => {
    const {
      disabled,
      focusVisible,
      focusVisibleClassName,
      classes
    } = ownerState;
    const slots = {
      root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
    };
    const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes);
    if (focusVisible && focusVisibleClassName) {
      composedClasses.root += ` ${focusVisibleClassName}`;
    }
    return composedClasses;
  };
  var ButtonBaseRoot = styled_default2("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    // Reset default value
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    border: 0,
    margin: 0,
    // Remove the margin in Safari
    borderRadius: 0,
    padding: 0,
    // Remove the padding in Firefox
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    // Reset
    WebkitAppearance: "none",
    // Reset
    textDecoration: "none",
    // So we take precedent over the style of a native <a /> element.
    color: "inherit",
    "&::-moz-focus-inner": {
      borderStyle: "none"
      // Remove Firefox dotted outline.
    },
    [`&.${buttonBaseClasses_default.disabled}`]: {
      pointerEvents: "none",
      // Disable link interactions
      cursor: "default"
    },
    "@media print": {
      colorAdjust: "exact"
    }
  });
  var ButtonBase = /* @__PURE__ */ React45.forwardRef(function ButtonBase2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiButtonBase"
    });
    const _a = props, {
      action,
      centerRipple = false,
      children,
      className,
      component = "button",
      disabled = false,
      disableRipple = false,
      disableTouchRipple = false,
      focusRipple = false,
      focusVisibleClassName,
      LinkComponent = "a",
      onBlur,
      onClick,
      onContextMenu,
      onDragLeave,
      onFocus,
      onFocusVisible,
      onKeyDown,
      onKeyUp,
      onMouseDown,
      onMouseLeave,
      onMouseUp,
      onTouchEnd,
      onTouchMove,
      onTouchStart,
      tabIndex = 0,
      TouchRippleProps,
      touchRippleRef,
      type
    } = _a, other = __objRest(_a, [
      "action",
      "centerRipple",
      "children",
      "className",
      "component",
      "disabled",
      "disableRipple",
      "disableTouchRipple",
      "focusRipple",
      "focusVisibleClassName",
      "LinkComponent",
      "onBlur",
      "onClick",
      "onContextMenu",
      "onDragLeave",
      "onFocus",
      "onFocusVisible",
      "onKeyDown",
      "onKeyUp",
      "onMouseDown",
      "onMouseLeave",
      "onMouseUp",
      "onTouchEnd",
      "onTouchMove",
      "onTouchStart",
      "tabIndex",
      "TouchRippleProps",
      "touchRippleRef",
      "type"
    ]);
    const buttonRef = React45.useRef(null);
    const ripple = useLazyRipple();
    const handleRippleRef = useForkRef_default(ripple.ref, touchRippleRef);
    const [focusVisible, setFocusVisible] = React45.useState(false);
    if (disabled && focusVisible) {
      setFocusVisible(false);
    }
    React45.useImperativeHandle(action, () => ({
      focusVisible: () => {
        setFocusVisible(true);
        buttonRef.current.focus();
      }
    }), []);
    const enableTouchRipple = ripple.shouldMount && !disableRipple && !disabled;
    React45.useEffect(() => {
      if (focusVisible && focusRipple && !disableRipple) {
        ripple.pulsate();
      }
    }, [disableRipple, focusRipple, focusVisible, ripple]);
    const handleMouseDown = useRippleHandler(ripple, "start", onMouseDown, disableTouchRipple);
    const handleContextMenu = useRippleHandler(ripple, "stop", onContextMenu, disableTouchRipple);
    const handleDragLeave = useRippleHandler(ripple, "stop", onDragLeave, disableTouchRipple);
    const handleMouseUp = useRippleHandler(ripple, "stop", onMouseUp, disableTouchRipple);
    const handleMouseLeave = useRippleHandler(ripple, "stop", (event) => {
      if (focusVisible) {
        event.preventDefault();
      }
      if (onMouseLeave) {
        onMouseLeave(event);
      }
    }, disableTouchRipple);
    const handleTouchStart = useRippleHandler(ripple, "start", onTouchStart, disableTouchRipple);
    const handleTouchEnd = useRippleHandler(ripple, "stop", onTouchEnd, disableTouchRipple);
    const handleTouchMove = useRippleHandler(ripple, "stop", onTouchMove, disableTouchRipple);
    const handleBlur = useRippleHandler(ripple, "stop", (event) => {
      if (!isFocusVisible(event.target)) {
        setFocusVisible(false);
      }
      if (onBlur) {
        onBlur(event);
      }
    }, false);
    const handleFocus = useEventCallback_default2((event) => {
      if (!buttonRef.current) {
        buttonRef.current = event.currentTarget;
      }
      if (isFocusVisible(event.target)) {
        setFocusVisible(true);
        if (onFocusVisible) {
          onFocusVisible(event);
        }
      }
      if (onFocus) {
        onFocus(event);
      }
    });
    const isNonNativeButton = () => {
      const button = buttonRef.current;
      return component && component !== "button" && !(button.tagName === "A" && button.href);
    };
    const handleKeyDown = useEventCallback_default2((event) => {
      if (focusRipple && !event.repeat && focusVisible && event.key === " ") {
        ripple.stop(event, () => {
          ripple.start(event);
        });
      }
      if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
        event.preventDefault();
      }
      if (onKeyDown) {
        onKeyDown(event);
      }
      if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
        event.preventDefault();
        if (onClick) {
          onClick(event);
        }
      }
    });
    const handleKeyUp = useEventCallback_default2((event) => {
      if (focusRipple && event.key === " " && focusVisible && !event.defaultPrevented) {
        ripple.stop(event, () => {
          ripple.pulsate(event);
        });
      }
      if (onKeyUp) {
        onKeyUp(event);
      }
      if (onClick && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
        onClick(event);
      }
    });
    let ComponentProp = component;
    if (ComponentProp === "button" && (other.href || other.to)) {
      ComponentProp = LinkComponent;
    }
    const buttonProps = {};
    if (ComponentProp === "button") {
      buttonProps.type = type === void 0 ? "button" : type;
      buttonProps.disabled = disabled;
    } else {
      if (!other.href && !other.to) {
        buttonProps.role = "button";
      }
      if (disabled) {
        buttonProps["aria-disabled"] = disabled;
      }
    }
    const handleRef = useForkRef_default(ref, buttonRef);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      centerRipple,
      component,
      disabled,
      disableRipple,
      disableTouchRipple,
      focusRipple,
      tabIndex,
      focusVisible
    });
    const classes = useUtilityClasses3(ownerState);
    return /* @__PURE__ */ (0, import_jsx_runtime23.jsxs)(ButtonBaseRoot, __spreadProps(__spreadValues(__spreadValues({
      as: ComponentProp,
      className: clsx_default(classes.root, className),
      ownerState,
      onBlur: handleBlur,
      onClick,
      onContextMenu: handleContextMenu,
      onFocus: handleFocus,
      onKeyDown: handleKeyDown,
      onKeyUp: handleKeyUp,
      onMouseDown: handleMouseDown,
      onMouseLeave: handleMouseLeave,
      onMouseUp: handleMouseUp,
      onDragLeave: handleDragLeave,
      onTouchEnd: handleTouchEnd,
      onTouchMove: handleTouchMove,
      onTouchStart: handleTouchStart,
      ref: handleRef,
      tabIndex: disabled ? -1 : tabIndex,
      type
    }, buttonProps), other), {
      children: [children, enableTouchRipple ? /* @__PURE__ */ (0, import_jsx_runtime23.jsx)(TouchRipple_default, __spreadValues({
        ref: handleRippleRef,
        center: centerRipple
      }, TouchRippleProps)) : null]
    }));
  });
  function useRippleHandler(ripple, rippleAction, eventCallback, skipRippleAction = false) {
    return useEventCallback_default2((event) => {
      if (eventCallback) {
        eventCallback(event);
      }
      if (!skipRippleAction) {
        ripple[rippleAction](event);
      }
      return true;
    });
  }
  false ? ButtonBase.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * A ref for imperative actions.
     * It currently only supports `focusVisible()` action.
     */
    action: refType_default,
    /**
     * If `true`, the ripples are centered.
     * They won't start at the cursor interaction position.
     * @default false
     */
    centerRipple: import_prop_types.default.bool,
    /**
     * The content of the component.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: elementTypeAcceptingRef_default,
    /**
     * If `true`, the component is disabled.
     * @default false
     */
    disabled: import_prop_types.default.bool,
    /**
     * If `true`, the ripple effect is disabled.
     *
     * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
     * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
     * @default false
     */
    disableRipple: import_prop_types.default.bool,
    /**
     * If `true`, the touch ripple effect is disabled.
     * @default false
     */
    disableTouchRipple: import_prop_types.default.bool,
    /**
     * If `true`, the base button will have a keyboard focus ripple.
     * @default false
     */
    focusRipple: import_prop_types.default.bool,
    /**
     * This prop can help identify which element has keyboard focus.
     * The class name will be applied when the element gains the focus through keyboard interaction.
     * It's a polyfill for the [CSS :focus-visible selector](https://drafts.csswg.org/selectors-4/#the-focus-visible-pseudo).
     * The rationale for using this feature [is explained here](https://github.com/WICG/focus-visible/blob/HEAD/explainer.md).
     * A [polyfill can be used](https://github.com/WICG/focus-visible) to apply a `focus-visible` class to other components
     * if needed.
     */
    focusVisibleClassName: import_prop_types.default.string,
    /**
     * @ignore
     */
    href: import_prop_types.default.any,
    /**
     * The component used to render a link when the `href` prop is provided.
     * @default 'a'
     */
    LinkComponent: import_prop_types.default.elementType,
    /**
     * @ignore
     */
    onBlur: import_prop_types.default.func,
    /**
     * @ignore
     */
    onClick: import_prop_types.default.func,
    /**
     * @ignore
     */
    onContextMenu: import_prop_types.default.func,
    /**
     * @ignore
     */
    onDragLeave: import_prop_types.default.func,
    /**
     * @ignore
     */
    onFocus: import_prop_types.default.func,
    /**
     * Callback fired when the component is focused with a keyboard.
     * We trigger a `onFocus` callback too.
     */
    onFocusVisible: import_prop_types.default.func,
    /**
     * @ignore
     */
    onKeyDown: import_prop_types.default.func,
    /**
     * @ignore
     */
    onKeyUp: import_prop_types.default.func,
    /**
     * @ignore
     */
    onMouseDown: import_prop_types.default.func,
    /**
     * @ignore
     */
    onMouseLeave: import_prop_types.default.func,
    /**
     * @ignore
     */
    onMouseUp: import_prop_types.default.func,
    /**
     * @ignore
     */
    onTouchEnd: import_prop_types.default.func,
    /**
     * @ignore
     */
    onTouchMove: import_prop_types.default.func,
    /**
     * @ignore
     */
    onTouchStart: import_prop_types.default.func,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * @default 0
     */
    tabIndex: import_prop_types.default.number,
    /**
     * Props applied to the `TouchRipple` element.
     */
    TouchRippleProps: import_prop_types.default.object,
    /**
     * A ref that points to the `TouchRipple` element.
     */
    touchRippleRef: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.shape({
      current: import_prop_types.default.shape({
        pulsate: import_prop_types.default.func.isRequired,
        start: import_prop_types.default.func.isRequired,
        stop: import_prop_types.default.func.isRequired
      })
    })]),
    /**
     * @ignore
     */
    type: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["button", "reset", "submit"]), import_prop_types.default.string])
  } : void 0;
  var ButtonBase_default = ButtonBase;

  // node_modules/@mui/material/utils/createSimplePaletteValueFilter.js
  function hasCorrectMainProperty(obj) {
    return typeof obj.main === "string";
  }
  function checkSimplePaletteColorValues(obj, additionalPropertiesToCheck = []) {
    if (!hasCorrectMainProperty(obj)) {
      return false;
    }
    for (const value of additionalPropertiesToCheck) {
      if (!obj.hasOwnProperty(value) || typeof obj[value] !== "string") {
        return false;
      }
    }
    return true;
  }
  function createSimplePaletteValueFilter(additionalPropertiesToCheck = []) {
    return ([, value]) => value && checkSimplePaletteColorValues(value, additionalPropertiesToCheck);
  }

  // node_modules/@mui/material/IconButton/IconButton.js
  var React47 = __toESM(require_react());

  // node_modules/@mui/material/CircularProgress/CircularProgress.js
  var React46 = __toESM(require_react());

  // node_modules/@mui/material/CircularProgress/circularProgressClasses.js
  function getCircularProgressUtilityClass(slot) {
    return generateUtilityClass("MuiCircularProgress", slot);
  }
  var circularProgressClasses = generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);

  // node_modules/@mui/material/CircularProgress/CircularProgress.js
  var import_jsx_runtime24 = __toESM(require_jsx_runtime());
  var SIZE = 44;
  var circularRotateKeyframe = keyframes`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`;
  var circularDashKeyframe = keyframes`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`;
  var rotateAnimation = typeof circularRotateKeyframe !== "string" ? css`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null;
  var dashAnimation = typeof circularDashKeyframe !== "string" ? css`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null;
  var useUtilityClasses4 = (ownerState) => {
    const {
      classes,
      variant,
      color: color3,
      disableShrink
    } = ownerState;
    const slots = {
      root: ["root", variant, `color${capitalize_default(color3)}`],
      svg: ["svg"],
      circle: ["circle", `circle${capitalize_default(variant)}`, disableShrink && "circleDisableShrink"]
    };
    return composeClasses(slots, getCircularProgressUtilityClass, classes);
  };
  var CircularProgressRoot = styled_default2("span", {
    name: "MuiCircularProgress",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], styles2[`color${capitalize_default(ownerState.color)}`]];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    display: "inline-block",
    variants: [{
      props: {
        variant: "determinate"
      },
      style: {
        transition: theme.transitions.create("transform")
      }
    }, {
      props: {
        variant: "indeterminate"
      },
      style: rotateAnimation || {
        animation: `${circularRotateKeyframe} 1.4s linear infinite`
      }
    }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color3]) => ({
      props: {
        color: color3
      },
      style: {
        color: (theme.vars || theme).palette[color3].main
      }
    }))]
  })));
  var CircularProgressSVG = styled_default2("svg", {
    name: "MuiCircularProgress",
    slot: "Svg",
    overridesResolver: (props, styles2) => styles2.svg
  })({
    display: "block"
    // Keeps the progress centered
  });
  var CircularProgressCircle = styled_default2("circle", {
    name: "MuiCircularProgress",
    slot: "Circle",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.circle, styles2[`circle${capitalize_default(ownerState.variant)}`], ownerState.disableShrink && styles2.circleDisableShrink];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    stroke: "currentColor",
    variants: [{
      props: {
        variant: "determinate"
      },
      style: {
        transition: theme.transitions.create("stroke-dashoffset")
      }
    }, {
      props: {
        variant: "indeterminate"
      },
      style: {
        // Some default value that looks fine waiting for the animation to kicks in.
        strokeDasharray: "80px, 200px",
        strokeDashoffset: 0
        // Add the unit to fix a Edge 16 and below bug.
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.variant === "indeterminate" && !ownerState.disableShrink,
      style: dashAnimation || {
        // At runtime for Pigment CSS, `bufferAnimation` will be null and the generated keyframe will be used.
        animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
      }
    }]
  })));
  var CircularProgress = /* @__PURE__ */ React46.forwardRef(function CircularProgress2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiCircularProgress"
    });
    const _a = props, {
      className,
      color: color3 = "primary",
      disableShrink = false,
      size = 40,
      style: style4,
      thickness = 3.6,
      value = 0,
      variant = "indeterminate"
    } = _a, other = __objRest(_a, [
      "className",
      "color",
      "disableShrink",
      "size",
      "style",
      "thickness",
      "value",
      "variant"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      color: color3,
      disableShrink,
      size,
      thickness,
      value,
      variant
    });
    const classes = useUtilityClasses4(ownerState);
    const circleStyle = {};
    const rootStyle = {};
    const rootProps = {};
    if (variant === "determinate") {
      const circumference = 2 * Math.PI * ((SIZE - thickness) / 2);
      circleStyle.strokeDasharray = circumference.toFixed(3);
      rootProps["aria-valuenow"] = Math.round(value);
      circleStyle.strokeDashoffset = `${((100 - value) / 100 * circumference).toFixed(3)}px`;
      rootStyle.transform = "rotate(-90deg)";
    }
    return /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(CircularProgressRoot, __spreadProps(__spreadValues(__spreadValues({
      className: clsx_default(classes.root, className),
      style: __spreadValues(__spreadValues({
        width: size,
        height: size
      }, rootStyle), style4),
      ownerState,
      ref,
      role: "progressbar"
    }, rootProps), other), {
      children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(CircularProgressSVG, {
        className: classes.svg,
        ownerState,
        viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
        children: /* @__PURE__ */ (0, import_jsx_runtime24.jsx)(CircularProgressCircle, {
          className: classes.circle,
          style: circleStyle,
          ownerState,
          cx: SIZE,
          cy: SIZE,
          r: (SIZE - thickness) / 2,
          fill: "none",
          strokeWidth: thickness
        })
      })
    }));
  });
  false ? CircularProgress.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
     * @default 'primary'
     */
    color: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["inherit", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types.default.string]),
    /**
     * If `true`, the shrink animation is disabled.
     * This only works if variant is `indeterminate`.
     * @default false
     */
    disableShrink: chainPropTypes(import_prop_types.default.bool, (props) => {
      if (props.disableShrink && props.variant && props.variant !== "indeterminate") {
        return new Error("MUI: You have provided the `disableShrink` prop with a variant other than `indeterminate`. This will have no effect.");
      }
      return null;
    }),
    /**
     * The size of the component.
     * If using a number, the pixel unit is assumed.
     * If using a string, you need to provide the CSS unit, for example '3rem'.
     * @default 40
     */
    size: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]),
    /**
     * @ignore
     */
    style: import_prop_types.default.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * The thickness of the circle.
     * @default 3.6
     */
    thickness: import_prop_types.default.number,
    /**
     * The value of the progress indicator for the determinate variant.
     * Value between 0 and 100.
     * @default 0
     */
    value: import_prop_types.default.number,
    /**
     * The variant to use.
     * Use indeterminate when there is no progress value.
     * @default 'indeterminate'
     */
    variant: import_prop_types.default.oneOf(["determinate", "indeterminate"])
  } : void 0;
  var CircularProgress_default = CircularProgress;

  // node_modules/@mui/material/IconButton/iconButtonClasses.js
  function getIconButtonUtilityClass(slot) {
    return generateUtilityClass("MuiIconButton", slot);
  }
  var iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"]);
  var iconButtonClasses_default = iconButtonClasses;

  // node_modules/@mui/material/IconButton/IconButton.js
  var import_jsx_runtime25 = __toESM(require_jsx_runtime());
  var useUtilityClasses5 = (ownerState) => {
    const {
      classes,
      disabled,
      color: color3,
      edge,
      size,
      loading
    } = ownerState;
    const slots = {
      root: ["root", loading && "loading", disabled && "disabled", color3 !== "default" && `color${capitalize_default(color3)}`, edge && `edge${capitalize_default(edge)}`, `size${capitalize_default(size)}`],
      loadingIndicator: ["loadingIndicator"],
      loadingWrapper: ["loadingWrapper"]
    };
    return composeClasses(slots, getIconButtonUtilityClass, classes);
  };
  var IconButtonRoot = styled_default2(ButtonBase_default, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.loading && styles2.loading, ownerState.color !== "default" && styles2[`color${capitalize_default(ownerState.color)}`], ownerState.edge && styles2[`edge${capitalize_default(ownerState.edge)}`], styles2[`size${capitalize_default(ownerState.size)}`]];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    textAlign: "center",
    flex: "0 0 auto",
    fontSize: theme.typography.pxToRem(24),
    padding: 8,
    borderRadius: "50%",
    color: (theme.vars || theme).palette.action.active,
    transition: theme.transitions.create("background-color", {
      duration: theme.transitions.duration.shortest
    }),
    variants: [{
      props: (props) => !props.disableRipple,
      style: {
        "--IconButton-hoverBg": theme.vars ? `rgba(${theme.vars.palette.action.activeChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.action.active, theme.palette.action.hoverOpacity),
        "&:hover": {
          backgroundColor: "var(--IconButton-hoverBg)",
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: "transparent"
          }
        }
      }
    }, {
      props: {
        edge: "start"
      },
      style: {
        marginLeft: -12
      }
    }, {
      props: {
        edge: "start",
        size: "small"
      },
      style: {
        marginLeft: -3
      }
    }, {
      props: {
        edge: "end"
      },
      style: {
        marginRight: -12
      }
    }, {
      props: {
        edge: "end",
        size: "small"
      },
      style: {
        marginRight: -3
      }
    }]
  })), memoTheme_default(({
    theme
  }) => ({
    variants: [{
      props: {
        color: "inherit"
      },
      style: {
        color: "inherit"
      }
    }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color3]) => ({
      props: {
        color: color3
      },
      style: {
        color: (theme.vars || theme).palette[color3].main
      }
    })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color3]) => ({
      props: {
        color: color3
      },
      style: {
        "--IconButton-hoverBg": theme.vars ? `rgba(${(theme.vars || theme).palette[color3].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha((theme.vars || theme).palette[color3].main, theme.palette.action.hoverOpacity)
      }
    })), {
      props: {
        size: "small"
      },
      style: {
        padding: 5,
        fontSize: theme.typography.pxToRem(18)
      }
    }, {
      props: {
        size: "large"
      },
      style: {
        padding: 12,
        fontSize: theme.typography.pxToRem(28)
      }
    }],
    [`&.${iconButtonClasses_default.disabled}`]: {
      backgroundColor: "transparent",
      color: (theme.vars || theme).palette.action.disabled
    },
    [`&.${iconButtonClasses_default.loading}`]: {
      color: "transparent"
    }
  })));
  var IconButtonLoadingIndicator = styled_default2("span", {
    name: "MuiIconButton",
    slot: "LoadingIndicator",
    overridesResolver: (props, styles2) => styles2.loadingIndicator
  })(({
    theme
  }) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    color: (theme.vars || theme).palette.action.disabled,
    variants: [{
      props: {
        loading: true
      },
      style: {
        display: "flex"
      }
    }]
  }));
  var IconButton = /* @__PURE__ */ React47.forwardRef(function IconButton2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiIconButton"
    });
    const _a = props, {
      edge = false,
      children,
      className,
      color: color3 = "default",
      disabled = false,
      disableFocusRipple = false,
      size = "medium",
      id: idProp,
      loading = null,
      loadingIndicator: loadingIndicatorProp
    } = _a, other = __objRest(_a, [
      "edge",
      "children",
      "className",
      "color",
      "disabled",
      "disableFocusRipple",
      "size",
      "id",
      "loading",
      "loadingIndicator"
    ]);
    const loadingId = useId_default(idProp);
    const loadingIndicator = loadingIndicatorProp != null ? loadingIndicatorProp : /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(CircularProgress_default, {
      "aria-labelledby": loadingId,
      color: "inherit",
      size: 16
    });
    const ownerState = __spreadProps(__spreadValues({}, props), {
      edge,
      color: color3,
      disabled,
      disableFocusRipple,
      loading,
      loadingIndicator,
      size
    });
    const classes = useUtilityClasses5(ownerState);
    return /* @__PURE__ */ (0, import_jsx_runtime25.jsxs)(IconButtonRoot, __spreadProps(__spreadValues({
      id: loading ? loadingId : idProp,
      className: clsx_default(classes.root, className),
      centerRipple: true,
      focusRipple: !disableFocusRipple,
      disabled: disabled || loading,
      ref
    }, other), {
      ownerState,
      children: [typeof loading === "boolean" && // use plain HTML span to minimize the runtime overhead
      /* @__PURE__ */ (0, import_jsx_runtime25.jsx)("span", {
        className: classes.loadingWrapper,
        style: {
          display: "contents"
        },
        children: /* @__PURE__ */ (0, import_jsx_runtime25.jsx)(IconButtonLoadingIndicator, {
          className: classes.loadingIndicator,
          ownerState,
          children: loading && loadingIndicator
        })
      }), children]
    }));
  });
  false ? IconButton.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The icon to display.
     */
    children: chainPropTypes(import_prop_types.default.node, (props) => {
      const found = React47.Children.toArray(props.children).some((child) => /* @__PURE__ */ React47.isValidElement(child) && child.props.onClick);
      if (found) {
        return new Error(["MUI: You are providing an onClick event listener to a child of a button element.", "Prefer applying it to the IconButton directly.", "This guarantees that the whole <button> will be responsive to click events."].join("\n"));
      }
      return null;
    }),
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
     * @default 'default'
     */
    color: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["inherit", "default", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types.default.string]),
    /**
     * If `true`, the component is disabled.
     * @default false
     */
    disabled: import_prop_types.default.bool,
    /**
     * If `true`, the  keyboard focus ripple is disabled.
     * @default false
     */
    disableFocusRipple: import_prop_types.default.bool,
    /**
     * If `true`, the ripple effect is disabled.
     *
     * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
     * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
     * @default false
     */
    disableRipple: import_prop_types.default.bool,
    /**
     * If given, uses a negative margin to counteract the padding on one
     * side (this is often helpful for aligning the left or right
     * side of the icon with content above or below, without ruining the border
     * size and shape).
     * @default false
     */
    edge: import_prop_types.default.oneOf(["end", "start", false]),
    /**
     * @ignore
     */
    id: import_prop_types.default.string,
    /**
     * If `true`, the loading indicator is visible and the button is disabled.
     * If `true | false`, the loading wrapper is always rendered before the children to prevent [Google Translation Crash](https://github.com/mui/material-ui/issues/27853).
     * @default null
     */
    loading: import_prop_types.default.bool,
    /**
     * Element placed before the children if the button is in loading state.
     * The node should contain an element with `role="progressbar"` with an accessible name.
     * By default, it renders a `CircularProgress` that is labeled by the button itself.
     * @default <CircularProgress color="inherit" size={16} />
     */
    loadingIndicator: import_prop_types.default.node,
    /**
     * The size of the component.
     * `small` is equivalent to the dense button styling.
     * @default 'medium'
     */
    size: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["small", "medium", "large"]), import_prop_types.default.string]),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var IconButton_default = IconButton;

  // node_modules/@mui/material/Typography/Typography.js
  var React48 = __toESM(require_react());

  // node_modules/@mui/material/Typography/typographyClasses.js
  function getTypographyUtilityClass(slot) {
    return generateUtilityClass("MuiTypography", slot);
  }
  var typographyClasses = generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);

  // node_modules/@mui/material/Typography/Typography.js
  var import_jsx_runtime26 = __toESM(require_jsx_runtime());
  var v6Colors = {
    primary: true,
    secondary: true,
    error: true,
    info: true,
    success: true,
    warning: true,
    textPrimary: true,
    textSecondary: true,
    textDisabled: true
  };
  var extendSxProp2 = internal_createExtendSxProp();
  var useUtilityClasses6 = (ownerState) => {
    const {
      align,
      gutterBottom,
      noWrap,
      paragraph,
      variant,
      classes
    } = ownerState;
    const slots = {
      root: ["root", variant, ownerState.align !== "inherit" && `align${capitalize_default(align)}`, gutterBottom && "gutterBottom", noWrap && "noWrap", paragraph && "paragraph"]
    };
    return composeClasses(slots, getTypographyUtilityClass, classes);
  };
  var TypographyRoot = styled_default2("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.variant && styles2[ownerState.variant], ownerState.align !== "inherit" && styles2[`align${capitalize_default(ownerState.align)}`], ownerState.noWrap && styles2.noWrap, ownerState.gutterBottom && styles2.gutterBottom, ownerState.paragraph && styles2.paragraph];
    }
  })(memoTheme_default(({
    theme
  }) => {
    var _a;
    return {
      margin: 0,
      variants: [{
        props: {
          variant: "inherit"
        },
        style: {
          // Some elements, like <button> on Chrome have default font that doesn't inherit, reset this.
          font: "inherit",
          lineHeight: "inherit",
          letterSpacing: "inherit"
        }
      }, ...Object.entries(theme.typography).filter(([variant, value]) => variant !== "inherit" && value && typeof value === "object").map(([variant, value]) => ({
        props: {
          variant
        },
        style: value
      })), ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color3]) => ({
        props: {
          color: color3
        },
        style: {
          color: (theme.vars || theme).palette[color3].main
        }
      })), ...Object.entries(((_a = theme.palette) == null ? void 0 : _a.text) || {}).filter(([, value]) => typeof value === "string").map(([color3]) => ({
        props: {
          color: `text${capitalize_default(color3)}`
        },
        style: {
          color: (theme.vars || theme).palette.text[color3]
        }
      })), {
        props: ({
          ownerState
        }) => ownerState.align !== "inherit",
        style: {
          textAlign: "var(--Typography-textAlign)"
        }
      }, {
        props: ({
          ownerState
        }) => ownerState.noWrap,
        style: {
          overflow: "hidden",
          textOverflow: "ellipsis",
          whiteSpace: "nowrap"
        }
      }, {
        props: ({
          ownerState
        }) => ownerState.gutterBottom,
        style: {
          marginBottom: "0.35em"
        }
      }, {
        props: ({
          ownerState
        }) => ownerState.paragraph,
        style: {
          marginBottom: 16
        }
      }]
    };
  }));
  var defaultVariantMapping = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
  };
  var Typography = /* @__PURE__ */ React48.forwardRef(function Typography2(inProps, ref) {
    const _a = useDefaultProps2({
      props: inProps,
      name: "MuiTypography"
    }), {
      color: color3
    } = _a, themeProps = __objRest(_a, [
      "color"
    ]);
    const isSxColor = !v6Colors[color3];
    const props = extendSxProp2(__spreadValues(__spreadValues({}, themeProps), isSxColor && {
      color: color3
    }));
    const _b = props, {
      align = "inherit",
      className,
      component,
      gutterBottom = false,
      noWrap = false,
      paragraph = false,
      variant = "body1",
      variantMapping = defaultVariantMapping
    } = _b, other = __objRest(_b, [
      "align",
      "className",
      "component",
      "gutterBottom",
      "noWrap",
      "paragraph",
      "variant",
      "variantMapping"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      align,
      color: color3,
      className,
      component,
      gutterBottom,
      noWrap,
      paragraph,
      variant,
      variantMapping
    });
    const Component = component || (paragraph ? "p" : variantMapping[variant] || defaultVariantMapping[variant]) || "span";
    const classes = useUtilityClasses6(ownerState);
    return /* @__PURE__ */ (0, import_jsx_runtime26.jsx)(TypographyRoot, __spreadProps(__spreadValues({
      as: Component,
      ref,
      className: clsx_default(classes.root, className)
    }, other), {
      ownerState,
      style: __spreadValues(__spreadValues({}, align !== "inherit" && {
        "--Typography-textAlign": align
      }), other.style)
    }));
  });
  false ? Typography.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * Set the text-align on the component.
     * @default 'inherit'
     */
    align: import_prop_types.default.oneOf(["center", "inherit", "justify", "left", "right"]),
    /**
     * The content of the component.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
     */
    color: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["primary", "secondary", "success", "error", "info", "warning", "textPrimary", "textSecondary", "textDisabled"]), import_prop_types.default.string]),
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * If `true`, the text will have a bottom margin.
     * @default false
     */
    gutterBottom: import_prop_types.default.bool,
    /**
     * If `true`, the text will not wrap, but instead will truncate with a text overflow ellipsis.
     *
     * Note that text overflow can only happen with block or inline-block level elements
     * (the element needs to have a width in order to overflow).
     * @default false
     */
    noWrap: import_prop_types.default.bool,
    /**
     * If `true`, the element will be a paragraph element.
     * @default false
     * @deprecated Use the `component` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
     */
    paragraph: import_prop_types.default.bool,
    /**
     * @ignore
     */
    style: import_prop_types.default.object,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * Applies the theme typography styles.
     * @default 'body1'
     */
    variant: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["body1", "body2", "button", "caption", "h1", "h2", "h3", "h4", "h5", "h6", "inherit", "overline", "subtitle1", "subtitle2"]), import_prop_types.default.string]),
    /**
     * The component maps the variant prop to a range of different HTML element types.
     * For instance, subtitle1 to `<h6>`.
     * If you wish to change that mapping, you can provide your own.
     * Alternatively, you can use the `component` prop.
     * @default {
     *   h1: 'h1',
     *   h2: 'h2',
     *   h3: 'h3',
     *   h4: 'h4',
     *   h5: 'h5',
     *   h6: 'h6',
     *   subtitle1: 'h6',
     *   subtitle2: 'h6',
     *   body1: 'p',
     *   body2: 'p',
     *   inherit: 'p',
     * }
     */
    variantMapping: import_prop_types.default.object
  } : void 0;
  var Typography_default = Typography;

  // node_modules/@mui/material/Popper/Popper.js
  var React51 = __toESM(require_react());

  // node_modules/@mui/material/Popper/BasePopper.js
  var React50 = __toESM(require_react());

  // node_modules/@popperjs/core/lib/enums.js
  var top = "top";
  var bottom = "bottom";
  var right = "right";
  var left = "left";
  var auto = "auto";
  var basePlacements = [top, bottom, right, left];
  var start = "start";
  var end = "end";
  var clippingParents = "clippingParents";
  var viewport = "viewport";
  var popper = "popper";
  var reference = "reference";
  var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
    return acc.concat([placement + "-" + start, placement + "-" + end]);
  }, []);
  var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
    return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
  }, []);
  var beforeRead = "beforeRead";
  var read = "read";
  var afterRead = "afterRead";
  var beforeMain = "beforeMain";
  var main = "main";
  var afterMain = "afterMain";
  var beforeWrite = "beforeWrite";
  var write = "write";
  var afterWrite = "afterWrite";
  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

  // node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
  function getNodeName(element) {
    return element ? (element.nodeName || "").toLowerCase() : null;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindow.js
  function getWindow(node2) {
    if (node2 == null) {
      return window;
    }
    if (node2.toString() !== "[object Window]") {
      var ownerDocument3 = node2.ownerDocument;
      return ownerDocument3 ? ownerDocument3.defaultView || window : window;
    }
    return node2;
  }

  // node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
  function isElement(node2) {
    var OwnElement = getWindow(node2).Element;
    return node2 instanceof OwnElement || node2 instanceof Element;
  }
  function isHTMLElement(node2) {
    var OwnElement = getWindow(node2).HTMLElement;
    return node2 instanceof OwnElement || node2 instanceof HTMLElement;
  }
  function isShadowRoot(node2) {
    if (typeof ShadowRoot === "undefined") {
      return false;
    }
    var OwnElement = getWindow(node2).ShadowRoot;
    return node2 instanceof OwnElement || node2 instanceof ShadowRoot;
  }

  // node_modules/@popperjs/core/lib/modifiers/applyStyles.js
  function applyStyles2(_ref) {
    var state = _ref.state;
    Object.keys(state.elements).forEach(function(name) {
      var style4 = state.styles[name] || {};
      var attributes = state.attributes[name] || {};
      var element = state.elements[name];
      if (!isHTMLElement(element) || !getNodeName(element)) {
        return;
      }
      Object.assign(element.style, style4);
      Object.keys(attributes).forEach(function(name2) {
        var value = attributes[name2];
        if (value === false) {
          element.removeAttribute(name2);
        } else {
          element.setAttribute(name2, value === true ? "" : value);
        }
      });
    });
  }
  function effect(_ref2) {
    var state = _ref2.state;
    var initialStyles = {
      popper: {
        position: state.options.strategy,
        left: "0",
        top: "0",
        margin: "0"
      },
      arrow: {
        position: "absolute"
      },
      reference: {}
    };
    Object.assign(state.elements.popper.style, initialStyles.popper);
    state.styles = initialStyles;
    if (state.elements.arrow) {
      Object.assign(state.elements.arrow.style, initialStyles.arrow);
    }
    return function() {
      Object.keys(state.elements).forEach(function(name) {
        var element = state.elements[name];
        var attributes = state.attributes[name] || {};
        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
        var style4 = styleProperties.reduce(function(style5, property) {
          style5[property] = "";
          return style5;
        }, {});
        if (!isHTMLElement(element) || !getNodeName(element)) {
          return;
        }
        Object.assign(element.style, style4);
        Object.keys(attributes).forEach(function(attribute) {
          element.removeAttribute(attribute);
        });
      });
    };
  }
  var applyStyles_default = {
    name: "applyStyles",
    enabled: true,
    phase: "write",
    fn: applyStyles2,
    effect,
    requires: ["computeStyles"]
  };

  // node_modules/@popperjs/core/lib/utils/getBasePlacement.js
  function getBasePlacement(placement) {
    return placement.split("-")[0];
  }

  // node_modules/@popperjs/core/lib/utils/math.js
  var max = Math.max;
  var min = Math.min;
  var round2 = Math.round;

  // node_modules/@popperjs/core/lib/utils/userAgent.js
  function getUAString() {
    var uaData = navigator.userAgentData;
    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {
      return uaData.brands.map(function(item) {
        return item.brand + "/" + item.version;
      }).join(" ");
    }
    return navigator.userAgent;
  }

  // node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
  function isLayoutViewport() {
    return !/^((?!chrome|android).)*safari/i.test(getUAString());
  }

  // node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
  function getBoundingClientRect(element, includeScale, isFixedStrategy) {
    if (includeScale === void 0) {
      includeScale = false;
    }
    if (isFixedStrategy === void 0) {
      isFixedStrategy = false;
    }
    var clientRect = element.getBoundingClientRect();
    var scaleX = 1;
    var scaleY = 1;
    if (includeScale && isHTMLElement(element)) {
      scaleX = element.offsetWidth > 0 ? round2(clientRect.width) / element.offsetWidth || 1 : 1;
      scaleY = element.offsetHeight > 0 ? round2(clientRect.height) / element.offsetHeight || 1 : 1;
    }
    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
    var width2 = clientRect.width / scaleX;
    var height2 = clientRect.height / scaleY;
    return {
      width: width2,
      height: height2,
      top: y,
      right: x + width2,
      bottom: y + height2,
      left: x,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
  function getLayoutRect(element) {
    var clientRect = getBoundingClientRect(element);
    var width2 = element.offsetWidth;
    var height2 = element.offsetHeight;
    if (Math.abs(clientRect.width - width2) <= 1) {
      width2 = clientRect.width;
    }
    if (Math.abs(clientRect.height - height2) <= 1) {
      height2 = clientRect.height;
    }
    return {
      x: element.offsetLeft,
      y: element.offsetTop,
      width: width2,
      height: height2
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/contains.js
  function contains(parent, child) {
    var rootNode = child.getRootNode && child.getRootNode();
    if (parent.contains(child)) {
      return true;
    } else if (rootNode && isShadowRoot(rootNode)) {
      var next2 = child;
      do {
        if (next2 && parent.isSameNode(next2)) {
          return true;
        }
        next2 = next2.parentNode || next2.host;
      } while (next2);
    }
    return false;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
  function getComputedStyle(element) {
    return getWindow(element).getComputedStyle(element);
  }

  // node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
  function isTableElement(element) {
    return ["table", "td", "th"].indexOf(getNodeName(element)) >= 0;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
  function getDocumentElement(element) {
    return ((isElement(element) ? element.ownerDocument : (
      // $FlowFixMe[prop-missing]
      element.document
    )) || window.document).documentElement;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
  function getParentNode(element) {
    if (getNodeName(element) === "html") {
      return element;
    }
    return (
      // this is a quicker (but less type safe) way to save quite some bytes from the bundle
      // $FlowFixMe[incompatible-return]
      // $FlowFixMe[prop-missing]
      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node
      element.parentNode || // DOM Element detected
      (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected
      // $FlowFixMe[incompatible-call]: HTMLElement is a Node
      getDocumentElement(element)
    );
  }

  // node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
  function getTrueOffsetParent(element) {
    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837
    getComputedStyle(element).position === "fixed") {
      return null;
    }
    return element.offsetParent;
  }
  function getContainingBlock(element) {
    var isFirefox = /firefox/i.test(getUAString());
    var isIE = /Trident/i.test(getUAString());
    if (isIE && isHTMLElement(element)) {
      var elementCss = getComputedStyle(element);
      if (elementCss.position === "fixed") {
        return null;
      }
    }
    var currentNode = getParentNode(element);
    if (isShadowRoot(currentNode)) {
      currentNode = currentNode.host;
    }
    while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
      var css2 = getComputedStyle(currentNode);
      if (css2.transform !== "none" || css2.perspective !== "none" || css2.contain === "paint" || ["transform", "perspective"].indexOf(css2.willChange) !== -1 || isFirefox && css2.willChange === "filter" || isFirefox && css2.filter && css2.filter !== "none") {
        return currentNode;
      } else {
        currentNode = currentNode.parentNode;
      }
    }
    return null;
  }
  function getOffsetParent(element) {
    var window2 = getWindow(element);
    var offsetParent = getTrueOffsetParent(element);
    while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
      offsetParent = getTrueOffsetParent(offsetParent);
    }
    if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static")) {
      return window2;
    }
    return offsetParent || getContainingBlock(element) || window2;
  }

  // node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
  function getMainAxisFromPlacement(placement) {
    return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
  }

  // node_modules/@popperjs/core/lib/utils/within.js
  function within(min2, value, max2) {
    return max(min2, min(value, max2));
  }
  function withinMaxClamp(min2, value, max2) {
    var v = within(min2, value, max2);
    return v > max2 ? max2 : v;
  }

  // node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
  function getFreshSideObject() {
    return {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
  function mergePaddingObject(paddingObject) {
    return Object.assign({}, getFreshSideObject(), paddingObject);
  }

  // node_modules/@popperjs/core/lib/utils/expandToHashMap.js
  function expandToHashMap(value, keys) {
    return keys.reduce(function(hashMap, key) {
      hashMap[key] = value;
      return hashMap;
    }, {});
  }

  // node_modules/@popperjs/core/lib/modifiers/arrow.js
  var toPaddingObject = function toPaddingObject2(padding2, state) {
    padding2 = typeof padding2 === "function" ? padding2(Object.assign({}, state.rects, {
      placement: state.placement
    })) : padding2;
    return mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
  };
  function arrow(_ref) {
    var _state$modifiersData$;
    var state = _ref.state, name = _ref.name, options = _ref.options;
    var arrowElement = state.elements.arrow;
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var basePlacement = getBasePlacement(state.placement);
    var axis = getMainAxisFromPlacement(basePlacement);
    var isVertical = [left, right].indexOf(basePlacement) >= 0;
    var len = isVertical ? "height" : "width";
    if (!arrowElement || !popperOffsets2) {
      return;
    }
    var paddingObject = toPaddingObject(options.padding, state);
    var arrowRect = getLayoutRect(arrowElement);
    var minProp = axis === "y" ? top : left;
    var maxProp = axis === "y" ? bottom : right;
    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
    var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
    var arrowOffsetParent = getOffsetParent(arrowElement);
    var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
    var centerToReference = endDiff / 2 - startDiff / 2;
    var min2 = paddingObject[minProp];
    var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
    var offset2 = within(min2, center, max2);
    var axisProp = axis;
    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
  }
  function effect2(_ref2) {
    var state = _ref2.state, options = _ref2.options;
    var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
    if (arrowElement == null) {
      return;
    }
    if (typeof arrowElement === "string") {
      arrowElement = state.elements.popper.querySelector(arrowElement);
      if (!arrowElement) {
        return;
      }
    }
    if (!contains(state.elements.popper, arrowElement)) {
      return;
    }
    state.elements.arrow = arrowElement;
  }
  var arrow_default = {
    name: "arrow",
    enabled: true,
    phase: "main",
    fn: arrow,
    effect: effect2,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
  };

  // node_modules/@popperjs/core/lib/utils/getVariation.js
  function getVariation(placement) {
    return placement.split("-")[1];
  }

  // node_modules/@popperjs/core/lib/modifiers/computeStyles.js
  var unsetSides = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
  };
  function roundOffsetsByDPR(_ref, win) {
    var x = _ref.x, y = _ref.y;
    var dpr = win.devicePixelRatio || 1;
    return {
      x: round2(x * dpr) / dpr || 0,
      y: round2(y * dpr) / dpr || 0
    };
  }
  function mapToStyles(_ref2) {
    var _Object$assign2;
    var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position2 = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
    var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
      x,
      y
    }) : {
      x,
      y
    };
    x = _ref3.x;
    y = _ref3.y;
    var hasX = offsets.hasOwnProperty("x");
    var hasY = offsets.hasOwnProperty("y");
    var sideX = left;
    var sideY = top;
    var win = window;
    if (adaptive) {
      var offsetParent = getOffsetParent(popper2);
      var heightProp = "clientHeight";
      var widthProp = "clientWidth";
      if (offsetParent === getWindow(popper2)) {
        offsetParent = getDocumentElement(popper2);
        if (getComputedStyle(offsetParent).position !== "static" && position2 === "absolute") {
          heightProp = "scrollHeight";
          widthProp = "scrollWidth";
        }
      }
      offsetParent = offsetParent;
      if (placement === top || (placement === left || placement === right) && variation === end) {
        sideY = bottom;
        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : (
          // $FlowFixMe[prop-missing]
          offsetParent[heightProp]
        );
        y -= offsetY - popperRect.height;
        y *= gpuAcceleration ? 1 : -1;
      }
      if (placement === left || (placement === top || placement === bottom) && variation === end) {
        sideX = right;
        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : (
          // $FlowFixMe[prop-missing]
          offsetParent[widthProp]
        );
        x -= offsetX - popperRect.width;
        x *= gpuAcceleration ? 1 : -1;
      }
    }
    var commonStyles = Object.assign({
      position: position2
    }, adaptive && unsetSides);
    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
      x,
      y
    }, getWindow(popper2)) : {
      x,
      y
    };
    x = _ref4.x;
    y = _ref4.y;
    if (gpuAcceleration) {
      var _Object$assign;
      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
    }
    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
  }
  function computeStyles(_ref5) {
    var state = _ref5.state, options = _ref5.options;
    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
    var commonStyles = {
      placement: getBasePlacement(state.placement),
      variation: getVariation(state.placement),
      popper: state.elements.popper,
      popperRect: state.rects.popper,
      gpuAcceleration,
      isFixed: state.options.strategy === "fixed"
    };
    if (state.modifiersData.popperOffsets != null) {
      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.popperOffsets,
        position: state.options.strategy,
        adaptive,
        roundOffsets
      })));
    }
    if (state.modifiersData.arrow != null) {
      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
        offsets: state.modifiersData.arrow,
        position: "absolute",
        adaptive: false,
        roundOffsets
      })));
    }
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-placement": state.placement
    });
  }
  var computeStyles_default = {
    name: "computeStyles",
    enabled: true,
    phase: "beforeWrite",
    fn: computeStyles,
    data: {}
  };

  // node_modules/@popperjs/core/lib/modifiers/eventListeners.js
  var passive = {
    passive: true
  };
  function effect3(_ref) {
    var state = _ref.state, instance2 = _ref.instance, options = _ref.options;
    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
    var window2 = getWindow(state.elements.popper);
    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.addEventListener("scroll", instance2.update, passive);
      });
    }
    if (resize) {
      window2.addEventListener("resize", instance2.update, passive);
    }
    return function() {
      if (scroll) {
        scrollParents.forEach(function(scrollParent) {
          scrollParent.removeEventListener("scroll", instance2.update, passive);
        });
      }
      if (resize) {
        window2.removeEventListener("resize", instance2.update, passive);
      }
    };
  }
  var eventListeners_default = {
    name: "eventListeners",
    enabled: true,
    phase: "write",
    fn: function fn() {
    },
    effect: effect3,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
  var hash2 = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
  };
  function getOppositePlacement(placement) {
    return placement.replace(/left|right|bottom|top/g, function(matched) {
      return hash2[matched];
    });
  }

  // node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
  var hash3 = {
    start: "end",
    end: "start"
  };
  function getOppositeVariationPlacement(placement) {
    return placement.replace(/start|end/g, function(matched) {
      return hash3[matched];
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
  function getWindowScroll(node2) {
    var win = getWindow(node2);
    var scrollLeft = win.pageXOffset;
    var scrollTop = win.pageYOffset;
    return {
      scrollLeft,
      scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
  function getWindowScrollBarX(element) {
    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
  }

  // node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
  function getViewportRect(element, strategy) {
    var win = getWindow(element);
    var html = getDocumentElement(element);
    var visualViewport = win.visualViewport;
    var width2 = html.clientWidth;
    var height2 = html.clientHeight;
    var x = 0;
    var y = 0;
    if (visualViewport) {
      width2 = visualViewport.width;
      height2 = visualViewport.height;
      var layoutViewport = isLayoutViewport();
      if (layoutViewport || !layoutViewport && strategy === "fixed") {
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
      }
    }
    return {
      width: width2,
      height: height2,
      x: x + getWindowScrollBarX(element),
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
  function getDocumentRect(element) {
    var _element$ownerDocumen;
    var html = getDocumentElement(element);
    var winScroll = getWindowScroll(element);
    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
    var width2 = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
    var height2 = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
    var y = -winScroll.scrollTop;
    if (getComputedStyle(body || html).direction === "rtl") {
      x += max(html.clientWidth, body ? body.clientWidth : 0) - width2;
    }
    return {
      width: width2,
      height: height2,
      x,
      y
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
  function isScrollParent(element) {
    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
  }

  // node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
  function getScrollParent(node2) {
    if (["html", "body", "#document"].indexOf(getNodeName(node2)) >= 0) {
      return node2.ownerDocument.body;
    }
    if (isHTMLElement(node2) && isScrollParent(node2)) {
      return node2;
    }
    return getScrollParent(getParentNode(node2));
  }

  // node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
  function listScrollParents(element, list) {
    var _element$ownerDocumen;
    if (list === void 0) {
      list = [];
    }
    var scrollParent = getScrollParent(element);
    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
    var win = getWindow(scrollParent);
    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
    var updatedList = list.concat(target);
    return isBody ? updatedList : (
      // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here
      updatedList.concat(listScrollParents(getParentNode(target)))
    );
  }

  // node_modules/@popperjs/core/lib/utils/rectToClientRect.js
  function rectToClientRect(rect) {
    return Object.assign({}, rect, {
      left: rect.x,
      top: rect.y,
      right: rect.x + rect.width,
      bottom: rect.y + rect.height
    });
  }

  // node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
  function getInnerBoundingClientRect(element, strategy) {
    var rect = getBoundingClientRect(element, false, strategy === "fixed");
    rect.top = rect.top + element.clientTop;
    rect.left = rect.left + element.clientLeft;
    rect.bottom = rect.top + element.clientHeight;
    rect.right = rect.left + element.clientWidth;
    rect.width = element.clientWidth;
    rect.height = element.clientHeight;
    rect.x = rect.left;
    rect.y = rect.top;
    return rect;
  }
  function getClientRectFromMixedType(element, clippingParent, strategy) {
    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
  }
  function getClippingParents(element) {
    var clippingParents2 = listScrollParents(getParentNode(element));
    var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle(element).position) >= 0;
    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
    if (!isElement(clipperElement)) {
      return [];
    }
    return clippingParents2.filter(function(clippingParent) {
      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
    });
  }
  function getClippingRect(element, boundary, rootBoundary, strategy) {
    var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
    var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
    var firstClippingParent = clippingParents2[0];
    var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
      var rect = getClientRectFromMixedType(element, clippingParent, strategy);
      accRect.top = max(rect.top, accRect.top);
      accRect.right = min(rect.right, accRect.right);
      accRect.bottom = min(rect.bottom, accRect.bottom);
      accRect.left = max(rect.left, accRect.left);
      return accRect;
    }, getClientRectFromMixedType(element, firstClippingParent, strategy));
    clippingRect.width = clippingRect.right - clippingRect.left;
    clippingRect.height = clippingRect.bottom - clippingRect.top;
    clippingRect.x = clippingRect.left;
    clippingRect.y = clippingRect.top;
    return clippingRect;
  }

  // node_modules/@popperjs/core/lib/utils/computeOffsets.js
  function computeOffsets(_ref) {
    var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;
    var basePlacement = placement ? getBasePlacement(placement) : null;
    var variation = placement ? getVariation(placement) : null;
    var commonX = reference2.x + reference2.width / 2 - element.width / 2;
    var commonY = reference2.y + reference2.height / 2 - element.height / 2;
    var offsets;
    switch (basePlacement) {
      case top:
        offsets = {
          x: commonX,
          y: reference2.y - element.height
        };
        break;
      case bottom:
        offsets = {
          x: commonX,
          y: reference2.y + reference2.height
        };
        break;
      case right:
        offsets = {
          x: reference2.x + reference2.width,
          y: commonY
        };
        break;
      case left:
        offsets = {
          x: reference2.x - element.width,
          y: commonY
        };
        break;
      default:
        offsets = {
          x: reference2.x,
          y: reference2.y
        };
    }
    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
    if (mainAxis != null) {
      var len = mainAxis === "y" ? "height" : "width";
      switch (variation) {
        case start:
          offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);
          break;
        case end:
          offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);
          break;
        default:
      }
    }
    return offsets;
  }

  // node_modules/@popperjs/core/lib/utils/detectOverflow.js
  function detectOverflow(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding2 = _options$padding === void 0 ? 0 : _options$padding;
    var paddingObject = mergePaddingObject(typeof padding2 !== "number" ? padding2 : expandToHashMap(padding2, basePlacements));
    var altContext = elementContext === popper ? reference : popper;
    var popperRect = state.rects.popper;
    var element = state.elements[altBoundary ? altContext : elementContext];
    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
    var referenceClientRect = getBoundingClientRect(state.elements.reference);
    var popperOffsets2 = computeOffsets({
      reference: referenceClientRect,
      element: popperRect,
      strategy: "absolute",
      placement
    });
    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
    var overflowOffsets = {
      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
      right: elementClientRect.right - clippingClientRect.right + paddingObject.right
    };
    var offsetData = state.modifiersData.offset;
    if (elementContext === popper && offsetData) {
      var offset2 = offsetData[placement];
      Object.keys(overflowOffsets).forEach(function(key) {
        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
        var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
        overflowOffsets[key] += offset2[axis] * multiply;
      });
    }
    return overflowOffsets;
  }

  // node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
  function computeAutoPlacement(state, options) {
    if (options === void 0) {
      options = {};
    }
    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding2 = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
    var variation = getVariation(placement);
    var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
      return getVariation(placement2) === variation;
    }) : basePlacements;
    var allowedPlacements = placements2.filter(function(placement2) {
      return allowedAutoPlacements.indexOf(placement2) >= 0;
    });
    if (allowedPlacements.length === 0) {
      allowedPlacements = placements2;
    }
    var overflows = allowedPlacements.reduce(function(acc, placement2) {
      acc[placement2] = detectOverflow(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding: padding2
      })[getBasePlacement(placement2)];
      return acc;
    }, {});
    return Object.keys(overflows).sort(function(a, b) {
      return overflows[a] - overflows[b];
    });
  }

  // node_modules/@popperjs/core/lib/modifiers/flip.js
  function getExpandedFallbackPlacements(placement) {
    if (getBasePlacement(placement) === auto) {
      return [];
    }
    var oppositePlacement = getOppositePlacement(placement);
    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
  }
  function flip(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    if (state.modifiersData[name]._skip) {
      return;
    }
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding2 = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
    var preferredPlacement = state.options.placement;
    var basePlacement = getBasePlacement(preferredPlacement);
    var isBasePlacement = basePlacement === preferredPlacement;
    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
    var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
      return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
        placement: placement2,
        boundary,
        rootBoundary,
        padding: padding2,
        flipVariations,
        allowedAutoPlacements
      }) : placement2);
    }, []);
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var checksMap = /* @__PURE__ */ new Map();
    var makeFallbackChecks = true;
    var firstFittingPlacement = placements2[0];
    for (var i = 0; i < placements2.length; i++) {
      var placement = placements2[i];
      var _basePlacement = getBasePlacement(placement);
      var isStartVariation = getVariation(placement) === start;
      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
      var len = isVertical ? "width" : "height";
      var overflow = detectOverflow(state, {
        placement,
        boundary,
        rootBoundary,
        altBoundary,
        padding: padding2
      });
      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
      if (referenceRect[len] > popperRect[len]) {
        mainVariationSide = getOppositePlacement(mainVariationSide);
      }
      var altVariationSide = getOppositePlacement(mainVariationSide);
      var checks = [];
      if (checkMainAxis) {
        checks.push(overflow[_basePlacement] <= 0);
      }
      if (checkAltAxis) {
        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
      }
      if (checks.every(function(check) {
        return check;
      })) {
        firstFittingPlacement = placement;
        makeFallbackChecks = false;
        break;
      }
      checksMap.set(placement, checks);
    }
    if (makeFallbackChecks) {
      var numberOfChecks = flipVariations ? 3 : 1;
      var _loop = function _loop2(_i2) {
        var fittingPlacement = placements2.find(function(placement2) {
          var checks2 = checksMap.get(placement2);
          if (checks2) {
            return checks2.slice(0, _i2).every(function(check) {
              return check;
            });
          }
        });
        if (fittingPlacement) {
          firstFittingPlacement = fittingPlacement;
          return "break";
        }
      };
      for (var _i = numberOfChecks; _i > 0; _i--) {
        var _ret = _loop(_i);
        if (_ret === "break") break;
      }
    }
    if (state.placement !== firstFittingPlacement) {
      state.modifiersData[name]._skip = true;
      state.placement = firstFittingPlacement;
      state.reset = true;
    }
  }
  var flip_default = {
    name: "flip",
    enabled: true,
    phase: "main",
    fn: flip,
    requiresIfExists: ["offset"],
    data: {
      _skip: false
    }
  };

  // node_modules/@popperjs/core/lib/modifiers/hide.js
  function getSideOffsets(overflow, rect, preventedOffsets) {
    if (preventedOffsets === void 0) {
      preventedOffsets = {
        x: 0,
        y: 0
      };
    }
    return {
      top: overflow.top - rect.height - preventedOffsets.y,
      right: overflow.right - rect.width + preventedOffsets.x,
      bottom: overflow.bottom - rect.height + preventedOffsets.y,
      left: overflow.left - rect.width - preventedOffsets.x
    };
  }
  function isAnySideFullyClipped(overflow) {
    return [top, right, bottom, left].some(function(side) {
      return overflow[side] >= 0;
    });
  }
  function hide(_ref) {
    var state = _ref.state, name = _ref.name;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var preventedOffsets = state.modifiersData.preventOverflow;
    var referenceOverflow = detectOverflow(state, {
      elementContext: "reference"
    });
    var popperAltOverflow = detectOverflow(state, {
      altBoundary: true
    });
    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
    state.modifiersData[name] = {
      referenceClippingOffsets,
      popperEscapeOffsets,
      isReferenceHidden,
      hasPopperEscaped
    };
    state.attributes.popper = Object.assign({}, state.attributes.popper, {
      "data-popper-reference-hidden": isReferenceHidden,
      "data-popper-escaped": hasPopperEscaped
    });
  }
  var hide_default = {
    name: "hide",
    enabled: true,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: hide
  };

  // node_modules/@popperjs/core/lib/modifiers/offset.js
  function distanceAndSkiddingToXY(placement, rects, offset2) {
    var basePlacement = getBasePlacement(placement);
    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
    var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
      placement
    })) : offset2, skidding = _ref[0], distance = _ref[1];
    skidding = skidding || 0;
    distance = (distance || 0) * invertDistance;
    return [left, right].indexOf(basePlacement) >= 0 ? {
      x: distance,
      y: skidding
    } : {
      x: skidding,
      y: distance
    };
  }
  function offset(_ref2) {
    var state = _ref2.state, options = _ref2.options, name = _ref2.name;
    var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
    var data = placements.reduce(function(acc, placement) {
      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
      return acc;
    }, {});
    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
    if (state.modifiersData.popperOffsets != null) {
      state.modifiersData.popperOffsets.x += x;
      state.modifiersData.popperOffsets.y += y;
    }
    state.modifiersData[name] = data;
  }
  var offset_default = {
    name: "offset",
    enabled: true,
    phase: "main",
    requires: ["popperOffsets"],
    fn: offset
  };

  // node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
  function popperOffsets(_ref) {
    var state = _ref.state, name = _ref.name;
    state.modifiersData[name] = computeOffsets({
      reference: state.rects.reference,
      element: state.rects.popper,
      strategy: "absolute",
      placement: state.placement
    });
  }
  var popperOffsets_default = {
    name: "popperOffsets",
    enabled: true,
    phase: "read",
    fn: popperOffsets,
    data: {}
  };

  // node_modules/@popperjs/core/lib/utils/getAltAxis.js
  function getAltAxis(axis) {
    return axis === "x" ? "y" : "x";
  }

  // node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
  function preventOverflow(_ref) {
    var state = _ref.state, options = _ref.options, name = _ref.name;
    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding2 = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
    var overflow = detectOverflow(state, {
      boundary,
      rootBoundary,
      padding: padding2,
      altBoundary
    });
    var basePlacement = getBasePlacement(state.placement);
    var variation = getVariation(state.placement);
    var isBasePlacement = !variation;
    var mainAxis = getMainAxisFromPlacement(basePlacement);
    var altAxis = getAltAxis(mainAxis);
    var popperOffsets2 = state.modifiersData.popperOffsets;
    var referenceRect = state.rects.reference;
    var popperRect = state.rects.popper;
    var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
      placement: state.placement
    })) : tetherOffset;
    var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
      mainAxis: tetherOffsetValue,
      altAxis: tetherOffsetValue
    } : Object.assign({
      mainAxis: 0,
      altAxis: 0
    }, tetherOffsetValue);
    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
    var data = {
      x: 0,
      y: 0
    };
    if (!popperOffsets2) {
      return;
    }
    if (checkMainAxis) {
      var _offsetModifierState$;
      var mainSide = mainAxis === "y" ? top : left;
      var altSide = mainAxis === "y" ? bottom : right;
      var len = mainAxis === "y" ? "height" : "width";
      var offset2 = popperOffsets2[mainAxis];
      var min2 = offset2 + overflow[mainSide];
      var max2 = offset2 - overflow[altSide];
      var additive = tether ? -popperRect[len] / 2 : 0;
      var minLen = variation === start ? referenceRect[len] : popperRect[len];
      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
      var arrowElement = state.elements.arrow;
      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
        width: 0,
        height: 0
      };
      var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
      var arrowPaddingMin = arrowPaddingObject[mainSide];
      var arrowPaddingMax = arrowPaddingObject[altSide];
      var arrowLen = within(0, referenceRect[len], arrowRect[len]);
      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
      var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
      var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
      var tetherMax = offset2 + maxOffset - offsetModifierValue;
      var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
      popperOffsets2[mainAxis] = preventedOffset;
      data[mainAxis] = preventedOffset - offset2;
    }
    if (checkAltAxis) {
      var _offsetModifierState$2;
      var _mainSide = mainAxis === "x" ? top : left;
      var _altSide = mainAxis === "x" ? bottom : right;
      var _offset = popperOffsets2[altAxis];
      var _len = altAxis === "y" ? "height" : "width";
      var _min = _offset + overflow[_mainSide];
      var _max = _offset - overflow[_altSide];
      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
      popperOffsets2[altAxis] = _preventedOffset;
      data[altAxis] = _preventedOffset - _offset;
    }
    state.modifiersData[name] = data;
  }
  var preventOverflow_default = {
    name: "preventOverflow",
    enabled: true,
    phase: "main",
    fn: preventOverflow,
    requiresIfExists: ["offset"]
  };

  // node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
  function getHTMLElementScroll(element) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }

  // node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
  function getNodeScroll(node2) {
    if (node2 === getWindow(node2) || !isHTMLElement(node2)) {
      return getWindowScroll(node2);
    } else {
      return getHTMLElementScroll(node2);
    }
  }

  // node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
  function isElementScaled(element) {
    var rect = element.getBoundingClientRect();
    var scaleX = round2(rect.width) / element.offsetWidth || 1;
    var scaleY = round2(rect.height) / element.offsetHeight || 1;
    return scaleX !== 1 || scaleY !== 1;
  }
  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
    if (isFixed === void 0) {
      isFixed = false;
    }
    var isOffsetParentAnElement = isHTMLElement(offsetParent);
    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
    var documentElement = getDocumentElement(offsetParent);
    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
    var scroll = {
      scrollLeft: 0,
      scrollTop: 0
    };
    var offsets = {
      x: 0,
      y: 0
    };
    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
      if (getNodeName(offsetParent) !== "body" || // https://github.com/popperjs/popper-core/issues/1078
      isScrollParent(documentElement)) {
        scroll = getNodeScroll(offsetParent);
      }
      if (isHTMLElement(offsetParent)) {
        offsets = getBoundingClientRect(offsetParent, true);
        offsets.x += offsetParent.clientLeft;
        offsets.y += offsetParent.clientTop;
      } else if (documentElement) {
        offsets.x = getWindowScrollBarX(documentElement);
      }
    }
    return {
      x: rect.left + scroll.scrollLeft - offsets.x,
      y: rect.top + scroll.scrollTop - offsets.y,
      width: rect.width,
      height: rect.height
    };
  }

  // node_modules/@popperjs/core/lib/utils/orderModifiers.js
  function order(modifiers) {
    var map2 = /* @__PURE__ */ new Map();
    var visited = /* @__PURE__ */ new Set();
    var result = [];
    modifiers.forEach(function(modifier) {
      map2.set(modifier.name, modifier);
    });
    function sort(modifier) {
      visited.add(modifier.name);
      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
      requires.forEach(function(dep) {
        if (!visited.has(dep)) {
          var depModifier = map2.get(dep);
          if (depModifier) {
            sort(depModifier);
          }
        }
      });
      result.push(modifier);
    }
    modifiers.forEach(function(modifier) {
      if (!visited.has(modifier.name)) {
        sort(modifier);
      }
    });
    return result;
  }
  function orderModifiers(modifiers) {
    var orderedModifiers = order(modifiers);
    return modifierPhases.reduce(function(acc, phase) {
      return acc.concat(orderedModifiers.filter(function(modifier) {
        return modifier.phase === phase;
      }));
    }, []);
  }

  // node_modules/@popperjs/core/lib/utils/debounce.js
  function debounce(fn2) {
    var pending;
    return function() {
      if (!pending) {
        pending = new Promise(function(resolve) {
          Promise.resolve().then(function() {
            pending = void 0;
            resolve(fn2());
          });
        });
      }
      return pending;
    };
  }

  // node_modules/@popperjs/core/lib/utils/mergeByName.js
  function mergeByName(modifiers) {
    var merged = modifiers.reduce(function(merged2, current) {
      var existing = merged2[current.name];
      merged2[current.name] = existing ? Object.assign({}, existing, current, {
        options: Object.assign({}, existing.options, current.options),
        data: Object.assign({}, existing.data, current.data)
      }) : current;
      return merged2;
    }, {});
    return Object.keys(merged).map(function(key) {
      return merged[key];
    });
  }

  // node_modules/@popperjs/core/lib/createPopper.js
  var DEFAULT_OPTIONS = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
  };
  function areValidElements() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return !args.some(function(element) {
      return !(element && typeof element.getBoundingClientRect === "function");
    });
  }
  function popperGenerator(generatorOptions) {
    if (generatorOptions === void 0) {
      generatorOptions = {};
    }
    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
    return function createPopper2(reference2, popper2, options) {
      if (options === void 0) {
        options = defaultOptions;
      }
      var state = {
        placement: "bottom",
        orderedModifiers: [],
        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
        modifiersData: {},
        elements: {
          reference: reference2,
          popper: popper2
        },
        attributes: {},
        styles: {}
      };
      var effectCleanupFns = [];
      var isDestroyed = false;
      var instance2 = {
        state,
        setOptions: function setOptions(setOptionsAction) {
          var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
          cleanupModifierEffects();
          state.options = Object.assign({}, defaultOptions, state.options, options2);
          state.scrollParents = {
            reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
            popper: listScrollParents(popper2)
          };
          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
          state.orderedModifiers = orderedModifiers.filter(function(m) {
            return m.enabled;
          });
          runModifierEffects();
          return instance2.update();
        },
        // Sync update – it will always be executed, even if not necessary. This
        // is useful for low frequency updates where sync behavior simplifies the
        // logic.
        // For high frequency updates (e.g. `resize` and `scroll` events), always
        // prefer the async Popper#update method
        forceUpdate: function forceUpdate() {
          if (isDestroyed) {
            return;
          }
          var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
          if (!areValidElements(reference3, popper3)) {
            return;
          }
          state.rects = {
            reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
            popper: getLayoutRect(popper3)
          };
          state.reset = false;
          state.placement = state.options.placement;
          state.orderedModifiers.forEach(function(modifier) {
            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
          });
          for (var index = 0; index < state.orderedModifiers.length; index++) {
            if (state.reset === true) {
              state.reset = false;
              index = -1;
              continue;
            }
            var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
            if (typeof fn2 === "function") {
              state = fn2({
                state,
                options: _options,
                name,
                instance: instance2
              }) || state;
            }
          }
        },
        // Async and optimistically optimized update – it will not be executed if
        // not necessary (debounced to run at most once-per-tick)
        update: debounce(function() {
          return new Promise(function(resolve) {
            instance2.forceUpdate();
            resolve(state);
          });
        }),
        destroy: function destroy() {
          cleanupModifierEffects();
          isDestroyed = true;
        }
      };
      if (!areValidElements(reference2, popper2)) {
        return instance2;
      }
      instance2.setOptions(options).then(function(state2) {
        if (!isDestroyed && options.onFirstUpdate) {
          options.onFirstUpdate(state2);
        }
      });
      function runModifierEffects() {
        state.orderedModifiers.forEach(function(_ref) {
          var name = _ref.name, _ref$options = _ref.options, options2 = _ref$options === void 0 ? {} : _ref$options, effect4 = _ref.effect;
          if (typeof effect4 === "function") {
            var cleanupFn = effect4({
              state,
              name,
              instance: instance2,
              options: options2
            });
            var noopFn = function noopFn2() {
            };
            effectCleanupFns.push(cleanupFn || noopFn);
          }
        });
      }
      function cleanupModifierEffects() {
        effectCleanupFns.forEach(function(fn2) {
          return fn2();
        });
        effectCleanupFns = [];
      }
      return instance2;
    };
  }

  // node_modules/@popperjs/core/lib/popper.js
  var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
  var createPopper = /* @__PURE__ */ popperGenerator({
    defaultModifiers
  });

  // node_modules/@mui/material/Portal/Portal.js
  var React49 = __toESM(require_react());
  var ReactDOM2 = __toESM(require_react_dom());
  function getContainer(container2) {
    return typeof container2 === "function" ? container2() : container2;
  }
  var Portal = /* @__PURE__ */ React49.forwardRef(function Portal2(props, forwardedRef) {
    const {
      children,
      container: container2,
      disablePortal = false
    } = props;
    const [mountNode, setMountNode] = React49.useState(null);
    const handleRef = useForkRef(/* @__PURE__ */ React49.isValidElement(children) ? getReactElementRef(children) : null, forwardedRef);
    useEnhancedEffect_default(() => {
      if (!disablePortal) {
        setMountNode(getContainer(container2) || document.body);
      }
    }, [container2, disablePortal]);
    useEnhancedEffect_default(() => {
      if (mountNode && !disablePortal) {
        setRef(forwardedRef, mountNode);
        return () => {
          setRef(forwardedRef, null);
        };
      }
      return void 0;
    }, [forwardedRef, mountNode, disablePortal]);
    if (disablePortal) {
      if (/* @__PURE__ */ React49.isValidElement(children)) {
        const newProps = {
          ref: handleRef
        };
        return /* @__PURE__ */ React49.cloneElement(children, newProps);
      }
      return children;
    }
    return mountNode ? /* @__PURE__ */ ReactDOM2.createPortal(children, mountNode) : mountNode;
  });
  false ? Portal.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The children to render into the `container`.
     */
    children: import_prop_types.default.node,
    /**
     * An HTML element or function that returns one.
     * The `container` will have the portal children appended to it.
     *
     * You can also provide a callback, which is called in a React layout effect.
     * This lets you set the container from a ref, and also makes server-side rendering possible.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: import_prop_types.default.oneOfType([HTMLElementType, import_prop_types.default.func]),
    /**
     * The `children` will be under the DOM hierarchy of the parent component.
     * @default false
     */
    disablePortal: import_prop_types.default.bool
  } : void 0;
  if (false) {
    Portal["propTypes"] = exactProp(Portal.propTypes);
  }
  var Portal_default = Portal;

  // node_modules/@mui/material/Popper/popperClasses.js
  function getPopperUtilityClass(slot) {
    return generateUtilityClass("MuiPopper", slot);
  }
  var popperClasses = generateUtilityClasses("MuiPopper", ["root"]);

  // node_modules/@mui/material/Popper/BasePopper.js
  var import_jsx_runtime27 = __toESM(require_jsx_runtime());
  function flipPlacement(placement, direction) {
    if (direction === "ltr") {
      return placement;
    }
    switch (placement) {
      case "bottom-end":
        return "bottom-start";
      case "bottom-start":
        return "bottom-end";
      case "top-end":
        return "top-start";
      case "top-start":
        return "top-end";
      default:
        return placement;
    }
  }
  function resolveAnchorEl(anchorEl) {
    return typeof anchorEl === "function" ? anchorEl() : anchorEl;
  }
  function isHTMLElement2(element) {
    return element.nodeType !== void 0;
  }
  var useUtilityClasses7 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getPopperUtilityClass, classes);
  };
  var defaultPopperOptions = {};
  var PopperTooltip = /* @__PURE__ */ React50.forwardRef(function PopperTooltip2(props, forwardedRef) {
    var _b;
    const _a = props, {
      anchorEl,
      children,
      direction,
      disablePortal,
      modifiers,
      open,
      placement: initialPlacement,
      popperOptions,
      popperRef: popperRefProp,
      slotProps = {},
      slots = {},
      TransitionProps,
      ownerState: ownerStateProp
    } = _a, other = __objRest(_a, [
      "anchorEl",
      "children",
      "direction",
      "disablePortal",
      "modifiers",
      "open",
      "placement",
      "popperOptions",
      "popperRef",
      "slotProps",
      "slots",
      "TransitionProps",
      // @ts-ignore internal logic
      "ownerState"
    ]);
    const tooltipRef = React50.useRef(null);
    const ownRef = useForkRef(tooltipRef, forwardedRef);
    const popperRef = React50.useRef(null);
    const handlePopperRef = useForkRef(popperRef, popperRefProp);
    const handlePopperRefRef = React50.useRef(handlePopperRef);
    useEnhancedEffect_default(() => {
      handlePopperRefRef.current = handlePopperRef;
    }, [handlePopperRef]);
    React50.useImperativeHandle(popperRefProp, () => popperRef.current, []);
    const rtlPlacement = flipPlacement(initialPlacement, direction);
    const [placement, setPlacement] = React50.useState(rtlPlacement);
    const [resolvedAnchorElement, setResolvedAnchorElement] = React50.useState(resolveAnchorEl(anchorEl));
    React50.useEffect(() => {
      if (popperRef.current) {
        popperRef.current.forceUpdate();
      }
    });
    React50.useEffect(() => {
      if (anchorEl) {
        setResolvedAnchorElement(resolveAnchorEl(anchorEl));
      }
    }, [anchorEl]);
    useEnhancedEffect_default(() => {
      if (!resolvedAnchorElement || !open) {
        return void 0;
      }
      const handlePopperUpdate = (data) => {
        setPlacement(data.placement);
      };
      if (false) {
        if (resolvedAnchorElement && isHTMLElement2(resolvedAnchorElement) && resolvedAnchorElement.nodeType === 1) {
          const box = resolvedAnchorElement.getBoundingClientRect();
          if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
            console.warn(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join("\n"));
          }
        }
      }
      let popperModifiers = [{
        name: "preventOverflow",
        options: {
          altBoundary: disablePortal
        }
      }, {
        name: "flip",
        options: {
          altBoundary: disablePortal
        }
      }, {
        name: "onUpdate",
        enabled: true,
        phase: "afterWrite",
        fn: ({
          state
        }) => {
          handlePopperUpdate(state);
        }
      }];
      if (modifiers != null) {
        popperModifiers = popperModifiers.concat(modifiers);
      }
      if (popperOptions && popperOptions.modifiers != null) {
        popperModifiers = popperModifiers.concat(popperOptions.modifiers);
      }
      const popper2 = createPopper(resolvedAnchorElement, tooltipRef.current, __spreadProps(__spreadValues({
        placement: rtlPlacement
      }, popperOptions), {
        modifiers: popperModifiers
      }));
      handlePopperRefRef.current(popper2);
      return () => {
        popper2.destroy();
        handlePopperRefRef.current(null);
      };
    }, [resolvedAnchorElement, disablePortal, modifiers, open, popperOptions, rtlPlacement]);
    const childProps = {
      placement
    };
    if (TransitionProps !== null) {
      childProps.TransitionProps = TransitionProps;
    }
    const classes = useUtilityClasses7(props);
    const Root2 = (_b = slots.root) != null ? _b : "div";
    const rootProps = useSlotProps_default({
      elementType: Root2,
      externalSlotProps: slotProps.root,
      externalForwardedProps: other,
      additionalProps: {
        role: "tooltip",
        ref: ownRef
      },
      ownerState: props,
      className: classes.root
    });
    return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Root2, __spreadProps(__spreadValues({}, rootProps), {
      children: typeof children === "function" ? children(childProps) : children
    }));
  });
  var Popper = /* @__PURE__ */ React50.forwardRef(function Popper2(props, forwardedRef) {
    const _a = props, {
      anchorEl,
      children,
      container: containerProp,
      direction = "ltr",
      disablePortal = false,
      keepMounted = false,
      modifiers,
      open,
      placement = "bottom",
      popperOptions = defaultPopperOptions,
      popperRef,
      style: style4,
      transition = false,
      slotProps = {},
      slots = {}
    } = _a, other = __objRest(_a, [
      "anchorEl",
      "children",
      "container",
      "direction",
      "disablePortal",
      "keepMounted",
      "modifiers",
      "open",
      "placement",
      "popperOptions",
      "popperRef",
      "style",
      "transition",
      "slotProps",
      "slots"
    ]);
    const [exited, setExited] = React50.useState(true);
    const handleEnter = () => {
      setExited(false);
    };
    const handleExited = () => {
      setExited(true);
    };
    if (!keepMounted && !open && (!transition || exited)) {
      return null;
    }
    let container2;
    if (containerProp) {
      container2 = containerProp;
    } else if (anchorEl) {
      const resolvedAnchorEl = resolveAnchorEl(anchorEl);
      container2 = resolvedAnchorEl && isHTMLElement2(resolvedAnchorEl) ? ownerDocument(resolvedAnchorEl).body : ownerDocument(null).body;
    }
    const display = !open && keepMounted && (!transition || exited) ? "none" : void 0;
    const transitionProps = transition ? {
      in: open,
      onEnter: handleEnter,
      onExited: handleExited
    } : void 0;
    return /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(Portal_default, {
      disablePortal,
      container: container2,
      children: /* @__PURE__ */ (0, import_jsx_runtime27.jsx)(PopperTooltip, __spreadProps(__spreadValues({
        anchorEl,
        direction,
        disablePortal,
        modifiers,
        ref: forwardedRef,
        open: transition ? !exited : open,
        placement,
        popperOptions,
        popperRef,
        slotProps,
        slots
      }, other), {
        style: __spreadValues({
          // Prevents scroll issue, waiting for Popper.js to add this style once initiated.
          position: "fixed",
          // Fix Popper.js display issue
          top: 0,
          left: 0,
          display
        }, style4),
        TransitionProps: transitionProps,
        children
      }))
    });
  });
  false ? Popper.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
     * or a function that returns either.
     * It's used to set the position of the popper.
     * The return value will passed as the reference object of the Popper instance.
     */
    anchorEl: chainPropTypes(import_prop_types.default.oneOfType([HTMLElementType, import_prop_types.default.object, import_prop_types.default.func]), (props) => {
      if (props.open) {
        const resolvedAnchorEl = resolveAnchorEl(props.anchorEl);
        if (resolvedAnchorEl && isHTMLElement2(resolvedAnchorEl) && resolvedAnchorEl.nodeType === 1) {
          const box = resolvedAnchorEl.getBoundingClientRect();
          if (box.top === 0 && box.left === 0 && box.right === 0 && box.bottom === 0) {
            return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "The anchor element should be part of the document layout.", "Make sure the element is present in the document or that it's not display none."].join("\n"));
          }
        } else if (!resolvedAnchorEl || typeof resolvedAnchorEl.getBoundingClientRect !== "function" || isVirtualElement(resolvedAnchorEl) && resolvedAnchorEl.contextElement != null && resolvedAnchorEl.contextElement.nodeType !== 1) {
          return new Error(["MUI: The `anchorEl` prop provided to the component is invalid.", "It should be an HTML element instance or a virtualElement ", "(https://popper.js.org/docs/v2/virtual-elements/)."].join("\n"));
        }
      }
      return null;
    }),
    /**
     * Popper render function or node.
     */
    children: import_prop_types.default.oneOfType([import_prop_types.default.node, import_prop_types.default.func]),
    /**
     * An HTML element or function that returns one.
     * The `container` will have the portal children appended to it.
     *
     * You can also provide a callback, which is called in a React layout effect.
     * This lets you set the container from a ref, and also makes server-side rendering possible.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: import_prop_types.default.oneOfType([HTMLElementType, import_prop_types.default.func]),
    /**
     * Direction of the text.
     * @default 'ltr'
     */
    direction: import_prop_types.default.oneOf(["ltr", "rtl"]),
    /**
     * The `children` will be under the DOM hierarchy of the parent component.
     * @default false
     */
    disablePortal: import_prop_types.default.bool,
    /**
     * Always keep the children in the DOM.
     * This prop can be useful in SEO situation or
     * when you want to maximize the responsiveness of the Popper.
     * @default false
     */
    keepMounted: import_prop_types.default.bool,
    /**
     * Popper.js is based on a "plugin-like" architecture,
     * most of its features are fully encapsulated "modifiers".
     *
     * A modifier is a function that is called each time Popper.js needs to
     * compute the position of the popper.
     * For this reason, modifiers should be very performant to avoid bottlenecks.
     * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
     */
    modifiers: import_prop_types.default.arrayOf(import_prop_types.default.shape({
      data: import_prop_types.default.object,
      effect: import_prop_types.default.func,
      enabled: import_prop_types.default.bool,
      fn: import_prop_types.default.func,
      name: import_prop_types.default.any,
      options: import_prop_types.default.object,
      phase: import_prop_types.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
      requires: import_prop_types.default.arrayOf(import_prop_types.default.string),
      requiresIfExists: import_prop_types.default.arrayOf(import_prop_types.default.string)
    })),
    /**
     * If `true`, the component is shown.
     */
    open: import_prop_types.default.bool.isRequired,
    /**
     * Popper placement.
     * @default 'bottom'
     */
    placement: import_prop_types.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    /**
     * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
     * @default {}
     */
    popperOptions: import_prop_types.default.shape({
      modifiers: import_prop_types.default.array,
      onFirstUpdate: import_prop_types.default.func,
      placement: import_prop_types.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
      strategy: import_prop_types.default.oneOf(["absolute", "fixed"])
    }),
    /**
     * A ref that points to the used popper instance.
     */
    popperRef: refType_default,
    /**
     * The props used for each slot inside the Popper.
     * @default {}
     */
    slotProps: import_prop_types.default.shape({
      root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
    }),
    /**
     * The components used for each slot inside the Popper.
     * Either a string to use a HTML element or a component.
     * @default {}
     */
    slots: import_prop_types.default.shape({
      root: import_prop_types.default.elementType
    }),
    /**
     * Help supporting a react-transition-group/Transition component.
     * @default false
     */
    transition: import_prop_types.default.bool
  } : void 0;
  var BasePopper_default = Popper;

  // node_modules/@mui/material/Popper/Popper.js
  var import_jsx_runtime28 = __toESM(require_jsx_runtime());
  var PopperRoot = styled_default2(BasePopper_default, {
    name: "MuiPopper",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  var Popper3 = /* @__PURE__ */ React51.forwardRef(function Popper4(inProps, ref) {
    var _b;
    const isRtl = useRtl();
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiPopper"
    });
    const _a = props, {
      anchorEl,
      component,
      components,
      componentsProps,
      container: container2,
      disablePortal,
      keepMounted,
      modifiers,
      open,
      placement,
      popperOptions,
      popperRef,
      transition,
      slots,
      slotProps
    } = _a, other = __objRest(_a, [
      "anchorEl",
      "component",
      "components",
      "componentsProps",
      "container",
      "disablePortal",
      "keepMounted",
      "modifiers",
      "open",
      "placement",
      "popperOptions",
      "popperRef",
      "transition",
      "slots",
      "slotProps"
    ]);
    const RootComponent = (_b = slots == null ? void 0 : slots.root) != null ? _b : components == null ? void 0 : components.Root;
    const otherProps = __spreadValues({
      anchorEl,
      container: container2,
      disablePortal,
      keepMounted,
      modifiers,
      open,
      placement,
      popperOptions,
      popperRef,
      transition
    }, other);
    return /* @__PURE__ */ (0, import_jsx_runtime28.jsx)(PopperRoot, __spreadProps(__spreadValues({
      as: component,
      direction: isRtl ? "rtl" : "ltr",
      slots: {
        root: RootComponent
      },
      slotProps: slotProps != null ? slotProps : componentsProps
    }, otherProps), {
      ref
    }));
  });
  false ? Popper3.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * An HTML element, [virtualElement](https://popper.js.org/docs/v2/virtual-elements/),
     * or a function that returns either.
     * It's used to set the position of the popper.
     * The return value will passed as the reference object of the Popper instance.
     */
    anchorEl: import_prop_types.default.oneOfType([HTMLElementType, import_prop_types.default.object, import_prop_types.default.func]),
    /**
     * Popper render function or node.
     */
    children: import_prop_types.default.oneOfType([import_prop_types.default.node, import_prop_types.default.func]),
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * The components used for each slot inside the Popper.
     * Either a string to use a HTML element or a component.
     *
     * @deprecated use the `slots` prop instead. This prop will be removed in v7. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
     * @default {}
     */
    components: import_prop_types.default.shape({
      Root: import_prop_types.default.elementType
    }),
    /**
     * The props used for each slot inside the Popper.
     *
     * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. [How to migrate](/material-ui/migration/migrating-from-deprecated-apis/).
     * @default {}
     */
    componentsProps: import_prop_types.default.shape({
      root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
    }),
    /**
     * An HTML element or function that returns one.
     * The `container` will have the portal children appended to it.
     *
     * You can also provide a callback, which is called in a React layout effect.
     * This lets you set the container from a ref, and also makes server-side rendering possible.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: import_prop_types.default.oneOfType([HTMLElementType, import_prop_types.default.func]),
    /**
     * The `children` will be under the DOM hierarchy of the parent component.
     * @default false
     */
    disablePortal: import_prop_types.default.bool,
    /**
     * Always keep the children in the DOM.
     * This prop can be useful in SEO situation or
     * when you want to maximize the responsiveness of the Popper.
     * @default false
     */
    keepMounted: import_prop_types.default.bool,
    /**
     * Popper.js is based on a "plugin-like" architecture,
     * most of its features are fully encapsulated "modifiers".
     *
     * A modifier is a function that is called each time Popper.js needs to
     * compute the position of the popper.
     * For this reason, modifiers should be very performant to avoid bottlenecks.
     * To learn how to create a modifier, [read the modifiers documentation](https://popper.js.org/docs/v2/modifiers/).
     */
    modifiers: import_prop_types.default.arrayOf(import_prop_types.default.shape({
      data: import_prop_types.default.object,
      effect: import_prop_types.default.func,
      enabled: import_prop_types.default.bool,
      fn: import_prop_types.default.func,
      name: import_prop_types.default.any,
      options: import_prop_types.default.object,
      phase: import_prop_types.default.oneOf(["afterMain", "afterRead", "afterWrite", "beforeMain", "beforeRead", "beforeWrite", "main", "read", "write"]),
      requires: import_prop_types.default.arrayOf(import_prop_types.default.string),
      requiresIfExists: import_prop_types.default.arrayOf(import_prop_types.default.string)
    })),
    /**
     * If `true`, the component is shown.
     */
    open: import_prop_types.default.bool.isRequired,
    /**
     * Popper placement.
     * @default 'bottom'
     */
    placement: import_prop_types.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
    /**
     * Options provided to the [`Popper.js`](https://popper.js.org/docs/v2/constructors/#options) instance.
     * @default {}
     */
    popperOptions: import_prop_types.default.shape({
      modifiers: import_prop_types.default.array,
      onFirstUpdate: import_prop_types.default.func,
      placement: import_prop_types.default.oneOf(["auto-end", "auto-start", "auto", "bottom-end", "bottom-start", "bottom", "left-end", "left-start", "left", "right-end", "right-start", "right", "top-end", "top-start", "top"]),
      strategy: import_prop_types.default.oneOf(["absolute", "fixed"])
    }),
    /**
     * A ref that points to the used popper instance.
     */
    popperRef: refType_default,
    /**
     * The props used for each slot inside the Popper.
     * @default {}
     */
    slotProps: import_prop_types.default.shape({
      root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
    }),
    /**
     * The components used for each slot inside the Popper.
     * Either a string to use a HTML element or a component.
     * @default {}
     */
    slots: import_prop_types.default.shape({
      root: import_prop_types.default.elementType
    }),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * Help supporting a react-transition-group/Transition component.
     * @default false
     */
    transition: import_prop_types.default.bool
  } : void 0;
  var Popper_default = Popper3;

  // node_modules/@mui/material/Backdrop/Backdrop.js
  var React53 = __toESM(require_react());

  // node_modules/@mui/material/Fade/Fade.js
  var React52 = __toESM(require_react());
  var import_jsx_runtime29 = __toESM(require_jsx_runtime());
  var styles = {
    entering: {
      opacity: 1
    },
    entered: {
      opacity: 1
    }
  };
  var Fade = /* @__PURE__ */ React52.forwardRef(function Fade2(props, ref) {
    const theme = useTheme5();
    const defaultTimeout = {
      enter: theme.transitions.duration.enteringScreen,
      exit: theme.transitions.duration.leavingScreen
    };
    const _a = props, {
      addEndListener,
      appear = true,
      children,
      easing: easing2,
      in: inProp,
      onEnter,
      onEntered,
      onEntering,
      onExit,
      onExited,
      onExiting,
      style: style4,
      timeout: timeout2 = defaultTimeout,
      TransitionComponent: TransitionComponent = Transition_default
    } = _a, other = __objRest(_a, [
      "addEndListener",
      "appear",
      "children",
      "easing",
      "in",
      "onEnter",
      "onEntered",
      "onEntering",
      "onExit",
      "onExited",
      "onExiting",
      "style",
      "timeout",
      // eslint-disable-next-line react/prop-types
      "TransitionComponent"
    ]);
    const enableStrictModeCompat = true;
    const nodeRef = React52.useRef(null);
    const handleRef = useForkRef_default(nodeRef, getReactElementRef(children), ref);
    const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
      if (callback) {
        const node2 = nodeRef.current;
        if (maybeIsAppearing === void 0) {
          callback(node2);
        } else {
          callback(node2, maybeIsAppearing);
        }
      }
    };
    const handleEntering = normalizedTransitionCallback(onEntering);
    const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
      reflow(node2);
      const transitionProps = getTransitionProps({
        style: style4,
        timeout: timeout2,
        easing: easing2
      }, {
        mode: "enter"
      });
      node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
      node2.style.transition = theme.transitions.create("opacity", transitionProps);
      if (onEnter) {
        onEnter(node2, isAppearing);
      }
    });
    const handleEntered = normalizedTransitionCallback(onEntered);
    const handleExiting = normalizedTransitionCallback(onExiting);
    const handleExit = normalizedTransitionCallback((node2) => {
      const transitionProps = getTransitionProps({
        style: style4,
        timeout: timeout2,
        easing: easing2
      }, {
        mode: "exit"
      });
      node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
      node2.style.transition = theme.transitions.create("opacity", transitionProps);
      if (onExit) {
        onExit(node2);
      }
    });
    const handleExited = normalizedTransitionCallback(onExited);
    const handleAddEndListener = (next2) => {
      if (addEndListener) {
        addEndListener(nodeRef.current, next2);
      }
    };
    return /* @__PURE__ */ (0, import_jsx_runtime29.jsx)(TransitionComponent, __spreadProps(__spreadValues({
      appear,
      in: inProp,
      nodeRef: enableStrictModeCompat ? nodeRef : void 0,
      onEnter: handleEnter,
      onEntered: handleEntered,
      onEntering: handleEntering,
      onExit: handleExit,
      onExited: handleExited,
      onExiting: handleExiting,
      addEndListener: handleAddEndListener,
      timeout: timeout2
    }, other), {
      children: (state, _b) => {
        var _c = _b, {
          ownerState
        } = _c, restChildProps = __objRest(_c, [
          "ownerState"
        ]);
        return /* @__PURE__ */ React52.cloneElement(children, __spreadValues({
          style: __spreadValues(__spreadValues(__spreadValues({
            opacity: 0,
            visibility: state === "exited" && !inProp ? "hidden" : void 0
          }, styles[state]), style4), children.props.style),
          ref: handleRef
        }, restChildProps));
      }
    }));
  });
  false ? Fade.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * Add a custom transition end trigger. Called with the transitioning DOM
     * node and a done callback. Allows for more fine grained transition end
     * logic. Note: Timeouts are still used as a fallback if provided.
     */
    addEndListener: import_prop_types.default.func,
    /**
     * Perform the enter transition when it first mounts if `in` is also `true`.
     * Set this to `false` to disable this behavior.
     * @default true
     */
    appear: import_prop_types.default.bool,
    /**
     * A single child content element.
     */
    children: elementAcceptingRef_default.isRequired,
    /**
     * The transition timing function.
     * You may specify a single easing or a object containing enter and exit values.
     */
    easing: import_prop_types.default.oneOfType([import_prop_types.default.shape({
      enter: import_prop_types.default.string,
      exit: import_prop_types.default.string
    }), import_prop_types.default.string]),
    /**
     * If `true`, the component will transition in.
     */
    in: import_prop_types.default.bool,
    /**
     * @ignore
     */
    onEnter: import_prop_types.default.func,
    /**
     * @ignore
     */
    onEntered: import_prop_types.default.func,
    /**
     * @ignore
     */
    onEntering: import_prop_types.default.func,
    /**
     * @ignore
     */
    onExit: import_prop_types.default.func,
    /**
     * @ignore
     */
    onExited: import_prop_types.default.func,
    /**
     * @ignore
     */
    onExiting: import_prop_types.default.func,
    /**
     * @ignore
     */
    style: import_prop_types.default.object,
    /**
     * The duration for the transition, in milliseconds.
     * You may specify a single timeout for all transitions, or individually with an object.
     * @default {
     *   enter: theme.transitions.duration.enteringScreen,
     *   exit: theme.transitions.duration.leavingScreen,
     * }
     */
    timeout: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
      appear: import_prop_types.default.number,
      enter: import_prop_types.default.number,
      exit: import_prop_types.default.number
    })])
  } : void 0;
  var Fade_default = Fade;

  // node_modules/@mui/material/Backdrop/backdropClasses.js
  function getBackdropUtilityClass(slot) {
    return generateUtilityClass("MuiBackdrop", slot);
  }
  var backdropClasses = generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);

  // node_modules/@mui/material/Backdrop/Backdrop.js
  var import_jsx_runtime30 = __toESM(require_jsx_runtime());
  var useUtilityClasses8 = (ownerState) => {
    const {
      classes,
      invisible
    } = ownerState;
    const slots = {
      root: ["root", invisible && "invisible"]
    };
    return composeClasses(slots, getBackdropUtilityClass, classes);
  };
  var BackdropRoot = styled_default2("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.invisible && styles2.invisible];
    }
  })({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent",
    variants: [{
      props: {
        invisible: true
      },
      style: {
        backgroundColor: "transparent"
      }
    }]
  });
  var Backdrop = /* @__PURE__ */ React53.forwardRef(function Backdrop2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiBackdrop"
    });
    const _a = props, {
      children,
      className,
      component = "div",
      invisible = false,
      open,
      components = {},
      componentsProps = {},
      slotProps = {},
      slots = {},
      TransitionComponent: TransitionComponentProp,
      transitionDuration
    } = _a, other = __objRest(_a, [
      "children",
      "className",
      "component",
      "invisible",
      "open",
      "components",
      "componentsProps",
      "slotProps",
      "slots",
      "TransitionComponent",
      "transitionDuration"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      component,
      invisible
    });
    const classes = useUtilityClasses8(ownerState);
    const backwardCompatibleSlots = __spreadValues({
      transition: TransitionComponentProp,
      root: components.Root
    }, slots);
    const backwardCompatibleSlotProps = __spreadValues(__spreadValues({}, componentsProps), slotProps);
    const externalForwardedProps = {
      slots: backwardCompatibleSlots,
      slotProps: backwardCompatibleSlotProps
    };
    const [RootSlot, rootProps] = useSlot("root", {
      elementType: BackdropRoot,
      externalForwardedProps,
      className: clsx_default(classes.root, className),
      ownerState
    });
    const [TransitionSlot, transitionProps] = useSlot("transition", {
      elementType: Fade_default,
      externalForwardedProps,
      ownerState
    });
    return /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(TransitionSlot, __spreadProps(__spreadValues(__spreadValues({
      in: open,
      timeout: transitionDuration
    }, other), transitionProps), {
      children: /* @__PURE__ */ (0, import_jsx_runtime30.jsx)(RootSlot, __spreadProps(__spreadValues({
        "aria-hidden": true
      }, rootProps), {
        classes,
        ref,
        children
      }))
    }));
  });
  false ? Backdrop.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the component.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * The components used for each slot inside.
     *
     * @deprecated Use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
     *
     * @default {}
     */
    components: import_prop_types.default.shape({
      Root: import_prop_types.default.elementType
    }),
    /**
     * The extra props for the slot components.
     * You can override the existing props or add new ones.
     *
     * @deprecated Use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
     *
     * @default {}
     */
    componentsProps: import_prop_types.default.shape({
      root: import_prop_types.default.object
    }),
    /**
     * If `true`, the backdrop is invisible.
     * It can be used when rendering a popover or a custom select component.
     * @default false
     */
    invisible: import_prop_types.default.bool,
    /**
     * If `true`, the component is shown.
     */
    open: import_prop_types.default.bool.isRequired,
    /**
     * The props used for each slot inside.
     * @default {}
     */
    slotProps: import_prop_types.default.shape({
      root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
      transition: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
    }),
    /**
     * The components used for each slot inside.
     * @default {}
     */
    slots: import_prop_types.default.shape({
      root: import_prop_types.default.elementType,
      transition: import_prop_types.default.elementType
    }),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * The component used for the transition.
     * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
     * @default Fade
     * @deprecated Use `slots.transition` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
     */
    TransitionComponent: import_prop_types.default.elementType,
    /**
     * The duration for the transition, in milliseconds.
     * You may specify a single timeout for all transitions, or individually with an object.
     */
    transitionDuration: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
      appear: import_prop_types.default.number,
      enter: import_prop_types.default.number,
      exit: import_prop_types.default.number
    })])
  } : void 0;
  var Backdrop_default = Backdrop;

  // node_modules/@mui/material/Badge/Badge.js
  var React54 = __toESM(require_react());

  // node_modules/@mui/material/Badge/useBadge.js
  function useBadge(parameters) {
    const {
      badgeContent: badgeContentProp,
      invisible: invisibleProp = false,
      max: maxProp = 99,
      showZero = false
    } = parameters;
    const prevProps = usePreviousProps_default({
      badgeContent: badgeContentProp,
      max: maxProp
    });
    let invisible = invisibleProp;
    if (invisibleProp === false && badgeContentProp === 0 && !showZero) {
      invisible = true;
    }
    const {
      badgeContent,
      max: max2 = maxProp
    } = invisible ? prevProps : parameters;
    const displayValue = badgeContent && Number(badgeContent) > max2 ? `${max2}+` : badgeContent;
    return {
      badgeContent,
      invisible,
      max: max2,
      displayValue
    };
  }
  var useBadge_default = useBadge;

  // node_modules/@mui/material/Badge/badgeClasses.js
  function getBadgeUtilityClass(slot) {
    return generateUtilityClass("MuiBadge", slot);
  }
  var badgeClasses = generateUtilityClasses("MuiBadge", [
    "root",
    "badge",
    "dot",
    "standard",
    "anchorOriginTopRight",
    "anchorOriginBottomRight",
    "anchorOriginTopLeft",
    "anchorOriginBottomLeft",
    "invisible",
    "colorError",
    "colorInfo",
    "colorPrimary",
    "colorSecondary",
    "colorSuccess",
    "colorWarning",
    "overlapRectangular",
    "overlapCircular",
    // TODO: v6 remove the overlap value from these class keys
    "anchorOriginTopLeftCircular",
    "anchorOriginTopLeftRectangular",
    "anchorOriginTopRightCircular",
    "anchorOriginTopRightRectangular",
    "anchorOriginBottomLeftCircular",
    "anchorOriginBottomLeftRectangular",
    "anchorOriginBottomRightCircular",
    "anchorOriginBottomRightRectangular"
  ]);
  var badgeClasses_default = badgeClasses;

  // node_modules/@mui/material/Badge/Badge.js
  var import_jsx_runtime31 = __toESM(require_jsx_runtime());
  var RADIUS_STANDARD = 10;
  var RADIUS_DOT = 4;
  var useUtilityClasses9 = (ownerState) => {
    const {
      color: color3,
      anchorOrigin,
      invisible,
      overlap,
      variant,
      classes = {}
    } = ownerState;
    const slots = {
      root: ["root"],
      badge: ["badge", variant, invisible && "invisible", `anchorOrigin${capitalize_default(anchorOrigin.vertical)}${capitalize_default(anchorOrigin.horizontal)}`, `anchorOrigin${capitalize_default(anchorOrigin.vertical)}${capitalize_default(anchorOrigin.horizontal)}${capitalize_default(overlap)}`, `overlap${capitalize_default(overlap)}`, color3 !== "default" && `color${capitalize_default(color3)}`]
    };
    return composeClasses(slots, getBadgeUtilityClass, classes);
  };
  var BadgeRoot = styled_default2("span", {
    name: "MuiBadge",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    position: "relative",
    display: "inline-flex",
    // For correct alignment with the text.
    verticalAlign: "middle",
    flexShrink: 0
  });
  var BadgeBadge = styled_default2("span", {
    name: "MuiBadge",
    slot: "Badge",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.badge, styles2[ownerState.variant], styles2[`anchorOrigin${capitalize_default(ownerState.anchorOrigin.vertical)}${capitalize_default(ownerState.anchorOrigin.horizontal)}${capitalize_default(ownerState.overlap)}`], ownerState.color !== "default" && styles2[`color${capitalize_default(ownerState.color)}`], ownerState.invisible && styles2.invisible];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    display: "flex",
    flexDirection: "row",
    flexWrap: "wrap",
    justifyContent: "center",
    alignContent: "center",
    alignItems: "center",
    position: "absolute",
    boxSizing: "border-box",
    fontFamily: theme.typography.fontFamily,
    fontWeight: theme.typography.fontWeightMedium,
    fontSize: theme.typography.pxToRem(12),
    minWidth: RADIUS_STANDARD * 2,
    lineHeight: 1,
    padding: "0 6px",
    height: RADIUS_STANDARD * 2,
    borderRadius: RADIUS_STANDARD,
    zIndex: 1,
    // Render the badge on top of potential ripples.
    transition: theme.transitions.create("transform", {
      easing: theme.transitions.easing.easeInOut,
      duration: theme.transitions.duration.enteringScreen
    }),
    variants: [...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(["contrastText"])).map(([color3]) => ({
      props: {
        color: color3
      },
      style: {
        backgroundColor: (theme.vars || theme).palette[color3].main,
        color: (theme.vars || theme).palette[color3].contrastText
      }
    })), {
      props: {
        variant: "dot"
      },
      style: {
        borderRadius: RADIUS_DOT,
        height: RADIUS_DOT * 2,
        minWidth: RADIUS_DOT * 2,
        padding: 0
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
      style: {
        top: 0,
        right: 0,
        transform: "scale(1) translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&.${badgeClasses_default.invisible}`]: {
          transform: "scale(0) translate(50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "rectangular",
      style: {
        bottom: 0,
        right: 0,
        transform: "scale(1) translate(50%, 50%)",
        transformOrigin: "100% 100%",
        [`&.${badgeClasses_default.invisible}`]: {
          transform: "scale(0) translate(50%, 50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
      style: {
        top: 0,
        left: 0,
        transform: "scale(1) translate(-50%, -50%)",
        transformOrigin: "0% 0%",
        [`&.${badgeClasses_default.invisible}`]: {
          transform: "scale(0) translate(-50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "rectangular",
      style: {
        bottom: 0,
        left: 0,
        transform: "scale(1) translate(-50%, 50%)",
        transformOrigin: "0% 100%",
        [`&.${badgeClasses_default.invisible}`]: {
          transform: "scale(0) translate(-50%, 50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
      style: {
        top: "14%",
        right: "14%",
        transform: "scale(1) translate(50%, -50%)",
        transformOrigin: "100% 0%",
        [`&.${badgeClasses_default.invisible}`]: {
          transform: "scale(0) translate(50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "right" && ownerState.overlap === "circular",
      style: {
        bottom: "14%",
        right: "14%",
        transform: "scale(1) translate(50%, 50%)",
        transformOrigin: "100% 100%",
        [`&.${badgeClasses_default.invisible}`]: {
          transform: "scale(0) translate(50%, 50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "top" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
      style: {
        top: "14%",
        left: "14%",
        transform: "scale(1) translate(-50%, -50%)",
        transformOrigin: "0% 0%",
        [`&.${badgeClasses_default.invisible}`]: {
          transform: "scale(0) translate(-50%, -50%)"
        }
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.anchorOrigin.vertical === "bottom" && ownerState.anchorOrigin.horizontal === "left" && ownerState.overlap === "circular",
      style: {
        bottom: "14%",
        left: "14%",
        transform: "scale(1) translate(-50%, 50%)",
        transformOrigin: "0% 100%",
        [`&.${badgeClasses_default.invisible}`]: {
          transform: "scale(0) translate(-50%, 50%)"
        }
      }
    }, {
      props: {
        invisible: true
      },
      style: {
        transition: theme.transitions.create("transform", {
          easing: theme.transitions.easing.easeInOut,
          duration: theme.transitions.duration.leavingScreen
        })
      }
    }]
  })));
  function getAnchorOrigin(anchorOrigin) {
    var _a, _b;
    return {
      vertical: (_a = anchorOrigin == null ? void 0 : anchorOrigin.vertical) != null ? _a : "top",
      horizontal: (_b = anchorOrigin == null ? void 0 : anchorOrigin.horizontal) != null ? _b : "right"
    };
  }
  var Badge = /* @__PURE__ */ React54.forwardRef(function Badge2(inProps, ref) {
    var _b, _c, _d, _e, _f, _g;
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiBadge"
    });
    const _a = props, {
      anchorOrigin: anchorOriginProp,
      className,
      classes: classesProp,
      component,
      components = {},
      componentsProps = {},
      children,
      overlap: overlapProp = "rectangular",
      color: colorProp = "default",
      invisible: invisibleProp = false,
      max: maxProp = 99,
      badgeContent: badgeContentProp,
      slots,
      slotProps,
      showZero = false,
      variant: variantProp = "standard"
    } = _a, other = __objRest(_a, [
      "anchorOrigin",
      "className",
      "classes",
      "component",
      "components",
      "componentsProps",
      "children",
      "overlap",
      "color",
      "invisible",
      "max",
      "badgeContent",
      "slots",
      "slotProps",
      "showZero",
      "variant"
    ]);
    const {
      badgeContent,
      invisible: invisibleFromHook,
      max: max2,
      displayValue: displayValueFromHook
    } = useBadge_default({
      max: maxProp,
      invisible: invisibleProp,
      badgeContent: badgeContentProp,
      showZero
    });
    const prevProps = usePreviousProps_default({
      anchorOrigin: getAnchorOrigin(anchorOriginProp),
      color: colorProp,
      overlap: overlapProp,
      variant: variantProp,
      badgeContent: badgeContentProp
    });
    const invisible = invisibleFromHook || badgeContent == null && variantProp !== "dot";
    const {
      color: color3 = colorProp,
      overlap = overlapProp,
      anchorOrigin: anchorOriginPropProp,
      variant = variantProp
    } = invisible ? prevProps : props;
    const anchorOrigin = getAnchorOrigin(anchorOriginPropProp);
    const displayValue = variant !== "dot" ? displayValueFromHook : void 0;
    const ownerState = __spreadProps(__spreadValues({}, props), {
      badgeContent,
      invisible,
      max: max2,
      displayValue,
      showZero,
      anchorOrigin,
      color: color3,
      overlap,
      variant
    });
    const classes = useUtilityClasses9(ownerState);
    const RootSlot = (_c = (_b = slots == null ? void 0 : slots.root) != null ? _b : components.Root) != null ? _c : BadgeRoot;
    const BadgeSlot = (_e = (_d = slots == null ? void 0 : slots.badge) != null ? _d : components.Badge) != null ? _e : BadgeBadge;
    const rootSlotProps = (_f = slotProps == null ? void 0 : slotProps.root) != null ? _f : componentsProps.root;
    const badgeSlotProps = (_g = slotProps == null ? void 0 : slotProps.badge) != null ? _g : componentsProps.badge;
    const rootProps = useSlotProps_default({
      elementType: RootSlot,
      externalSlotProps: rootSlotProps,
      externalForwardedProps: other,
      additionalProps: {
        ref,
        as: component
      },
      ownerState,
      className: clsx_default(rootSlotProps == null ? void 0 : rootSlotProps.className, classes.root, className)
    });
    const badgeProps = useSlotProps_default({
      elementType: BadgeSlot,
      externalSlotProps: badgeSlotProps,
      ownerState,
      className: clsx_default(classes.badge, badgeSlotProps == null ? void 0 : badgeSlotProps.className)
    });
    return /* @__PURE__ */ (0, import_jsx_runtime31.jsxs)(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
      children: [children, /* @__PURE__ */ (0, import_jsx_runtime31.jsx)(BadgeSlot, __spreadProps(__spreadValues({}, badgeProps), {
        children: displayValue
      }))]
    }));
  });
  false ? Badge.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The anchor of the badge.
     * @default {
     *   vertical: 'top',
     *   horizontal: 'right',
     * }
     */
    anchorOrigin: import_prop_types.default.shape({
      horizontal: import_prop_types.default.oneOf(["left", "right"]),
      vertical: import_prop_types.default.oneOf(["bottom", "top"])
    }),
    /**
     * The content rendered within the badge.
     */
    badgeContent: import_prop_types.default.node,
    /**
     * The badge will be added relative to this node.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
     * @default 'default'
     */
    color: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["default", "primary", "secondary", "error", "info", "success", "warning"]), import_prop_types.default.string]),
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * The components used for each slot inside.
     *
     * @deprecated use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
     *
     * @default {}
     */
    components: import_prop_types.default.shape({
      Badge: import_prop_types.default.elementType,
      Root: import_prop_types.default.elementType
    }),
    /**
     * The extra props for the slot components.
     * You can override the existing props or add new ones.
     *
     * @deprecated use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
     *
     * @default {}
     */
    componentsProps: import_prop_types.default.shape({
      badge: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
      root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
    }),
    /**
     * If `true`, the badge is invisible.
     * @default false
     */
    invisible: import_prop_types.default.bool,
    /**
     * Max count to show.
     * @default 99
     */
    max: import_prop_types.default.number,
    /**
     * Wrapped shape the badge should overlap.
     * @default 'rectangular'
     */
    overlap: import_prop_types.default.oneOf(["circular", "rectangular"]),
    /**
     * Controls whether the badge is hidden when `badgeContent` is zero.
     * @default false
     */
    showZero: import_prop_types.default.bool,
    /**
     * The props used for each slot inside the Badge.
     * @default {}
     */
    slotProps: import_prop_types.default.shape({
      badge: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
      root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
    }),
    /**
     * The components used for each slot inside the Badge.
     * Either a string to use a HTML element or a component.
     * @default {}
     */
    slots: import_prop_types.default.shape({
      badge: import_prop_types.default.elementType,
      root: import_prop_types.default.elementType
    }),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * The variant to use.
     * @default 'standard'
     */
    variant: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["dot", "standard"]), import_prop_types.default.string])
  } : void 0;
  var Badge_default = Badge;

  // node_modules/@mui/material/Box/boxClasses.js
  var boxClasses = generateUtilityClasses("MuiBox", ["root"]);
  var boxClasses_default = boxClasses;

  // node_modules/@mui/material/Box/Box.js
  var defaultTheme4 = createTheme2();
  var Box = createBox({
    themeId: identifier_default,
    defaultTheme: defaultTheme4,
    defaultClassName: boxClasses_default.root,
    generateClassName: ClassNameGenerator_default.generate
  });
  false ? Box.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * @ignore
     */
    children: import_prop_types.default.node,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var Box_default = Box;

  // node_modules/@mui/material/Button/Button.js
  var React57 = __toESM(require_react());

  // node_modules/@mui/material/Button/buttonClasses.js
  function getButtonUtilityClass(slot) {
    return generateUtilityClass("MuiButton", slot);
  }
  var buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"]);
  var buttonClasses_default = buttonClasses;

  // node_modules/@mui/material/ButtonGroup/ButtonGroupContext.js
  var React55 = __toESM(require_react());
  var ButtonGroupContext = /* @__PURE__ */ React55.createContext({});
  if (false) {
    ButtonGroupContext.displayName = "ButtonGroupContext";
  }
  var ButtonGroupContext_default = ButtonGroupContext;

  // node_modules/@mui/material/ButtonGroup/ButtonGroupButtonContext.js
  var React56 = __toESM(require_react());
  var ButtonGroupButtonContext = /* @__PURE__ */ React56.createContext(void 0);
  if (false) {
    ButtonGroupButtonContext.displayName = "ButtonGroupButtonContext";
  }
  var ButtonGroupButtonContext_default = ButtonGroupButtonContext;

  // node_modules/@mui/material/Button/Button.js
  var import_jsx_runtime32 = __toESM(require_jsx_runtime());
  var useUtilityClasses10 = (ownerState) => {
    const {
      color: color3,
      disableElevation,
      fullWidth,
      size,
      variant,
      loading,
      loadingPosition,
      classes
    } = ownerState;
    const slots = {
      root: ["root", loading && "loading", variant, `${variant}${capitalize_default(color3)}`, `size${capitalize_default(size)}`, `${variant}Size${capitalize_default(size)}`, `color${capitalize_default(color3)}`, disableElevation && "disableElevation", fullWidth && "fullWidth", loading && `loadingPosition${capitalize_default(loadingPosition)}`],
      startIcon: ["icon", "startIcon", `iconSize${capitalize_default(size)}`],
      endIcon: ["icon", "endIcon", `iconSize${capitalize_default(size)}`],
      loadingIndicator: ["loadingIndicator"],
      loadingWrapper: ["loadingWrapper"]
    };
    const composedClasses = composeClasses(slots, getButtonUtilityClass, classes);
    return __spreadValues(__spreadValues({}, classes), composedClasses);
  };
  var commonIconStyles = [{
    props: {
      size: "small"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 18
      }
    }
  }, {
    props: {
      size: "medium"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 20
      }
    }
  }, {
    props: {
      size: "large"
    },
    style: {
      "& > *:nth-of-type(1)": {
        fontSize: 22
      }
    }
  }];
  var ButtonRoot = styled_default2(ButtonBase_default, {
    shouldForwardProp: (prop) => rootShouldForwardProp_default(prop) || prop === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], styles2[`${ownerState.variant}${capitalize_default(ownerState.color)}`], styles2[`size${capitalize_default(ownerState.size)}`], styles2[`${ownerState.variant}Size${capitalize_default(ownerState.size)}`], ownerState.color === "inherit" && styles2.colorInherit, ownerState.disableElevation && styles2.disableElevation, ownerState.fullWidth && styles2.fullWidth, ownerState.loading && styles2.loading];
    }
  })(memoTheme_default(({
    theme
  }) => {
    const inheritContainedBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey[300] : theme.palette.grey[800];
    const inheritContainedHoverBackgroundColor = theme.palette.mode === "light" ? theme.palette.grey.A100 : theme.palette.grey[700];
    return __spreadProps(__spreadValues({}, theme.typography.button), {
      minWidth: 64,
      padding: "6px 16px",
      border: 0,
      borderRadius: (theme.vars || theme).shape.borderRadius,
      transition: theme.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
        duration: theme.transitions.duration.short
      }),
      "&:hover": {
        textDecoration: "none"
      },
      [`&.${buttonClasses_default.disabled}`]: {
        color: (theme.vars || theme).palette.action.disabled
      },
      variants: [{
        props: {
          variant: "contained"
        },
        style: {
          color: `var(--variant-containedColor)`,
          backgroundColor: `var(--variant-containedBg)`,
          boxShadow: (theme.vars || theme).shadows[2],
          "&:hover": {
            boxShadow: (theme.vars || theme).shadows[4],
            // Reset on touch devices, it doesn't add specificity
            "@media (hover: none)": {
              boxShadow: (theme.vars || theme).shadows[2]
            }
          },
          "&:active": {
            boxShadow: (theme.vars || theme).shadows[8]
          },
          [`&.${buttonClasses_default.focusVisible}`]: {
            boxShadow: (theme.vars || theme).shadows[6]
          },
          [`&.${buttonClasses_default.disabled}`]: {
            color: (theme.vars || theme).palette.action.disabled,
            boxShadow: (theme.vars || theme).shadows[0],
            backgroundColor: (theme.vars || theme).palette.action.disabledBackground
          }
        }
      }, {
        props: {
          variant: "outlined"
        },
        style: {
          padding: "5px 15px",
          border: "1px solid currentColor",
          borderColor: `var(--variant-outlinedBorder, currentColor)`,
          backgroundColor: `var(--variant-outlinedBg)`,
          color: `var(--variant-outlinedColor)`,
          [`&.${buttonClasses_default.disabled}`]: {
            border: `1px solid ${(theme.vars || theme).palette.action.disabledBackground}`
          }
        }
      }, {
        props: {
          variant: "text"
        },
        style: {
          padding: "6px 8px",
          color: `var(--variant-textColor)`,
          backgroundColor: `var(--variant-textBg)`
        }
      }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter()).map(([color3]) => ({
        props: {
          color: color3
        },
        style: {
          "--variant-textColor": (theme.vars || theme).palette[color3].main,
          "--variant-outlinedColor": (theme.vars || theme).palette[color3].main,
          "--variant-outlinedBorder": theme.vars ? `rgba(${theme.vars.palette[color3].mainChannel} / 0.5)` : alpha(theme.palette[color3].main, 0.5),
          "--variant-containedColor": (theme.vars || theme).palette[color3].contrastText,
          "--variant-containedBg": (theme.vars || theme).palette[color3].main,
          "@media (hover: hover)": {
            "&:hover": {
              "--variant-containedBg": (theme.vars || theme).palette[color3].dark,
              "--variant-textBg": theme.vars ? `rgba(${theme.vars.palette[color3].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color3].main, theme.palette.action.hoverOpacity),
              "--variant-outlinedBorder": (theme.vars || theme).palette[color3].main,
              "--variant-outlinedBg": theme.vars ? `rgba(${theme.vars.palette[color3].mainChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette[color3].main, theme.palette.action.hoverOpacity)
            }
          }
        }
      })), {
        props: {
          color: "inherit"
        },
        style: {
          color: "inherit",
          borderColor: "currentColor",
          "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedBg : inheritContainedBackgroundColor,
          "@media (hover: hover)": {
            "&:hover": {
              "--variant-containedBg": theme.vars ? theme.vars.palette.Button.inheritContainedHoverBg : inheritContainedHoverBackgroundColor,
              "--variant-textBg": theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity),
              "--variant-outlinedBg": theme.vars ? `rgba(${theme.vars.palette.text.primaryChannel} / ${theme.vars.palette.action.hoverOpacity})` : alpha(theme.palette.text.primary, theme.palette.action.hoverOpacity)
            }
          }
        }
      }, {
        props: {
          size: "small",
          variant: "text"
        },
        style: {
          padding: "4px 5px",
          fontSize: theme.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "text"
        },
        style: {
          padding: "8px 11px",
          fontSize: theme.typography.pxToRem(15)
        }
      }, {
        props: {
          size: "small",
          variant: "outlined"
        },
        style: {
          padding: "3px 9px",
          fontSize: theme.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "outlined"
        },
        style: {
          padding: "7px 21px",
          fontSize: theme.typography.pxToRem(15)
        }
      }, {
        props: {
          size: "small",
          variant: "contained"
        },
        style: {
          padding: "4px 10px",
          fontSize: theme.typography.pxToRem(13)
        }
      }, {
        props: {
          size: "large",
          variant: "contained"
        },
        style: {
          padding: "8px 22px",
          fontSize: theme.typography.pxToRem(15)
        }
      }, {
        props: {
          disableElevation: true
        },
        style: {
          boxShadow: "none",
          "&:hover": {
            boxShadow: "none"
          },
          [`&.${buttonClasses_default.focusVisible}`]: {
            boxShadow: "none"
          },
          "&:active": {
            boxShadow: "none"
          },
          [`&.${buttonClasses_default.disabled}`]: {
            boxShadow: "none"
          }
        }
      }, {
        props: {
          fullWidth: true
        },
        style: {
          width: "100%"
        }
      }, {
        props: {
          loadingPosition: "center"
        },
        style: {
          transition: theme.transitions.create(["background-color", "box-shadow", "border-color"], {
            duration: theme.transitions.duration.short
          }),
          [`&.${buttonClasses_default.loading}`]: {
            color: "transparent"
          }
        }
      }]
    });
  }));
  var ButtonStartIcon = styled_default2("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.startIcon, ownerState.loading && styles2.startIconLoadingStart, styles2[`iconSize${capitalize_default(ownerState.size)}`]];
    }
  })(({
    theme
  }) => ({
    display: "inherit",
    marginRight: 8,
    marginLeft: -4,
    variants: [{
      props: {
        size: "small"
      },
      style: {
        marginLeft: -2
      }
    }, {
      props: {
        loadingPosition: "start",
        loading: true
      },
      style: {
        transition: theme.transitions.create(["opacity"], {
          duration: theme.transitions.duration.short
        }),
        opacity: 0
      }
    }, {
      props: {
        loadingPosition: "start",
        loading: true,
        fullWidth: true
      },
      style: {
        marginRight: -8
      }
    }, ...commonIconStyles]
  }));
  var ButtonEndIcon = styled_default2("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.endIcon, ownerState.loading && styles2.endIconLoadingEnd, styles2[`iconSize${capitalize_default(ownerState.size)}`]];
    }
  })(({
    theme
  }) => ({
    display: "inherit",
    marginRight: -4,
    marginLeft: 8,
    variants: [{
      props: {
        size: "small"
      },
      style: {
        marginRight: -2
      }
    }, {
      props: {
        loadingPosition: "end",
        loading: true
      },
      style: {
        transition: theme.transitions.create(["opacity"], {
          duration: theme.transitions.duration.short
        }),
        opacity: 0
      }
    }, {
      props: {
        loadingPosition: "end",
        loading: true,
        fullWidth: true
      },
      style: {
        marginLeft: -8
      }
    }, ...commonIconStyles]
  }));
  var ButtonLoadingIndicator = styled_default2("span", {
    name: "MuiButton",
    slot: "LoadingIndicator",
    overridesResolver: (props, styles2) => styles2.loadingIndicator
  })(({
    theme
  }) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    variants: [{
      props: {
        loading: true
      },
      style: {
        display: "flex"
      }
    }, {
      props: {
        loadingPosition: "start"
      },
      style: {
        left: 14
      }
    }, {
      props: {
        loadingPosition: "start",
        size: "small"
      },
      style: {
        left: 10
      }
    }, {
      props: {
        variant: "text",
        loadingPosition: "start"
      },
      style: {
        left: 6
      }
    }, {
      props: {
        loadingPosition: "center"
      },
      style: {
        left: "50%",
        transform: "translate(-50%)",
        color: (theme.vars || theme).palette.action.disabled
      }
    }, {
      props: {
        loadingPosition: "end"
      },
      style: {
        right: 14
      }
    }, {
      props: {
        loadingPosition: "end",
        size: "small"
      },
      style: {
        right: 10
      }
    }, {
      props: {
        variant: "text",
        loadingPosition: "end"
      },
      style: {
        right: 6
      }
    }, {
      props: {
        loadingPosition: "start",
        fullWidth: true
      },
      style: {
        position: "relative",
        left: -10
      }
    }, {
      props: {
        loadingPosition: "end",
        fullWidth: true
      },
      style: {
        position: "relative",
        right: -10
      }
    }]
  }));
  var ButtonLoadingIconPlaceholder = styled_default2("span", {
    name: "MuiButton",
    slot: "LoadingIconPlaceholder",
    overridesResolver: (props, styles2) => styles2.loadingIconPlaceholder
  })({
    display: "inline-block",
    width: "1em",
    height: "1em"
  });
  var Button = /* @__PURE__ */ React57.forwardRef(function Button2(inProps, ref) {
    const contextProps = React57.useContext(ButtonGroupContext_default);
    const buttonGroupButtonContextPositionClassName = React57.useContext(ButtonGroupButtonContext_default);
    const resolvedProps = resolveProps(contextProps, inProps);
    const props = useDefaultProps2({
      props: resolvedProps,
      name: "MuiButton"
    });
    const _a = props, {
      children,
      color: color3 = "primary",
      component = "button",
      className,
      disabled = false,
      disableElevation = false,
      disableFocusRipple = false,
      endIcon: endIconProp,
      focusVisibleClassName,
      fullWidth = false,
      id: idProp,
      loading = null,
      loadingIndicator: loadingIndicatorProp,
      loadingPosition = "center",
      size = "medium",
      startIcon: startIconProp,
      type,
      variant = "text"
    } = _a, other = __objRest(_a, [
      "children",
      "color",
      "component",
      "className",
      "disabled",
      "disableElevation",
      "disableFocusRipple",
      "endIcon",
      "focusVisibleClassName",
      "fullWidth",
      "id",
      "loading",
      "loadingIndicator",
      "loadingPosition",
      "size",
      "startIcon",
      "type",
      "variant"
    ]);
    const loadingId = useId_default(idProp);
    const loadingIndicator = loadingIndicatorProp != null ? loadingIndicatorProp : /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(CircularProgress_default, {
      "aria-labelledby": loadingId,
      color: "inherit",
      size: 16
    });
    const ownerState = __spreadProps(__spreadValues({}, props), {
      color: color3,
      component,
      disabled,
      disableElevation,
      disableFocusRipple,
      fullWidth,
      loading,
      loadingIndicator,
      loadingPosition,
      size,
      type,
      variant
    });
    const classes = useUtilityClasses10(ownerState);
    const startIcon = (startIconProp || loading && loadingPosition === "start") && /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(ButtonStartIcon, {
      className: classes.startIcon,
      ownerState,
      children: startIconProp || /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(ButtonLoadingIconPlaceholder, {
        className: classes.loadingIconPlaceholder,
        ownerState
      })
    });
    const endIcon = (endIconProp || loading && loadingPosition === "end") && /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(ButtonEndIcon, {
      className: classes.endIcon,
      ownerState,
      children: endIconProp || /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(ButtonLoadingIconPlaceholder, {
        className: classes.loadingIconPlaceholder,
        ownerState
      })
    });
    const positionClassName = buttonGroupButtonContextPositionClassName || "";
    const loader = typeof loading === "boolean" ? (
      // use plain HTML span to minimize the runtime overhead
      /* @__PURE__ */ (0, import_jsx_runtime32.jsx)("span", {
        className: classes.loadingWrapper,
        style: {
          display: "contents"
        },
        children: loading && /* @__PURE__ */ (0, import_jsx_runtime32.jsx)(ButtonLoadingIndicator, {
          className: classes.loadingIndicator,
          ownerState,
          children: loadingIndicator
        })
      })
    ) : null;
    return /* @__PURE__ */ (0, import_jsx_runtime32.jsxs)(ButtonRoot, __spreadProps(__spreadValues({
      ownerState,
      className: clsx_default(contextProps.className, classes.root, className, positionClassName),
      component,
      disabled: disabled || loading,
      focusRipple: !disableFocusRipple,
      focusVisibleClassName: clsx_default(classes.focusVisible, focusVisibleClassName),
      ref,
      type,
      id: loading ? loadingId : idProp
    }, other), {
      classes,
      children: [startIcon, loadingPosition !== "end" && loader, children, loadingPosition === "end" && loader, endIcon]
    }));
  });
  false ? Button.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the component.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The color of the component.
     * It supports both default and custom theme colors, which can be added as shown in the
     * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).
     * @default 'primary'
     */
    color: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["inherit", "primary", "secondary", "success", "error", "info", "warning"]), import_prop_types.default.string]),
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * If `true`, the component is disabled.
     * @default false
     */
    disabled: import_prop_types.default.bool,
    /**
     * If `true`, no elevation is used.
     * @default false
     */
    disableElevation: import_prop_types.default.bool,
    /**
     * If `true`, the  keyboard focus ripple is disabled.
     * @default false
     */
    disableFocusRipple: import_prop_types.default.bool,
    /**
     * If `true`, the ripple effect is disabled.
     *
     * ⚠️ Without a ripple there is no styling for :focus-visible by default. Be sure
     * to highlight the element by applying separate styles with the `.Mui-focusVisible` class.
     * @default false
     */
    disableRipple: import_prop_types.default.bool,
    /**
     * Element placed after the children.
     */
    endIcon: import_prop_types.default.node,
    /**
     * @ignore
     */
    focusVisibleClassName: import_prop_types.default.string,
    /**
     * If `true`, the button will take up the full width of its container.
     * @default false
     */
    fullWidth: import_prop_types.default.bool,
    /**
     * The URL to link to when the button is clicked.
     * If defined, an `a` element will be used as the root node.
     */
    href: import_prop_types.default.string,
    /**
     * @ignore
     */
    id: import_prop_types.default.string,
    /**
     * If `true`, the loading indicator is visible and the button is disabled.
     * If `true | false`, the loading wrapper is always rendered before the children to prevent [Google Translation Crash](https://github.com/mui/material-ui/issues/27853).
     * @default null
     */
    loading: import_prop_types.default.bool,
    /**
     * Element placed before the children if the button is in loading state.
     * The node should contain an element with `role="progressbar"` with an accessible name.
     * By default, it renders a `CircularProgress` that is labeled by the button itself.
     * @default <CircularProgress color="inherit" size={16} />
     */
    loadingIndicator: import_prop_types.default.node,
    /**
     * The loading indicator can be positioned on the start, end, or the center of the button.
     * @default 'center'
     */
    loadingPosition: import_prop_types.default.oneOf(["center", "end", "start"]),
    /**
     * The size of the component.
     * `small` is equivalent to the dense button styling.
     * @default 'medium'
     */
    size: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["small", "medium", "large"]), import_prop_types.default.string]),
    /**
     * Element placed before the children.
     */
    startIcon: import_prop_types.default.node,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * @ignore
     */
    type: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["button", "reset", "submit"]), import_prop_types.default.string]),
    /**
     * The variant to use.
     * @default 'text'
     */
    variant: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["contained", "outlined", "text"]), import_prop_types.default.string])
  } : void 0;
  var Button_default = Button;

  // node_modules/@mui/material/Dialog/Dialog.js
  var React62 = __toESM(require_react());

  // node_modules/@mui/material/Modal/ModalManager.js
  function isOverflowing(container2) {
    const doc = ownerDocument(container2);
    if (doc.body === container2) {
      return ownerWindow(container2).innerWidth > doc.documentElement.clientWidth;
    }
    return container2.scrollHeight > container2.clientHeight;
  }
  function ariaHidden(element, hide2) {
    if (hide2) {
      element.setAttribute("aria-hidden", "true");
    } else {
      element.removeAttribute("aria-hidden");
    }
  }
  function getPaddingRight(element) {
    return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
  }
  function isAriaHiddenForbiddenOnElement(element) {
    const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
    const isForbiddenTagName = forbiddenTagNames.includes(element.tagName);
    const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
    return isForbiddenTagName || isInputHidden;
  }
  function ariaHiddenSiblings(container2, mountElement, currentElement, elementsToExclude, hide2) {
    const blacklist = [mountElement, currentElement, ...elementsToExclude];
    [].forEach.call(container2.children, (element) => {
      const isNotExcludedElement = !blacklist.includes(element);
      const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
      if (isNotExcludedElement && isNotForbiddenElement) {
        ariaHidden(element, hide2);
      }
    });
  }
  function findIndexOf(items, callback) {
    let idx = -1;
    items.some((item, index) => {
      if (callback(item)) {
        idx = index;
        return true;
      }
      return false;
    });
    return idx;
  }
  function handleContainer(containerInfo, props) {
    const restoreStyle = [];
    const container2 = containerInfo.container;
    if (!props.disableScrollLock) {
      if (isOverflowing(container2)) {
        const scrollbarSize = getScrollbarSize(ownerWindow(container2));
        restoreStyle.push({
          value: container2.style.paddingRight,
          property: "padding-right",
          el: container2
        });
        container2.style.paddingRight = `${getPaddingRight(container2) + scrollbarSize}px`;
        const fixedElements2 = ownerDocument(container2).querySelectorAll(".mui-fixed");
        [].forEach.call(fixedElements2, (element) => {
          restoreStyle.push({
            value: element.style.paddingRight,
            property: "padding-right",
            el: element
          });
          element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
        });
      }
      let scrollContainer;
      if (container2.parentNode instanceof DocumentFragment) {
        scrollContainer = ownerDocument(container2).body;
      } else {
        const parent = container2.parentElement;
        const containerWindow = ownerWindow(container2);
        scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container2;
      }
      restoreStyle.push({
        value: scrollContainer.style.overflow,
        property: "overflow",
        el: scrollContainer
      }, {
        value: scrollContainer.style.overflowX,
        property: "overflow-x",
        el: scrollContainer
      }, {
        value: scrollContainer.style.overflowY,
        property: "overflow-y",
        el: scrollContainer
      });
      scrollContainer.style.overflow = "hidden";
    }
    const restore = () => {
      restoreStyle.forEach(({
        value,
        el,
        property
      }) => {
        if (value) {
          el.style.setProperty(property, value);
        } else {
          el.style.removeProperty(property);
        }
      });
    };
    return restore;
  }
  function getHiddenSiblings(container2) {
    const hiddenSiblings = [];
    [].forEach.call(container2.children, (element) => {
      if (element.getAttribute("aria-hidden") === "true") {
        hiddenSiblings.push(element);
      }
    });
    return hiddenSiblings;
  }
  var ModalManager = class {
    constructor() {
      this.modals = [];
      this.containers = [];
    }
    add(modal, container2) {
      let modalIndex = this.modals.indexOf(modal);
      if (modalIndex !== -1) {
        return modalIndex;
      }
      modalIndex = this.modals.length;
      this.modals.push(modal);
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, false);
      }
      const hiddenSiblings = getHiddenSiblings(container2);
      ariaHiddenSiblings(container2, modal.mount, modal.modalRef, hiddenSiblings, true);
      const containerIndex = findIndexOf(this.containers, (item) => item.container === container2);
      if (containerIndex !== -1) {
        this.containers[containerIndex].modals.push(modal);
        return modalIndex;
      }
      this.containers.push({
        modals: [modal],
        container: container2,
        restore: null,
        hiddenSiblings
      });
      return modalIndex;
    }
    mount(modal, props) {
      const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal));
      const containerInfo = this.containers[containerIndex];
      if (!containerInfo.restore) {
        containerInfo.restore = handleContainer(containerInfo, props);
      }
    }
    remove(modal, ariaHiddenState = true) {
      const modalIndex = this.modals.indexOf(modal);
      if (modalIndex === -1) {
        return modalIndex;
      }
      const containerIndex = findIndexOf(this.containers, (item) => item.modals.includes(modal));
      const containerInfo = this.containers[containerIndex];
      containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
      this.modals.splice(modalIndex, 1);
      if (containerInfo.modals.length === 0) {
        if (containerInfo.restore) {
          containerInfo.restore();
        }
        if (modal.modalRef) {
          ariaHidden(modal.modalRef, ariaHiddenState);
        }
        ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
        this.containers.splice(containerIndex, 1);
      } else {
        const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
        if (nextTop.modalRef) {
          ariaHidden(nextTop.modalRef, false);
        }
      }
      return modalIndex;
    }
    isTopModal(modal) {
      return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
    }
  };

  // node_modules/@mui/material/Modal/Modal.js
  var React60 = __toESM(require_react());

  // node_modules/@mui/material/Unstable_TrapFocus/FocusTrap.js
  var React58 = __toESM(require_react());
  var import_jsx_runtime33 = __toESM(require_jsx_runtime());
  var candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
  function getTabIndex(node2) {
    const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
    if (!Number.isNaN(tabindexAttr)) {
      return tabindexAttr;
    }
    if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
      return 0;
    }
    return node2.tabIndex;
  }
  function isNonTabbableRadio(node2) {
    if (node2.tagName !== "INPUT" || node2.type !== "radio") {
      return false;
    }
    if (!node2.name) {
      return false;
    }
    const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
    let roving = getRadio(`[name="${node2.name}"]:checked`);
    if (!roving) {
      roving = getRadio(`[name="${node2.name}"]`);
    }
    return roving !== node2;
  }
  function isNodeMatchingSelectorFocusable(node2) {
    if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
      return false;
    }
    return true;
  }
  function defaultGetTabbable(root2) {
    const regularTabNodes = [];
    const orderedTabNodes = [];
    Array.from(root2.querySelectorAll(candidatesSelector)).forEach((node2, i) => {
      const nodeTabIndex = getTabIndex(node2);
      if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
        return;
      }
      if (nodeTabIndex === 0) {
        regularTabNodes.push(node2);
      } else {
        orderedTabNodes.push({
          documentOrder: i,
          tabIndex: nodeTabIndex,
          node: node2
        });
      }
    });
    return orderedTabNodes.sort((a, b) => a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex).map((a) => a.node).concat(regularTabNodes);
  }
  function defaultIsEnabled() {
    return true;
  }
  function FocusTrap(props) {
    const {
      children,
      disableAutoFocus = false,
      disableEnforceFocus = false,
      disableRestoreFocus = false,
      getTabbable = defaultGetTabbable,
      isEnabled = defaultIsEnabled,
      open
    } = props;
    const ignoreNextEnforceFocus = React58.useRef(false);
    const sentinelStart = React58.useRef(null);
    const sentinelEnd = React58.useRef(null);
    const nodeToRestore = React58.useRef(null);
    const reactFocusEventTarget = React58.useRef(null);
    const activated = React58.useRef(false);
    const rootRef = React58.useRef(null);
    const handleRef = useForkRef(getReactElementRef(children), rootRef);
    const lastKeydown = React58.useRef(null);
    React58.useEffect(() => {
      if (!open || !rootRef.current) {
        return;
      }
      activated.current = !disableAutoFocus;
    }, [disableAutoFocus, open]);
    React58.useEffect(() => {
      if (!open || !rootRef.current) {
        return;
      }
      const doc = ownerDocument(rootRef.current);
      if (!rootRef.current.contains(doc.activeElement)) {
        if (!rootRef.current.hasAttribute("tabIndex")) {
          if (false) {
            console.error(["MUI: The modal content node does not accept focus.", 'For the benefit of assistive technologies, the tabIndex of the node is being set to "-1".'].join("\n"));
          }
          rootRef.current.setAttribute("tabIndex", "-1");
        }
        if (activated.current) {
          rootRef.current.focus();
        }
      }
      return () => {
        if (!disableRestoreFocus) {
          if (nodeToRestore.current && nodeToRestore.current.focus) {
            ignoreNextEnforceFocus.current = true;
            nodeToRestore.current.focus();
          }
          nodeToRestore.current = null;
        }
      };
    }, [open]);
    React58.useEffect(() => {
      if (!open || !rootRef.current) {
        return;
      }
      const doc = ownerDocument(rootRef.current);
      const loopFocus = (nativeEvent) => {
        lastKeydown.current = nativeEvent;
        if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
          return;
        }
        if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
          ignoreNextEnforceFocus.current = true;
          if (sentinelEnd.current) {
            sentinelEnd.current.focus();
          }
        }
      };
      const contain = () => {
        var _a, _b;
        const rootElement = rootRef.current;
        if (rootElement === null) {
          return;
        }
        if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
          ignoreNextEnforceFocus.current = false;
          return;
        }
        if (rootElement.contains(doc.activeElement)) {
          return;
        }
        if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
          return;
        }
        if (doc.activeElement !== reactFocusEventTarget.current) {
          reactFocusEventTarget.current = null;
        } else if (reactFocusEventTarget.current !== null) {
          return;
        }
        if (!activated.current) {
          return;
        }
        let tabbable = [];
        if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
          tabbable = getTabbable(rootRef.current);
        }
        if (tabbable.length > 0) {
          const isShiftTab = Boolean(((_a = lastKeydown.current) == null ? void 0 : _a.shiftKey) && ((_b = lastKeydown.current) == null ? void 0 : _b.key) === "Tab");
          const focusNext = tabbable[0];
          const focusPrevious = tabbable[tabbable.length - 1];
          if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
            if (isShiftTab) {
              focusPrevious.focus();
            } else {
              focusNext.focus();
            }
          }
        } else {
          rootElement.focus();
        }
      };
      doc.addEventListener("focusin", contain);
      doc.addEventListener("keydown", loopFocus, true);
      const interval = setInterval(() => {
        if (doc.activeElement && doc.activeElement.tagName === "BODY") {
          contain();
        }
      }, 50);
      return () => {
        clearInterval(interval);
        doc.removeEventListener("focusin", contain);
        doc.removeEventListener("keydown", loopFocus, true);
      };
    }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
    const onFocus = (event) => {
      if (nodeToRestore.current === null) {
        nodeToRestore.current = event.relatedTarget;
      }
      activated.current = true;
      reactFocusEventTarget.current = event.target;
      const childrenPropsHandler = children.props.onFocus;
      if (childrenPropsHandler) {
        childrenPropsHandler(event);
      }
    };
    const handleFocusSentinel = (event) => {
      if (nodeToRestore.current === null) {
        nodeToRestore.current = event.relatedTarget;
      }
      activated.current = true;
    };
    return /* @__PURE__ */ (0, import_jsx_runtime33.jsxs)(React58.Fragment, {
      children: [/* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", {
        tabIndex: open ? 0 : -1,
        onFocus: handleFocusSentinel,
        ref: sentinelStart,
        "data-testid": "sentinelStart"
      }), /* @__PURE__ */ React58.cloneElement(children, {
        ref: handleRef,
        onFocus
      }), /* @__PURE__ */ (0, import_jsx_runtime33.jsx)("div", {
        tabIndex: open ? 0 : -1,
        onFocus: handleFocusSentinel,
        ref: sentinelEnd,
        "data-testid": "sentinelEnd"
      })]
    });
  }
  false ? FocusTrap.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * A single child content element.
     */
    children: elementAcceptingRef_default,
    /**
     * If `true`, the focus trap will not automatically shift focus to itself when it opens, and
     * replace it to the last focused element when it closes.
     * This also works correctly with any focus trap children that have the `disableAutoFocus` prop.
     *
     * Generally this should never be set to `true` as it makes the focus trap less
     * accessible to assistive technologies, like screen readers.
     * @default false
     */
    disableAutoFocus: import_prop_types.default.bool,
    /**
     * If `true`, the focus trap will not prevent focus from leaving the focus trap while open.
     *
     * Generally this should never be set to `true` as it makes the focus trap less
     * accessible to assistive technologies, like screen readers.
     * @default false
     */
    disableEnforceFocus: import_prop_types.default.bool,
    /**
     * If `true`, the focus trap will not restore focus to previously focused element once
     * focus trap is hidden or unmounted.
     * @default false
     */
    disableRestoreFocus: import_prop_types.default.bool,
    /**
     * Returns an array of ordered tabbable nodes (i.e. in tab order) within the root.
     * For instance, you can provide the "tabbable" npm dependency.
     * @param {HTMLElement} root
     */
    getTabbable: import_prop_types.default.func,
    /**
     * This prop extends the `open` prop.
     * It allows to toggle the open state without having to wait for a rerender when changing the `open` prop.
     * This prop should be memoized.
     * It can be used to support multiple focus trap mounted at the same time.
     * @default function defaultIsEnabled(): boolean {
     *   return true;
     * }
     */
    isEnabled: import_prop_types.default.func,
    /**
     * If `true`, focus is locked.
     */
    open: import_prop_types.default.bool.isRequired
  } : void 0;
  if (false) {
    FocusTrap["propTypes"] = exactProp(FocusTrap.propTypes);
  }
  var FocusTrap_default = FocusTrap;

  // node_modules/@mui/material/Modal/useModal.js
  var React59 = __toESM(require_react());
  function getContainer2(container2) {
    return typeof container2 === "function" ? container2() : container2;
  }
  function getHasTransition(children) {
    return children ? children.props.hasOwnProperty("in") : false;
  }
  var noop4 = () => {
  };
  var manager = new ModalManager();
  function useModal(parameters) {
    const {
      container: container2,
      disableEscapeKeyDown = false,
      disableScrollLock = false,
      closeAfterTransition = false,
      onTransitionEnter,
      onTransitionExited,
      children,
      onClose,
      open,
      rootRef
    } = parameters;
    const modal = React59.useRef({});
    const mountNodeRef = React59.useRef(null);
    const modalRef = React59.useRef(null);
    const handleRef = useForkRef(modalRef, rootRef);
    const [exited, setExited] = React59.useState(!open);
    const hasTransition = getHasTransition(children);
    let ariaHiddenProp = true;
    if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
      ariaHiddenProp = false;
    }
    const getDoc = () => ownerDocument(mountNodeRef.current);
    const getModal = () => {
      modal.current.modalRef = modalRef.current;
      modal.current.mount = mountNodeRef.current;
      return modal.current;
    };
    const handleMounted = () => {
      manager.mount(getModal(), {
        disableScrollLock
      });
      if (modalRef.current) {
        modalRef.current.scrollTop = 0;
      }
    };
    const handleOpen = useEventCallback_default(() => {
      const resolvedContainer = getContainer2(container2) || getDoc().body;
      manager.add(getModal(), resolvedContainer);
      if (modalRef.current) {
        handleMounted();
      }
    });
    const isTopModal = () => manager.isTopModal(getModal());
    const handlePortalRef = useEventCallback_default((node2) => {
      mountNodeRef.current = node2;
      if (!node2) {
        return;
      }
      if (open && isTopModal()) {
        handleMounted();
      } else if (modalRef.current) {
        ariaHidden(modalRef.current, ariaHiddenProp);
      }
    });
    const handleClose = React59.useCallback(() => {
      manager.remove(getModal(), ariaHiddenProp);
    }, [ariaHiddenProp]);
    React59.useEffect(() => {
      return () => {
        handleClose();
      };
    }, [handleClose]);
    React59.useEffect(() => {
      if (open) {
        handleOpen();
      } else if (!hasTransition || !closeAfterTransition) {
        handleClose();
      }
    }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
    const createHandleKeyDown = (otherHandlers) => (event) => {
      var _a;
      (_a = otherHandlers.onKeyDown) == null ? void 0 : _a.call(otherHandlers, event);
      if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
      !isTopModal()) {
        return;
      }
      if (!disableEscapeKeyDown) {
        event.stopPropagation();
        if (onClose) {
          onClose(event, "escapeKeyDown");
        }
      }
    };
    const createHandleBackdropClick = (otherHandlers) => (event) => {
      var _a;
      (_a = otherHandlers.onClick) == null ? void 0 : _a.call(otherHandlers, event);
      if (event.target !== event.currentTarget) {
        return;
      }
      if (onClose) {
        onClose(event, "backdropClick");
      }
    };
    const getRootProps = (otherHandlers = {}) => {
      const propsEventHandlers = extractEventHandlers_default(parameters);
      delete propsEventHandlers.onTransitionEnter;
      delete propsEventHandlers.onTransitionExited;
      const externalEventHandlers = __spreadValues(__spreadValues({}, propsEventHandlers), otherHandlers);
      return __spreadProps(__spreadValues({
        /*
         * Marking an element with the role presentation indicates to assistive technology
         * that this element should be ignored; it exists to support the web application and
         * is not meant for humans to interact with directly.
         * https://github.com/evcohen/eslint-plugin-jsx-a11y/blob/master/docs/rules/no-static-element-interactions.md
         */
        role: "presentation"
      }, externalEventHandlers), {
        onKeyDown: createHandleKeyDown(externalEventHandlers),
        ref: handleRef
      });
    };
    const getBackdropProps = (otherHandlers = {}) => {
      const externalEventHandlers = otherHandlers;
      return __spreadProps(__spreadValues({
        "aria-hidden": true
      }, externalEventHandlers), {
        onClick: createHandleBackdropClick(externalEventHandlers),
        open
      });
    };
    const getTransitionProps2 = () => {
      var _a, _b;
      const handleEnter = () => {
        setExited(false);
        if (onTransitionEnter) {
          onTransitionEnter();
        }
      };
      const handleExited = () => {
        setExited(true);
        if (onTransitionExited) {
          onTransitionExited();
        }
        if (closeAfterTransition) {
          handleClose();
        }
      };
      return {
        onEnter: createChainedFunction(handleEnter, (_a = children == null ? void 0 : children.props.onEnter) != null ? _a : noop4),
        onExited: createChainedFunction(handleExited, (_b = children == null ? void 0 : children.props.onExited) != null ? _b : noop4)
      };
    };
    return {
      getRootProps,
      getBackdropProps,
      getTransitionProps: getTransitionProps2,
      rootRef: handleRef,
      portalRef: handlePortalRef,
      isTopModal,
      exited,
      hasTransition
    };
  }
  var useModal_default = useModal;

  // node_modules/@mui/material/Modal/modalClasses.js
  function getModalUtilityClass(slot) {
    return generateUtilityClass("MuiModal", slot);
  }
  var modalClasses = generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);

  // node_modules/@mui/material/Modal/Modal.js
  var import_jsx_runtime34 = __toESM(require_jsx_runtime());
  var useUtilityClasses11 = (ownerState) => {
    const {
      open,
      exited,
      classes
    } = ownerState;
    const slots = {
      root: ["root", !open && exited && "hidden"],
      backdrop: ["backdrop"]
    };
    return composeClasses(slots, getModalUtilityClass, classes);
  };
  var ModalRoot = styled_default2("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    position: "fixed",
    zIndex: (theme.vars || theme).zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    variants: [{
      props: ({
        ownerState
      }) => !ownerState.open && ownerState.exited,
      style: {
        visibility: "hidden"
      }
    }]
  })));
  var ModalBackdrop = styled_default2(Backdrop_default, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (props, styles2) => {
      return styles2.backdrop;
    }
  })({
    zIndex: -1
  });
  var Modal = /* @__PURE__ */ React60.forwardRef(function Modal2(inProps, ref) {
    const props = useDefaultProps2({
      name: "MuiModal",
      props: inProps
    });
    const _a = props, {
      BackdropComponent = ModalBackdrop,
      BackdropProps,
      classes: classesProp,
      className,
      closeAfterTransition = false,
      children,
      container: container2,
      component,
      components = {},
      componentsProps = {},
      disableAutoFocus = false,
      disableEnforceFocus = false,
      disableEscapeKeyDown = false,
      disablePortal = false,
      disableRestoreFocus = false,
      disableScrollLock = false,
      hideBackdrop = false,
      keepMounted = false,
      onBackdropClick,
      onClose,
      onTransitionEnter,
      onTransitionExited,
      open,
      slotProps = {},
      slots = {},
      theme: theme
    } = _a, other = __objRest(_a, [
      "BackdropComponent",
      "BackdropProps",
      "classes",
      "className",
      "closeAfterTransition",
      "children",
      "container",
      "component",
      "components",
      "componentsProps",
      "disableAutoFocus",
      "disableEnforceFocus",
      "disableEscapeKeyDown",
      "disablePortal",
      "disableRestoreFocus",
      "disableScrollLock",
      "hideBackdrop",
      "keepMounted",
      "onBackdropClick",
      "onClose",
      "onTransitionEnter",
      "onTransitionExited",
      "open",
      "slotProps",
      "slots",
      // eslint-disable-next-line react/prop-types
      "theme"
    ]);
    const propsWithDefaults = __spreadProps(__spreadValues({}, props), {
      closeAfterTransition,
      disableAutoFocus,
      disableEnforceFocus,
      disableEscapeKeyDown,
      disablePortal,
      disableRestoreFocus,
      disableScrollLock,
      hideBackdrop,
      keepMounted
    });
    const {
      getRootProps,
      getBackdropProps,
      getTransitionProps: getTransitionProps2,
      portalRef,
      isTopModal,
      exited,
      hasTransition
    } = useModal_default(__spreadProps(__spreadValues({}, propsWithDefaults), {
      rootRef: ref
    }));
    const ownerState = __spreadProps(__spreadValues({}, propsWithDefaults), {
      exited
    });
    const classes = useUtilityClasses11(ownerState);
    const childProps = {};
    if (children.props.tabIndex === void 0) {
      childProps.tabIndex = "-1";
    }
    if (hasTransition) {
      const {
        onEnter,
        onExited
      } = getTransitionProps2();
      childProps.onEnter = onEnter;
      childProps.onExited = onExited;
    }
    const externalForwardedProps = {
      slots: __spreadValues({
        root: components.Root,
        backdrop: components.Backdrop
      }, slots),
      slotProps: __spreadValues(__spreadValues({}, componentsProps), slotProps)
    };
    const [RootSlot, rootProps] = useSlot("root", {
      ref,
      elementType: ModalRoot,
      externalForwardedProps: __spreadProps(__spreadValues(__spreadValues({}, externalForwardedProps), other), {
        component
      }),
      getSlotProps: getRootProps,
      ownerState,
      className: clsx_default(className, classes == null ? void 0 : classes.root, !ownerState.open && ownerState.exited && (classes == null ? void 0 : classes.hidden))
    });
    const [BackdropSlot, backdropProps] = useSlot("backdrop", {
      ref: BackdropProps == null ? void 0 : BackdropProps.ref,
      elementType: BackdropComponent,
      externalForwardedProps,
      shouldForwardComponentProp: true,
      additionalProps: BackdropProps,
      getSlotProps: (otherHandlers) => {
        return getBackdropProps(__spreadProps(__spreadValues({}, otherHandlers), {
          onClick: (event) => {
            if (onBackdropClick) {
              onBackdropClick(event);
            }
            if (otherHandlers == null ? void 0 : otherHandlers.onClick) {
              otherHandlers.onClick(event);
            }
          }
        }));
      },
      className: clsx_default(BackdropProps == null ? void 0 : BackdropProps.className, classes == null ? void 0 : classes.backdrop),
      ownerState
    });
    if (!keepMounted && !open && (!hasTransition || exited)) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(Portal_default, {
      ref: portalRef,
      container: container2,
      disablePortal,
      children: /* @__PURE__ */ (0, import_jsx_runtime34.jsxs)(RootSlot, __spreadProps(__spreadValues({}, rootProps), {
        children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(BackdropSlot, __spreadValues({}, backdropProps)) : null, /* @__PURE__ */ (0, import_jsx_runtime34.jsx)(FocusTrap_default, {
          disableEnforceFocus,
          disableAutoFocus,
          disableRestoreFocus,
          isEnabled: isTopModal,
          open,
          children: /* @__PURE__ */ React60.cloneElement(children, childProps)
        })]
      }))
    });
  });
  false ? Modal.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * A backdrop component. This prop enables custom backdrop rendering.
     * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
     * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
     * @default styled(Backdrop, {
     *   name: 'MuiModal',
     *   slot: 'Backdrop',
     *   overridesResolver: (props, styles) => {
     *     return styles.backdrop;
     *   },
     * })({
     *   zIndex: -1,
     * })
     */
    BackdropComponent: import_prop_types.default.elementType,
    /**
     * Props applied to the [`Backdrop`](https://mui.com/material-ui/api/backdrop/) element.
     * @deprecated Use `slotProps.backdrop` instead.
     */
    BackdropProps: import_prop_types.default.object,
    /**
     * A single child content element.
     */
    children: elementAcceptingRef_default.isRequired,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * When set to true the Modal waits until a nested Transition is completed before closing.
     * @default false
     */
    closeAfterTransition: import_prop_types.default.bool,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * The components used for each slot inside.
     *
     * @deprecated Use the `slots` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
     *
     * @default {}
     */
    components: import_prop_types.default.shape({
      Backdrop: import_prop_types.default.elementType,
      Root: import_prop_types.default.elementType
    }),
    /**
     * The extra props for the slot components.
     * You can override the existing props or add new ones.
     *
     * @deprecated Use the `slotProps` prop instead. This prop will be removed in v7. See [Migrating from deprecated APIs](https://mui.com/material-ui/migration/migrating-from-deprecated-apis/) for more details.
     *
     * @default {}
     */
    componentsProps: import_prop_types.default.shape({
      backdrop: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
      root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
    }),
    /**
     * An HTML element or function that returns one.
     * The `container` will have the portal children appended to it.
     *
     * You can also provide a callback, which is called in a React layout effect.
     * This lets you set the container from a ref, and also makes server-side rendering possible.
     *
     * By default, it uses the body of the top-level document object,
     * so it's simply `document.body` most of the time.
     */
    container: import_prop_types.default.oneOfType([HTMLElementType, import_prop_types.default.func]),
    /**
     * If `true`, the modal will not automatically shift focus to itself when it opens, and
     * replace it to the last focused element when it closes.
     * This also works correctly with any modal children that have the `disableAutoFocus` prop.
     *
     * Generally this should never be set to `true` as it makes the modal less
     * accessible to assistive technologies, like screen readers.
     * @default false
     */
    disableAutoFocus: import_prop_types.default.bool,
    /**
     * If `true`, the modal will not prevent focus from leaving the modal while open.
     *
     * Generally this should never be set to `true` as it makes the modal less
     * accessible to assistive technologies, like screen readers.
     * @default false
     */
    disableEnforceFocus: import_prop_types.default.bool,
    /**
     * If `true`, hitting escape will not fire the `onClose` callback.
     * @default false
     */
    disableEscapeKeyDown: import_prop_types.default.bool,
    /**
     * The `children` will be under the DOM hierarchy of the parent component.
     * @default false
     */
    disablePortal: import_prop_types.default.bool,
    /**
     * If `true`, the modal will not restore focus to previously focused element once
     * modal is hidden or unmounted.
     * @default false
     */
    disableRestoreFocus: import_prop_types.default.bool,
    /**
     * Disable the scroll lock behavior.
     * @default false
     */
    disableScrollLock: import_prop_types.default.bool,
    /**
     * If `true`, the backdrop is not rendered.
     * @default false
     */
    hideBackdrop: import_prop_types.default.bool,
    /**
     * Always keep the children in the DOM.
     * This prop can be useful in SEO situation or
     * when you want to maximize the responsiveness of the Modal.
     * @default false
     */
    keepMounted: import_prop_types.default.bool,
    /**
     * Callback fired when the backdrop is clicked.
     * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
     */
    onBackdropClick: import_prop_types.default.func,
    /**
     * Callback fired when the component requests to be closed.
     * The `reason` parameter can optionally be used to control the response to `onClose`.
     *
     * @param {object} event The event source of the callback.
     * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
     */
    onClose: import_prop_types.default.func,
    /**
     * A function called when a transition enters.
     */
    onTransitionEnter: import_prop_types.default.func,
    /**
     * A function called when a transition has exited.
     */
    onTransitionExited: import_prop_types.default.func,
    /**
     * If `true`, the component is shown.
     */
    open: import_prop_types.default.bool.isRequired,
    /**
     * The props used for each slot inside the Modal.
     * @default {}
     */
    slotProps: import_prop_types.default.shape({
      backdrop: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
      root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
    }),
    /**
     * The components used for each slot inside the Modal.
     * Either a string to use a HTML element or a component.
     * @default {}
     */
    slots: import_prop_types.default.shape({
      backdrop: import_prop_types.default.elementType,
      root: import_prop_types.default.elementType
    }),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var Modal_default = Modal;

  // node_modules/@mui/material/Dialog/dialogClasses.js
  function getDialogUtilityClass(slot) {
    return generateUtilityClass("MuiDialog", slot);
  }
  var dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
  var dialogClasses_default = dialogClasses;

  // node_modules/@mui/material/Dialog/DialogContext.js
  var React61 = __toESM(require_react());
  var DialogContext = /* @__PURE__ */ React61.createContext({});
  if (false) {
    DialogContext.displayName = "DialogContext";
  }
  var DialogContext_default = DialogContext;

  // node_modules/@mui/material/Dialog/Dialog.js
  var import_jsx_runtime35 = __toESM(require_jsx_runtime());
  var DialogBackdrop = styled_default2(Backdrop_default, {
    name: "MuiDialog",
    slot: "Backdrop",
    overrides: (props, styles2) => styles2.backdrop
  })({
    // Improve scrollable dialog support.
    zIndex: -1
  });
  var useUtilityClasses12 = (ownerState) => {
    const {
      classes,
      scroll,
      maxWidth: maxWidth2,
      fullWidth,
      fullScreen
    } = ownerState;
    const slots = {
      root: ["root"],
      container: ["container", `scroll${capitalize_default(scroll)}`],
      paper: ["paper", `paperScroll${capitalize_default(scroll)}`, `paperWidth${capitalize_default(String(maxWidth2))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
    };
    return composeClasses(slots, getDialogUtilityClass, classes);
  };
  var DialogRoot = styled_default2(Modal_default, {
    name: "MuiDialog",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    "@media print": {
      // Use !important to override the Modal inline-style.
      position: "absolute !important"
    }
  });
  var DialogContainer = styled_default2("div", {
    name: "MuiDialog",
    slot: "Container",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.container, styles2[`scroll${capitalize_default(ownerState.scroll)}`]];
    }
  })({
    height: "100%",
    "@media print": {
      height: "auto"
    },
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    variants: [{
      props: {
        scroll: "paper"
      },
      style: {
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      }
    }, {
      props: {
        scroll: "body"
      },
      style: {
        overflowY: "auto",
        overflowX: "hidden",
        textAlign: "center",
        "&::after": {
          content: '""',
          display: "inline-block",
          verticalAlign: "middle",
          height: "100%",
          width: "0"
        }
      }
    }]
  });
  var DialogPaper = styled_default2(Paper_default, {
    name: "MuiDialog",
    slot: "Paper",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.paper, styles2[`scrollPaper${capitalize_default(ownerState.scroll)}`], styles2[`paperWidth${capitalize_default(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles2.paperFullWidth, ownerState.fullScreen && styles2.paperFullScreen];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    margin: 32,
    position: "relative",
    overflowY: "auto",
    "@media print": {
      overflowY: "visible",
      boxShadow: "none"
    },
    variants: [{
      props: {
        scroll: "paper"
      },
      style: {
        display: "flex",
        flexDirection: "column",
        maxHeight: "calc(100% - 64px)"
      }
    }, {
      props: {
        scroll: "body"
      },
      style: {
        display: "inline-block",
        verticalAlign: "middle",
        textAlign: "initial"
      }
    }, {
      props: ({
        ownerState
      }) => !ownerState.maxWidth,
      style: {
        maxWidth: "calc(100% - 64px)"
      }
    }, {
      props: {
        maxWidth: "xs"
      },
      style: {
        maxWidth: theme.breakpoints.unit === "px" ? Math.max(theme.breakpoints.values.xs, 444) : `max(${theme.breakpoints.values.xs}${theme.breakpoints.unit}, 444px)`,
        [`&.${dialogClasses_default.paperScrollBody}`]: {
          [theme.breakpoints.down(Math.max(theme.breakpoints.values.xs, 444) + 32 * 2)]: {
            maxWidth: "calc(100% - 64px)"
          }
        }
      }
    }, ...Object.keys(theme.breakpoints.values).filter((maxWidth2) => maxWidth2 !== "xs").map((maxWidth2) => ({
      props: {
        maxWidth: maxWidth2
      },
      style: {
        maxWidth: `${theme.breakpoints.values[maxWidth2]}${theme.breakpoints.unit}`,
        [`&.${dialogClasses_default.paperScrollBody}`]: {
          [theme.breakpoints.down(theme.breakpoints.values[maxWidth2] + 32 * 2)]: {
            maxWidth: "calc(100% - 64px)"
          }
        }
      }
    })), {
      props: ({
        ownerState
      }) => ownerState.fullWidth,
      style: {
        width: "calc(100% - 64px)"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.fullScreen,
      style: {
        margin: 0,
        width: "100%",
        maxWidth: "100%",
        height: "100%",
        maxHeight: "none",
        borderRadius: 0,
        [`&.${dialogClasses_default.paperScrollBody}`]: {
          margin: 0,
          maxWidth: "100%"
        }
      }
    }]
  })));
  var Dialog = /* @__PURE__ */ React62.forwardRef(function Dialog2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiDialog"
    });
    const theme = useTheme5();
    const defaultTransitionDuration = {
      enter: theme.transitions.duration.enteringScreen,
      exit: theme.transitions.duration.leavingScreen
    };
    const _a = props, {
      "aria-describedby": ariaDescribedby,
      "aria-labelledby": ariaLabelledbyProp,
      "aria-modal": ariaModal = true,
      BackdropComponent,
      BackdropProps,
      children,
      className,
      disableEscapeKeyDown = false,
      fullScreen = false,
      fullWidth = false,
      maxWidth: maxWidth2 = "sm",
      onBackdropClick,
      onClick,
      onClose,
      open,
      PaperComponent = Paper_default,
      PaperProps = {},
      scroll = "paper",
      slots = {},
      slotProps = {},
      TransitionComponent = Fade_default,
      transitionDuration = defaultTransitionDuration,
      TransitionProps
    } = _a, other = __objRest(_a, [
      "aria-describedby",
      "aria-labelledby",
      "aria-modal",
      "BackdropComponent",
      "BackdropProps",
      "children",
      "className",
      "disableEscapeKeyDown",
      "fullScreen",
      "fullWidth",
      "maxWidth",
      "onBackdropClick",
      "onClick",
      "onClose",
      "open",
      "PaperComponent",
      "PaperProps",
      "scroll",
      "slots",
      "slotProps",
      "TransitionComponent",
      "transitionDuration",
      "TransitionProps"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      disableEscapeKeyDown,
      fullScreen,
      fullWidth,
      maxWidth: maxWidth2,
      scroll
    });
    const classes = useUtilityClasses12(ownerState);
    const backdropClick = React62.useRef();
    const handleMouseDown = (event) => {
      backdropClick.current = event.target === event.currentTarget;
    };
    const handleBackdropClick = (event) => {
      if (onClick) {
        onClick(event);
      }
      if (!backdropClick.current) {
        return;
      }
      backdropClick.current = null;
      if (onBackdropClick) {
        onBackdropClick(event);
      }
      if (onClose) {
        onClose(event, "backdropClick");
      }
    };
    const ariaLabelledby = useId(ariaLabelledbyProp);
    const dialogContextValue = React62.useMemo(() => {
      return {
        titleId: ariaLabelledby
      };
    }, [ariaLabelledby]);
    const backwardCompatibleSlots = __spreadValues({
      transition: TransitionComponent
    }, slots);
    const backwardCompatibleSlotProps = __spreadValues({
      transition: TransitionProps,
      paper: PaperProps,
      backdrop: BackdropProps
    }, slotProps);
    const externalForwardedProps = {
      slots: backwardCompatibleSlots,
      slotProps: backwardCompatibleSlotProps
    };
    const [RootSlot, rootSlotProps] = useSlot("root", {
      elementType: DialogRoot,
      shouldForwardComponentProp: true,
      externalForwardedProps,
      ownerState,
      className: clsx_default(classes.root, className),
      ref
    });
    const [BackdropSlot, backdropSlotProps] = useSlot("backdrop", {
      elementType: DialogBackdrop,
      shouldForwardComponentProp: true,
      externalForwardedProps,
      ownerState
    });
    const [PaperSlot, paperSlotProps] = useSlot("paper", {
      elementType: DialogPaper,
      shouldForwardComponentProp: true,
      externalForwardedProps,
      ownerState,
      className: clsx_default(classes.paper, PaperProps.className)
    });
    const [ContainerSlot, containerSlotProps] = useSlot("container", {
      elementType: DialogContainer,
      externalForwardedProps,
      ownerState,
      className: clsx_default(classes.container)
    });
    const [TransitionSlot, transitionSlotProps] = useSlot("transition", {
      elementType: Fade_default,
      externalForwardedProps,
      ownerState,
      additionalProps: {
        appear: true,
        in: open,
        timeout: transitionDuration,
        role: "presentation"
      }
    });
    return /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(RootSlot, __spreadProps(__spreadValues(__spreadValues({
      closeAfterTransition: true,
      slots: {
        backdrop: BackdropSlot
      },
      slotProps: {
        backdrop: __spreadValues({
          transitionDuration,
          as: BackdropComponent
        }, backdropSlotProps)
      },
      disableEscapeKeyDown,
      onClose,
      open,
      onClick: handleBackdropClick
    }, rootSlotProps), other), {
      children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(TransitionSlot, __spreadProps(__spreadValues({}, transitionSlotProps), {
        children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(ContainerSlot, __spreadProps(__spreadValues({
          onMouseDown: handleMouseDown
        }, containerSlotProps), {
          children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(PaperSlot, __spreadProps(__spreadValues({
            as: PaperComponent,
            elevation: 24,
            role: "dialog",
            "aria-describedby": ariaDescribedby,
            "aria-labelledby": ariaLabelledby,
            "aria-modal": ariaModal
          }, paperSlotProps), {
            children: /* @__PURE__ */ (0, import_jsx_runtime35.jsx)(DialogContext_default.Provider, {
              value: dialogContextValue,
              children
            })
          }))
        }))
      }))
    }));
  });
  false ? Dialog.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The id(s) of the element(s) that describe the dialog.
     */
    "aria-describedby": import_prop_types.default.string,
    /**
     * The id(s) of the element(s) that label the dialog.
     */
    "aria-labelledby": import_prop_types.default.string,
    /**
     * Informs assistive technologies that the element is modal.
     * It's added on the element with role="dialog".
     * @default true
     */
    "aria-modal": import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["false", "true"]), import_prop_types.default.bool]),
    /**
     * A backdrop component. This prop enables custom backdrop rendering.
     * @deprecated Use `slots.backdrop` instead. While this prop currently works, it will be removed in the next major version.
     * Use the `slots.backdrop` prop to make your application ready for the next version of Material UI.
     * @default styled(Backdrop, {
     *   name: 'MuiModal',
     *   slot: 'Backdrop',
     *   overridesResolver: (props, styles) => {
     *     return styles.backdrop;
     *   },
     * })({
     *   zIndex: -1,
     * })
     */
    BackdropComponent: import_prop_types.default.elementType,
    /**
     * @ignore
     */
    BackdropProps: import_prop_types.default.object,
    /**
     * Dialog children, usually the included sub-components.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * If `true`, hitting escape will not fire the `onClose` callback.
     * @default false
     */
    disableEscapeKeyDown: import_prop_types.default.bool,
    /**
     * If `true`, the dialog is full-screen.
     * @default false
     */
    fullScreen: import_prop_types.default.bool,
    /**
     * If `true`, the dialog stretches to `maxWidth`.
     *
     * Notice that the dialog width grow is limited by the default margin.
     * @default false
     */
    fullWidth: import_prop_types.default.bool,
    /**
     * Determine the max-width of the dialog.
     * The dialog width grows with the size of the screen.
     * Set to `false` to disable `maxWidth`.
     * @default 'sm'
     */
    maxWidth: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["xs", "sm", "md", "lg", "xl", false]), import_prop_types.default.string]),
    /**
     * Callback fired when the backdrop is clicked.
     * @deprecated Use the `onClose` prop with the `reason` argument to handle the `backdropClick` events.
     */
    onBackdropClick: import_prop_types.default.func,
    /**
     * @ignore
     */
    onClick: import_prop_types.default.func,
    /**
     * Callback fired when the component requests to be closed.
     *
     * @param {object} event The event source of the callback.
     * @param {string} reason Can be: `"escapeKeyDown"`, `"backdropClick"`.
     */
    onClose: import_prop_types.default.func,
    /**
     * If `true`, the component is shown.
     */
    open: import_prop_types.default.bool.isRequired,
    /**
     * The component used to render the body of the dialog.
     * @default Paper
     */
    PaperComponent: import_prop_types.default.elementType,
    /**
     * Props applied to the [`Paper`](https://mui.com/material-ui/api/paper/) element.
     * @default {}
     * @deprecated Use `slotProps.paper` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
     */
    PaperProps: import_prop_types.default.object,
    /**
     * Determine the container for scrolling the dialog.
     * @default 'paper'
     */
    scroll: import_prop_types.default.oneOf(["body", "paper"]),
    /**
     * The props used for each slot inside.
     * @default {}
     */
    slotProps: import_prop_types.default.shape({
      backdrop: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
      container: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
      paper: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
      root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
      transition: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
    }),
    /**
     * The components used for each slot inside.
     * @default {}
     */
    slots: import_prop_types.default.shape({
      backdrop: import_prop_types.default.elementType,
      container: import_prop_types.default.elementType,
      paper: import_prop_types.default.elementType,
      root: import_prop_types.default.elementType,
      transition: import_prop_types.default.elementType
    }),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * The component used for the transition.
     * [Follow this guide](https://mui.com/material-ui/transitions/#transitioncomponent-prop) to learn more about the requirements for this component.
     * @default Fade
     * @deprecated Use `slots.transition` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
     */
    TransitionComponent: import_prop_types.default.elementType,
    /**
     * The duration for the transition, in milliseconds.
     * You may specify a single timeout for all transitions, or individually with an object.
     * @default {
     *   enter: theme.transitions.duration.enteringScreen,
     *   exit: theme.transitions.duration.leavingScreen,
     * }
     */
    transitionDuration: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.shape({
      appear: import_prop_types.default.number,
      enter: import_prop_types.default.number,
      exit: import_prop_types.default.number
    })]),
    /**
     * Props applied to the transition element.
     * By default, the element is based on this [`Transition`](https://reactcommunity.org/react-transition-group/transition/) component.
     * @deprecated Use `slotProps.transition` instead. This prop will be removed in v7. See [Migrating from deprecated APIs](/material-ui/migration/migrating-from-deprecated-apis/) for more details.
     */
    TransitionProps: import_prop_types.default.object
  } : void 0;
  var Dialog_default = Dialog;

  // node_modules/@mui/material/DialogActions/DialogActions.js
  var React63 = __toESM(require_react());

  // node_modules/@mui/material/DialogActions/dialogActionsClasses.js
  function getDialogActionsUtilityClass(slot) {
    return generateUtilityClass("MuiDialogActions", slot);
  }
  var dialogActionsClasses = generateUtilityClasses("MuiDialogActions", ["root", "spacing"]);

  // node_modules/@mui/material/DialogActions/DialogActions.js
  var import_jsx_runtime36 = __toESM(require_jsx_runtime());
  var useUtilityClasses13 = (ownerState) => {
    const {
      classes,
      disableSpacing
    } = ownerState;
    const slots = {
      root: ["root", !disableSpacing && "spacing"]
    };
    return composeClasses(slots, getDialogActionsUtilityClass, classes);
  };
  var DialogActionsRoot = styled_default2("div", {
    name: "MuiDialogActions",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, !ownerState.disableSpacing && styles2.spacing];
    }
  })({
    display: "flex",
    alignItems: "center",
    padding: 8,
    justifyContent: "flex-end",
    flex: "0 0 auto",
    variants: [{
      props: ({
        ownerState
      }) => !ownerState.disableSpacing,
      style: {
        "& > :not(style) ~ :not(style)": {
          marginLeft: 8
        }
      }
    }]
  });
  var DialogActions = /* @__PURE__ */ React63.forwardRef(function DialogActions2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiDialogActions"
    });
    const _a = props, {
      className,
      disableSpacing = false
    } = _a, other = __objRest(_a, [
      "className",
      "disableSpacing"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      disableSpacing
    });
    const classes = useUtilityClasses13(ownerState);
    return /* @__PURE__ */ (0, import_jsx_runtime36.jsx)(DialogActionsRoot, __spreadValues({
      className: clsx_default(classes.root, className),
      ownerState,
      ref
    }, other));
  });
  false ? DialogActions.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the component.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * If `true`, the actions do not have additional margin.
     * @default false
     */
    disableSpacing: import_prop_types.default.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var DialogActions_default = DialogActions;

  // node_modules/@mui/material/DialogContent/DialogContent.js
  var React64 = __toESM(require_react());

  // node_modules/@mui/material/DialogContent/dialogContentClasses.js
  function getDialogContentUtilityClass(slot) {
    return generateUtilityClass("MuiDialogContent", slot);
  }
  var dialogContentClasses = generateUtilityClasses("MuiDialogContent", ["root", "dividers"]);

  // node_modules/@mui/material/DialogTitle/dialogTitleClasses.js
  function getDialogTitleUtilityClass(slot) {
    return generateUtilityClass("MuiDialogTitle", slot);
  }
  var dialogTitleClasses = generateUtilityClasses("MuiDialogTitle", ["root"]);
  var dialogTitleClasses_default = dialogTitleClasses;

  // node_modules/@mui/material/DialogContent/DialogContent.js
  var import_jsx_runtime37 = __toESM(require_jsx_runtime());
  var useUtilityClasses14 = (ownerState) => {
    const {
      classes,
      dividers
    } = ownerState;
    const slots = {
      root: ["root", dividers && "dividers"]
    };
    return composeClasses(slots, getDialogContentUtilityClass, classes);
  };
  var DialogContentRoot = styled_default2("div", {
    name: "MuiDialogContent",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.dividers && styles2.dividers];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    flex: "1 1 auto",
    // Add iOS momentum scrolling for iOS < 13.0
    WebkitOverflowScrolling: "touch",
    overflowY: "auto",
    padding: "20px 24px",
    variants: [{
      props: ({
        ownerState
      }) => ownerState.dividers,
      style: {
        padding: "16px 24px",
        borderTop: `1px solid ${(theme.vars || theme).palette.divider}`,
        borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
      }
    }, {
      props: ({
        ownerState
      }) => !ownerState.dividers,
      style: {
        [`.${dialogTitleClasses_default.root} + &`]: {
          paddingTop: 0
        }
      }
    }]
  })));
  var DialogContent = /* @__PURE__ */ React64.forwardRef(function DialogContent2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiDialogContent"
    });
    const _a = props, {
      className,
      dividers = false
    } = _a, other = __objRest(_a, [
      "className",
      "dividers"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      dividers
    });
    const classes = useUtilityClasses14(ownerState);
    return /* @__PURE__ */ (0, import_jsx_runtime37.jsx)(DialogContentRoot, __spreadValues({
      className: clsx_default(classes.root, className),
      ownerState,
      ref
    }, other));
  });
  false ? DialogContent.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the component.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * Display the top and bottom dividers.
     * @default false
     */
    dividers: import_prop_types.default.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var DialogContent_default = DialogContent;

  // node_modules/@mui/material/DialogTitle/DialogTitle.js
  var React65 = __toESM(require_react());
  var import_jsx_runtime38 = __toESM(require_jsx_runtime());
  var useUtilityClasses15 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getDialogTitleUtilityClass, classes);
  };
  var DialogTitleRoot = styled_default2(Typography_default, {
    name: "MuiDialogTitle",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    padding: "16px 24px",
    flex: "0 0 auto"
  });
  var DialogTitle = /* @__PURE__ */ React65.forwardRef(function DialogTitle2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiDialogTitle"
    });
    const _a = props, {
      className,
      id: idProp
    } = _a, other = __objRest(_a, [
      "className",
      "id"
    ]);
    const ownerState = props;
    const classes = useUtilityClasses15(ownerState);
    const {
      titleId = idProp
    } = React65.useContext(DialogContext_default);
    return /* @__PURE__ */ (0, import_jsx_runtime38.jsx)(DialogTitleRoot, __spreadValues({
      component: "h2",
      className: clsx_default(classes.root, className),
      ownerState,
      ref,
      variant: "h6",
      id: idProp != null ? idProp : titleId
    }, other));
  });
  false ? DialogTitle.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the component.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * @ignore
     */
    id: import_prop_types.default.string,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var DialogTitle_default = DialogTitle;

  // node_modules/@mui/material/Grid2/Grid2.js
  var Grid2 = createGrid({
    createStyledComponent: styled_default2("div", {
      name: "MuiGrid2",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.container && styles2.container];
      }
    }),
    componentName: "MuiGrid2",
    useThemeProps: (inProps) => useDefaultProps2({
      props: inProps,
      name: "MuiGrid2"
    }),
    useTheme: useTheme5
  });
  false ? Grid2.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the component.
     */
    children: import_prop_types.default.node,
    /**
     * The number of columns.
     * @default 12
     */
    columns: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.number), import_prop_types.default.number, import_prop_types.default.object]),
    /**
     * Defines the horizontal space between the type `item` components.
     * It overrides the value of the `spacing` prop.
     */
    columnSpacing: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])), import_prop_types.default.number, import_prop_types.default.object, import_prop_types.default.string]),
    /**
     * If `true`, the component will have the flex *container* behavior.
     * You should be wrapping *items* with a *container*.
     * @default false
     */
    container: import_prop_types.default.bool,
    /**
     * Defines the `flex-direction` style property.
     * It is applied for all screen sizes.
     * @default 'row'
     */
    direction: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types.default.arrayOf(import_prop_types.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types.default.object]),
    /**
     * Defines the offset value for the type `item` components.
     */
    offset: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.number, import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.number])), import_prop_types.default.object]),
    /**
     * Defines the vertical space between the type `item` components.
     * It overrides the value of the `spacing` prop.
     */
    rowSpacing: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])), import_prop_types.default.number, import_prop_types.default.object, import_prop_types.default.string]),
    /**
     * Defines the size of the the type `item` components.
     */
    size: import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.bool, import_prop_types.default.number, import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.string, import_prop_types.default.bool, import_prop_types.default.number])), import_prop_types.default.object]),
    /**
     * Defines the space between the type `item` components.
     * It can only be used on a type `container` component.
     * @default 0
     */
    spacing: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])), import_prop_types.default.number, import_prop_types.default.object, import_prop_types.default.string]),
    /**
     * @ignore
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * @internal
     * The level of the grid starts from `0` and increases when the grid nests
     * inside another grid. Nesting is defined as a container Grid being a direct
     * child of a container Grid.
     *
     * ```js
     * <Grid container> // level 0
     *   <Grid container> // level 1
     *     <Grid container> // level 2
     * ```
     *
     * Only consecutive grid is considered nesting. A grid container will start at
     * `0` if there are non-Grid container element above it.
     *
     * ```js
     * <Grid container> // level 0
     *   <div>
     *     <Grid container> // level 0
     * ```
     *
     * ```js
     * <Grid container> // level 0
     *   <Grid>
     *     <Grid container> // level 0
     * ```
     */
    unstable_level: import_prop_types.default.number,
    /**
     * Defines the `flex-wrap` style property.
     * It's applied for all screen sizes.
     * @default 'wrap'
     */
    wrap: import_prop_types.default.oneOf(["nowrap", "wrap-reverse", "wrap"])
  } : void 0;
  if (false) {
    const Component = Grid2;
    const requireProp = requirePropFactory_default("Grid2", Component);
    Component["propTypes"] = __spreadProps(__spreadValues({}, Component.propTypes), {
      direction: requireProp("container"),
      spacing: requireProp("container"),
      wrap: requireProp("container")
    });
  }
  var Grid2_default = Grid2;

  // node_modules/@mui/material/NoSsr/NoSsr.js
  var React66 = __toESM(require_react());
  function NoSsr(props) {
    const {
      children,
      defer = false,
      fallback = null
    } = props;
    const [mountedState, setMountedState] = React66.useState(false);
    useEnhancedEffect_default(() => {
      if (!defer) {
        setMountedState(true);
      }
    }, [defer]);
    React66.useEffect(() => {
      if (defer) {
        setMountedState(true);
      }
    }, [defer]);
    return mountedState ? children : fallback;
  }
  false ? NoSsr.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │ To update them, edit the TypeScript types and run `pnpm proptypes`. │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * You can wrap a node.
     */
    children: import_prop_types.default.node,
    /**
     * If `true`, the component will not only prevent server-side rendering.
     * It will also defer the rendering of the children into a different screen frame.
     * @default false
     */
    defer: import_prop_types.default.bool,
    /**
     * The fallback content to display.
     * @default null
     */
    fallback: import_prop_types.default.node
  } : void 0;
  if (false) {
    NoSsr["propTypes"] = exactProp(NoSsr.propTypes);
  }
  var NoSsr_default = NoSsr;

  // node_modules/@mui/material/Stack/Stack.js
  var Stack = createStack({
    createStyledComponent: styled_default2("div", {
      name: "MuiStack",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    }),
    useThemeProps: (inProps) => useDefaultProps2({
      props: inProps,
      name: "MuiStack"
    })
  });
  false ? Stack.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the component.
     */
    children: import_prop_types.default.node,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * Defines the `flex-direction` style property.
     * It is applied for all screen sizes.
     * @default 'column'
     */
    direction: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["column-reverse", "column", "row-reverse", "row"]), import_prop_types.default.arrayOf(import_prop_types.default.oneOf(["column-reverse", "column", "row-reverse", "row"])), import_prop_types.default.object]),
    /**
     * Add an element between each child.
     */
    divider: import_prop_types.default.node,
    /**
     * Defines the space between immediate children.
     * @default 0
     */
    spacing: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])), import_prop_types.default.number, import_prop_types.default.object, import_prop_types.default.string]),
    /**
     * The system prop, which allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * If `true`, the CSS flexbox `gap` is used instead of applying `margin` to children.
     *
     * While CSS `gap` removes the [known limitations](https://mui.com/joy-ui/react-stack/#limitations),
     * it is not fully supported in some browsers. We recommend checking https://caniuse.com/?search=flex%20gap before using this flag.
     *
     * To enable this flag globally, follow the [theme's default props](https://mui.com/material-ui/customization/theme-components/#default-props) configuration.
     * @default false
     */
    useFlexGap: import_prop_types.default.bool
  } : void 0;
  var Stack_default = Stack;

  // node_modules/@mui/material/Table/Table.js
  var React68 = __toESM(require_react());

  // node_modules/@mui/material/Table/TableContext.js
  var React67 = __toESM(require_react());
  var TableContext = /* @__PURE__ */ React67.createContext();
  if (false) {
    TableContext.displayName = "TableContext";
  }
  var TableContext_default = TableContext;

  // node_modules/@mui/material/Table/tableClasses.js
  function getTableUtilityClass(slot) {
    return generateUtilityClass("MuiTable", slot);
  }
  var tableClasses = generateUtilityClasses("MuiTable", ["root", "stickyHeader"]);

  // node_modules/@mui/material/Table/Table.js
  var import_jsx_runtime39 = __toESM(require_jsx_runtime());
  var useUtilityClasses16 = (ownerState) => {
    const {
      classes,
      stickyHeader
    } = ownerState;
    const slots = {
      root: ["root", stickyHeader && "stickyHeader"]
    };
    return composeClasses(slots, getTableUtilityClass, classes);
  };
  var TableRoot = styled_default2("table", {
    name: "MuiTable",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.stickyHeader && styles2.stickyHeader];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    display: "table",
    width: "100%",
    borderCollapse: "collapse",
    borderSpacing: 0,
    "& caption": __spreadProps(__spreadValues({}, theme.typography.body2), {
      padding: theme.spacing(2),
      color: (theme.vars || theme).palette.text.secondary,
      textAlign: "left",
      captionSide: "bottom"
    }),
    variants: [{
      props: ({
        ownerState
      }) => ownerState.stickyHeader,
      style: {
        borderCollapse: "separate"
      }
    }]
  })));
  var defaultComponent = "table";
  var Table = /* @__PURE__ */ React68.forwardRef(function Table2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiTable"
    });
    const _a = props, {
      className,
      component = defaultComponent,
      padding: padding2 = "normal",
      size = "medium",
      stickyHeader = false
    } = _a, other = __objRest(_a, [
      "className",
      "component",
      "padding",
      "size",
      "stickyHeader"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      component,
      padding: padding2,
      size,
      stickyHeader
    });
    const classes = useUtilityClasses16(ownerState);
    const table = React68.useMemo(() => ({
      padding: padding2,
      size,
      stickyHeader
    }), [padding2, size, stickyHeader]);
    return /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(TableContext_default.Provider, {
      value: table,
      children: /* @__PURE__ */ (0, import_jsx_runtime39.jsx)(TableRoot, __spreadValues({
        as: component,
        role: component === defaultComponent ? null : "table",
        ref,
        className: clsx_default(classes.root, className),
        ownerState
      }, other))
    });
  });
  false ? Table.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the table, normally `TableHead` and `TableBody`.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * Allows TableCells to inherit padding of the Table.
     * @default 'normal'
     */
    padding: import_prop_types.default.oneOf(["checkbox", "none", "normal"]),
    /**
     * Allows TableCells to inherit size of the Table.
     * @default 'medium'
     */
    size: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["medium", "small"]), import_prop_types.default.string]),
    /**
     * Set the header sticky.
     * @default false
     */
    stickyHeader: import_prop_types.default.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var Table_default = Table;

  // node_modules/@mui/material/TableBody/TableBody.js
  var React70 = __toESM(require_react());

  // node_modules/@mui/material/Table/Tablelvl2Context.js
  var React69 = __toESM(require_react());
  var Tablelvl2Context = /* @__PURE__ */ React69.createContext();
  if (false) {
    Tablelvl2Context.displayName = "Tablelvl2Context";
  }
  var Tablelvl2Context_default = Tablelvl2Context;

  // node_modules/@mui/material/TableBody/tableBodyClasses.js
  function getTableBodyUtilityClass(slot) {
    return generateUtilityClass("MuiTableBody", slot);
  }
  var tableBodyClasses = generateUtilityClasses("MuiTableBody", ["root"]);

  // node_modules/@mui/material/TableBody/TableBody.js
  var import_jsx_runtime40 = __toESM(require_jsx_runtime());
  var useUtilityClasses17 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getTableBodyUtilityClass, classes);
  };
  var TableBodyRoot = styled_default2("tbody", {
    name: "MuiTableBody",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "table-row-group"
  });
  var tablelvl2 = {
    variant: "body"
  };
  var defaultComponent2 = "tbody";
  var TableBody = /* @__PURE__ */ React70.forwardRef(function TableBody2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiTableBody"
    });
    const _a = props, {
      className,
      component = defaultComponent2
    } = _a, other = __objRest(_a, [
      "className",
      "component"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      component
    });
    const classes = useUtilityClasses17(ownerState);
    return /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(Tablelvl2Context_default.Provider, {
      value: tablelvl2,
      children: /* @__PURE__ */ (0, import_jsx_runtime40.jsx)(TableBodyRoot, __spreadValues({
        className: clsx_default(classes.root, className),
        as: component,
        ref,
        role: component === defaultComponent2 ? null : "rowgroup",
        ownerState
      }, other))
    });
  });
  false ? TableBody.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the component, normally `TableRow`.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var TableBody_default = TableBody;

  // node_modules/@mui/material/TableCell/TableCell.js
  var React71 = __toESM(require_react());

  // node_modules/@mui/material/TableCell/tableCellClasses.js
  function getTableCellUtilityClass(slot) {
    return generateUtilityClass("MuiTableCell", slot);
  }
  var tableCellClasses = generateUtilityClasses("MuiTableCell", ["root", "head", "body", "footer", "sizeSmall", "sizeMedium", "paddingCheckbox", "paddingNone", "alignLeft", "alignCenter", "alignRight", "alignJustify", "stickyHeader"]);
  var tableCellClasses_default = tableCellClasses;

  // node_modules/@mui/material/TableCell/TableCell.js
  var import_jsx_runtime41 = __toESM(require_jsx_runtime());
  var useUtilityClasses18 = (ownerState) => {
    const {
      classes,
      variant,
      align,
      padding: padding2,
      size,
      stickyHeader
    } = ownerState;
    const slots = {
      root: ["root", variant, stickyHeader && "stickyHeader", align !== "inherit" && `align${capitalize_default(align)}`, padding2 !== "normal" && `padding${capitalize_default(padding2)}`, `size${capitalize_default(size)}`]
    };
    return composeClasses(slots, getTableCellUtilityClass, classes);
  };
  var TableCellRoot = styled_default2("td", {
    name: "MuiTableCell",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, styles2[ownerState.variant], styles2[`size${capitalize_default(ownerState.size)}`], ownerState.padding !== "normal" && styles2[`padding${capitalize_default(ownerState.padding)}`], ownerState.align !== "inherit" && styles2[`align${capitalize_default(ownerState.align)}`], ownerState.stickyHeader && styles2.stickyHeader];
    }
  })(memoTheme_default(({
    theme
  }) => __spreadProps(__spreadValues({}, theme.typography.body2), {
    display: "table-cell",
    verticalAlign: "inherit",
    // Workaround for a rendering bug with spanned columns in Chrome 62.0.
    // Removes the alpha (sets it to 1), and lightens or darkens the theme color.
    borderBottom: theme.vars ? `1px solid ${theme.vars.palette.TableCell.border}` : `1px solid
    ${theme.palette.mode === "light" ? lighten(alpha(theme.palette.divider, 1), 0.88) : darken(alpha(theme.palette.divider, 1), 0.68)}`,
    textAlign: "left",
    padding: 16,
    variants: [{
      props: {
        variant: "head"
      },
      style: {
        color: (theme.vars || theme).palette.text.primary,
        lineHeight: theme.typography.pxToRem(24),
        fontWeight: theme.typography.fontWeightMedium
      }
    }, {
      props: {
        variant: "body"
      },
      style: {
        color: (theme.vars || theme).palette.text.primary
      }
    }, {
      props: {
        variant: "footer"
      },
      style: {
        color: (theme.vars || theme).palette.text.secondary,
        lineHeight: theme.typography.pxToRem(21),
        fontSize: theme.typography.pxToRem(12)
      }
    }, {
      props: {
        size: "small"
      },
      style: {
        padding: "6px 16px",
        [`&.${tableCellClasses_default.paddingCheckbox}`]: {
          width: 24,
          // prevent the checkbox column from growing
          padding: "0 12px 0 16px",
          "& > *": {
            padding: 0
          }
        }
      }
    }, {
      props: {
        padding: "checkbox"
      },
      style: {
        width: 48,
        // prevent the checkbox column from growing
        padding: "0 0 0 4px"
      }
    }, {
      props: {
        padding: "none"
      },
      style: {
        padding: 0
      }
    }, {
      props: {
        align: "left"
      },
      style: {
        textAlign: "left"
      }
    }, {
      props: {
        align: "center"
      },
      style: {
        textAlign: "center"
      }
    }, {
      props: {
        align: "right"
      },
      style: {
        textAlign: "right",
        flexDirection: "row-reverse"
      }
    }, {
      props: {
        align: "justify"
      },
      style: {
        textAlign: "justify"
      }
    }, {
      props: ({
        ownerState
      }) => ownerState.stickyHeader,
      style: {
        position: "sticky",
        top: 0,
        zIndex: 2,
        backgroundColor: (theme.vars || theme).palette.background.default
      }
    }]
  })));
  var TableCell = /* @__PURE__ */ React71.forwardRef(function TableCell2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiTableCell"
    });
    const _a = props, {
      align = "inherit",
      className,
      component: componentProp,
      padding: paddingProp,
      scope: scopeProp,
      size: sizeProp,
      sortDirection,
      variant: variantProp
    } = _a, other = __objRest(_a, [
      "align",
      "className",
      "component",
      "padding",
      "scope",
      "size",
      "sortDirection",
      "variant"
    ]);
    const table = React71.useContext(TableContext_default);
    const tablelvl23 = React71.useContext(Tablelvl2Context_default);
    const isHeadCell = tablelvl23 && tablelvl23.variant === "head";
    let component;
    if (componentProp) {
      component = componentProp;
    } else {
      component = isHeadCell ? "th" : "td";
    }
    let scope = scopeProp;
    if (component === "td") {
      scope = void 0;
    } else if (!scope && isHeadCell) {
      scope = "col";
    }
    const variant = variantProp || tablelvl23 && tablelvl23.variant;
    const ownerState = __spreadProps(__spreadValues({}, props), {
      align,
      component,
      padding: paddingProp || (table && table.padding ? table.padding : "normal"),
      size: sizeProp || (table && table.size ? table.size : "medium"),
      sortDirection,
      stickyHeader: variant === "head" && table && table.stickyHeader,
      variant
    });
    const classes = useUtilityClasses18(ownerState);
    let ariaSort = null;
    if (sortDirection) {
      ariaSort = sortDirection === "asc" ? "ascending" : "descending";
    }
    return /* @__PURE__ */ (0, import_jsx_runtime41.jsx)(TableCellRoot, __spreadValues({
      as: component,
      ref,
      className: clsx_default(classes.root, className),
      "aria-sort": ariaSort,
      scope,
      ownerState
    }, other));
  });
  false ? TableCell.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * Set the text-align on the table cell content.
     *
     * Monetary or generally number fields **should be right aligned** as that allows
     * you to add them up quickly in your head without having to worry about decimals.
     * @default 'inherit'
     */
    align: import_prop_types.default.oneOf(["center", "inherit", "justify", "left", "right"]),
    /**
     * The content of the component.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * Sets the padding applied to the cell.
     * The prop defaults to the value (`'default'`) inherited from the parent Table component.
     */
    padding: import_prop_types.default.oneOf(["checkbox", "none", "normal"]),
    /**
     * Set scope attribute.
     */
    scope: import_prop_types.default.string,
    /**
     * Specify the size of the cell.
     * The prop defaults to the value (`'medium'`) inherited from the parent Table component.
     */
    size: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["medium", "small"]), import_prop_types.default.string]),
    /**
     * Set aria-sort direction.
     */
    sortDirection: import_prop_types.default.oneOf(["asc", "desc", false]),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * Specify the cell type.
     * The prop defaults to the value inherited from the parent TableHead, TableBody, or TableFooter components.
     */
    variant: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["body", "footer", "head"]), import_prop_types.default.string])
  } : void 0;
  var TableCell_default = TableCell;

  // node_modules/@mui/material/TableContainer/TableContainer.js
  var React72 = __toESM(require_react());

  // node_modules/@mui/material/TableContainer/tableContainerClasses.js
  function getTableContainerUtilityClass(slot) {
    return generateUtilityClass("MuiTableContainer", slot);
  }
  var tableContainerClasses = generateUtilityClasses("MuiTableContainer", ["root"]);

  // node_modules/@mui/material/TableContainer/TableContainer.js
  var import_jsx_runtime42 = __toESM(require_jsx_runtime());
  var useUtilityClasses19 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getTableContainerUtilityClass, classes);
  };
  var TableContainerRoot = styled_default2("div", {
    name: "MuiTableContainer",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    width: "100%",
    overflowX: "auto"
  });
  var TableContainer = /* @__PURE__ */ React72.forwardRef(function TableContainer2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiTableContainer"
    });
    const _a = props, {
      className,
      component = "div"
    } = _a, other = __objRest(_a, [
      "className",
      "component"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      component
    });
    const classes = useUtilityClasses19(ownerState);
    return /* @__PURE__ */ (0, import_jsx_runtime42.jsx)(TableContainerRoot, __spreadValues({
      ref,
      as: component,
      className: clsx_default(classes.root, className),
      ownerState
    }, other));
  });
  false ? TableContainer.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the component, normally `Table`.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var TableContainer_default = TableContainer;

  // node_modules/@mui/material/TableHead/TableHead.js
  var React73 = __toESM(require_react());

  // node_modules/@mui/material/TableHead/tableHeadClasses.js
  function getTableHeadUtilityClass(slot) {
    return generateUtilityClass("MuiTableHead", slot);
  }
  var tableHeadClasses = generateUtilityClasses("MuiTableHead", ["root"]);

  // node_modules/@mui/material/TableHead/TableHead.js
  var import_jsx_runtime43 = __toESM(require_jsx_runtime());
  var useUtilityClasses20 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"]
    };
    return composeClasses(slots, getTableHeadUtilityClass, classes);
  };
  var TableHeadRoot = styled_default2("thead", {
    name: "MuiTableHead",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({
    display: "table-header-group"
  });
  var tablelvl22 = {
    variant: "head"
  };
  var defaultComponent3 = "thead";
  var TableHead = /* @__PURE__ */ React73.forwardRef(function TableHead2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiTableHead"
    });
    const _a = props, {
      className,
      component = defaultComponent3
    } = _a, other = __objRest(_a, [
      "className",
      "component"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      component
    });
    const classes = useUtilityClasses20(ownerState);
    return /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(Tablelvl2Context_default.Provider, {
      value: tablelvl22,
      children: /* @__PURE__ */ (0, import_jsx_runtime43.jsx)(TableHeadRoot, __spreadValues({
        as: component,
        className: clsx_default(classes.root, className),
        ref,
        role: component === defaultComponent3 ? null : "rowgroup",
        ownerState
      }, other))
    });
  });
  false ? TableHead.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * The content of the component, normally `TableRow`.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var TableHead_default = TableHead;

  // node_modules/@mui/material/TableRow/TableRow.js
  var React74 = __toESM(require_react());

  // node_modules/@mui/material/TableRow/tableRowClasses.js
  function getTableRowUtilityClass(slot) {
    return generateUtilityClass("MuiTableRow", slot);
  }
  var tableRowClasses = generateUtilityClasses("MuiTableRow", ["root", "selected", "hover", "head", "footer"]);
  var tableRowClasses_default = tableRowClasses;

  // node_modules/@mui/material/TableRow/TableRow.js
  var import_jsx_runtime44 = __toESM(require_jsx_runtime());
  var useUtilityClasses21 = (ownerState) => {
    const {
      classes,
      selected,
      hover,
      head,
      footer
    } = ownerState;
    const slots = {
      root: ["root", selected && "selected", hover && "hover", head && "head", footer && "footer"]
    };
    return composeClasses(slots, getTableRowUtilityClass, classes);
  };
  var TableRowRoot = styled_default2("tr", {
    name: "MuiTableRow",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.head && styles2.head, ownerState.footer && styles2.footer];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    color: "inherit",
    display: "table-row",
    verticalAlign: "middle",
    // We disable the focus ring for mouse, touch and keyboard users.
    outline: 0,
    [`&.${tableRowClasses_default.hover}:hover`]: {
      backgroundColor: (theme.vars || theme).palette.action.hover
    },
    [`&.${tableRowClasses_default.selected}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
      "&:hover": {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity)
      }
    }
  })));
  var defaultComponent4 = "tr";
  var TableRow = /* @__PURE__ */ React74.forwardRef(function TableRow2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiTableRow"
    });
    const _a = props, {
      className,
      component = defaultComponent4,
      hover = false,
      selected = false
    } = _a, other = __objRest(_a, [
      "className",
      "component",
      "hover",
      "selected"
    ]);
    const tablelvl23 = React74.useContext(Tablelvl2Context_default);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      component,
      hover,
      selected,
      head: tablelvl23 && tablelvl23.variant === "head",
      footer: tablelvl23 && tablelvl23.variant === "footer"
    });
    const classes = useUtilityClasses21(ownerState);
    return /* @__PURE__ */ (0, import_jsx_runtime44.jsx)(TableRowRoot, __spreadValues({
      as: component,
      ref,
      className: clsx_default(classes.root, className),
      role: component === defaultComponent4 ? null : "row",
      ownerState
    }, other));
  });
  false ? TableRow.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * Should be valid `<tr>` children such as `TableCell`.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The component used for the root node.
     * Either a string to use a HTML element or a component.
     */
    component: import_prop_types.default.elementType,
    /**
     * If `true`, the table row will shade on hover.
     * @default false
     */
    hover: import_prop_types.default.bool,
    /**
     * If `true`, the table row will have the selected shading.
     * @default false
     */
    selected: import_prop_types.default.bool,
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var TableRow_default = TableRow;

  // node_modules/@mui/material/TableSortLabel/TableSortLabel.js
  var React76 = __toESM(require_react());

  // node_modules/@mui/material/internal/svg-icons/ArrowDownward.js
  var React75 = __toESM(require_react());
  var import_jsx_runtime45 = __toESM(require_jsx_runtime());
  var ArrowDownward_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime45.jsx)("path", {
    d: "M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"
  }), "ArrowDownward");

  // node_modules/@mui/material/TableSortLabel/tableSortLabelClasses.js
  function getTableSortLabelUtilityClass(slot) {
    return generateUtilityClass("MuiTableSortLabel", slot);
  }
  var tableSortLabelClasses = generateUtilityClasses("MuiTableSortLabel", ["root", "active", "icon", "iconDirectionDesc", "iconDirectionAsc", "directionDesc", "directionAsc"]);
  var tableSortLabelClasses_default = tableSortLabelClasses;

  // node_modules/@mui/material/TableSortLabel/TableSortLabel.js
  var import_jsx_runtime46 = __toESM(require_jsx_runtime());
  var useUtilityClasses22 = (ownerState) => {
    const {
      classes,
      direction,
      active
    } = ownerState;
    const slots = {
      root: ["root", active && "active", `direction${capitalize_default(direction)}`],
      icon: ["icon", `iconDirection${capitalize_default(direction)}`]
    };
    return composeClasses(slots, getTableSortLabelUtilityClass, classes);
  };
  var TableSortLabelRoot = styled_default2(ButtonBase_default, {
    name: "MuiTableSortLabel",
    slot: "Root",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.active && styles2.active];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    cursor: "pointer",
    display: "inline-flex",
    justifyContent: "flex-start",
    flexDirection: "inherit",
    alignItems: "center",
    "&:focus": {
      color: (theme.vars || theme).palette.text.secondary
    },
    "&:hover": {
      color: (theme.vars || theme).palette.text.secondary,
      [`& .${tableSortLabelClasses_default.icon}`]: {
        opacity: 0.5
      }
    },
    [`&.${tableSortLabelClasses_default.active}`]: {
      color: (theme.vars || theme).palette.text.primary,
      [`& .${tableSortLabelClasses_default.icon}`]: {
        opacity: 1,
        color: (theme.vars || theme).palette.text.secondary
      }
    }
  })));
  var TableSortLabelIcon = styled_default2("span", {
    name: "MuiTableSortLabel",
    slot: "Icon",
    overridesResolver: (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.icon, styles2[`iconDirection${capitalize_default(ownerState.direction)}`]];
    }
  })(memoTheme_default(({
    theme
  }) => ({
    fontSize: 18,
    marginRight: 4,
    marginLeft: 4,
    opacity: 0,
    transition: theme.transitions.create(["opacity", "transform"], {
      duration: theme.transitions.duration.shorter
    }),
    userSelect: "none",
    variants: [{
      props: {
        direction: "desc"
      },
      style: {
        transform: "rotate(0deg)"
      }
    }, {
      props: {
        direction: "asc"
      },
      style: {
        transform: "rotate(180deg)"
      }
    }]
  })));
  var TableSortLabel = /* @__PURE__ */ React76.forwardRef(function TableSortLabel2(inProps, ref) {
    const props = useDefaultProps2({
      props: inProps,
      name: "MuiTableSortLabel"
    });
    const _a = props, {
      active = false,
      children,
      className,
      direction = "asc",
      hideSortIcon = false,
      IconComponent = ArrowDownward_default,
      slots = {},
      slotProps = {}
    } = _a, other = __objRest(_a, [
      "active",
      "children",
      "className",
      "direction",
      "hideSortIcon",
      "IconComponent",
      "slots",
      "slotProps"
    ]);
    const ownerState = __spreadProps(__spreadValues({}, props), {
      active,
      direction,
      hideSortIcon,
      IconComponent
    });
    const classes = useUtilityClasses22(ownerState);
    const externalForwardedProps = {
      slots,
      slotProps
    };
    const [RootSlot, rootProps] = useSlot("root", {
      elementType: TableSortLabelRoot,
      externalForwardedProps,
      ownerState,
      className: clsx_default(classes.root, className),
      ref
    });
    const [IconSlot, iconProps] = useSlot("icon", {
      elementType: TableSortLabelIcon,
      externalForwardedProps,
      ownerState,
      className: classes.icon
    });
    return /* @__PURE__ */ (0, import_jsx_runtime46.jsxs)(RootSlot, __spreadProps(__spreadValues(__spreadValues({
      disableRipple: true,
      component: "span"
    }, rootProps), other), {
      children: [children, hideSortIcon && !active ? null : /* @__PURE__ */ (0, import_jsx_runtime46.jsx)(IconSlot, __spreadValues({
        as: IconComponent
      }, iconProps))]
    }));
  });
  false ? TableSortLabel.propTypes = {
    // ┌────────────────────────────── Warning ──────────────────────────────┐
    // │ These PropTypes are generated from the TypeScript type definitions. │
    // │    To update them, edit the d.ts file and run `pnpm proptypes`.     │
    // └─────────────────────────────────────────────────────────────────────┘
    /**
     * If `true`, the label will have the active styling (should be true for the sorted column).
     * @default false
     */
    active: import_prop_types.default.bool,
    /**
     * Label contents, the arrow will be appended automatically.
     */
    children: import_prop_types.default.node,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * @ignore
     */
    className: import_prop_types.default.string,
    /**
     * The current sort direction.
     * @default 'asc'
     */
    direction: import_prop_types.default.oneOf(["asc", "desc"]),
    /**
     * Hide sort icon when active is false.
     * @default false
     */
    hideSortIcon: import_prop_types.default.bool,
    /**
     * Sort icon to use.
     * @default ArrowDownwardIcon
     */
    IconComponent: import_prop_types.default.elementType,
    /**
     * The props used for each slot inside.
     * @default {}
     */
    slotProps: import_prop_types.default.shape({
      icon: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object]),
      root: import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object])
    }),
    /**
     * The components used for each slot inside.
     * @default {}
     */
    slots: import_prop_types.default.shape({
      icon: import_prop_types.default.elementType,
      root: import_prop_types.default.elementType
    }),
    /**
     * The system prop that allows defining system overrides as well as additional CSS styles.
     */
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;
  var TableSortLabel_default = TableSortLabel;

  // src/Components/Poppers/BasePopper.tsx
  var import_jsx_runtime47 = __toESM(require_jsx_runtime());
  var BasePopper = ({ anchor, children }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime47.jsx)(
      Popper_default,
      {
        sx: { zIndex: 1700 },
        open: true,
        anchorEl: anchor,
        placement: "left",
        disablePortal: false,
        modifiers: [
          {
            name: "flip",
            options: {
              fallbackPlacements: ["right", "top", "bottom"]
            }
          }
        ],
        children
      }
    );
  };

  // node_modules/@mui/icons-material/esm/Close.js
  var import_jsx_runtime48 = __toESM(require_jsx_runtime());
  var Close_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime48.jsx)("path", {
    d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
  }), "Close");

  // src/Components/Modals/BaseModal.tsx
  var import_jsx_runtime49 = __toESM(require_jsx_runtime());
  var BaseModal = (props) => {
    const { sx, children, title, modal, setModal, maxWidth: maxWidth2, onCancel } = props;
    const onClose = () => onCancel ? onCancel() : setModal(false);
    return /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(Dialog_default, { sx, open: modal, onClose, scroll: "paper", fullWidth: true, maxWidth: maxWidth2, children: [
      /* @__PURE__ */ (0, import_jsx_runtime49.jsxs)(Box_default, { sx: { display: "flex", alignItems: "center" }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(DialogTitle_default, { children: title }),
        /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(Box_default, { sx: { flexGrow: 1 } }),
        /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(IconButton_default, { sx: { mr: 2 }, onClick: onClose, children: /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(Close_default, {}) })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(DialogContent_default, { dividers: true, children }),
      /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(DialogActions_default, { children: /* @__PURE__ */ (0, import_jsx_runtime49.jsx)(Button_default, { onClick: onClose, children: "Cancel" }) })
    ] });
  };

  // src/Components/Views/WidgetInfoRowsView.tsx
  var import_react12 = __toESM(require_react());
  var import_jsx_runtime50 = __toESM(require_jsx_runtime());
  var WidgetInfoRowsView = (props) => {
    const { children, containerSx } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(Grid2_default, { container: true, spacing: 1, sx: __spreadValues({ mt: 2 }, containerSx), children: import_react12.Children.map(
      children,
      (child, index) => child && /* @__PURE__ */ (0, import_jsx_runtime50.jsx)(Grid2_default, { size: { xs: 12 }, children: child }, index)
    ) });
  };

  // node_modules/@mui/icons-material/esm/ContentCopy.js
  var import_jsx_runtime51 = __toESM(require_jsx_runtime());
  var ContentCopy_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime51.jsx)("path", {
    d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2m0 16H8V7h11z"
  }), "ContentCopy");

  // src/Components/Views/BaseInfoRowView.tsx
  var import_react13 = __toESM(require_react());
  var import_jsx_runtime52 = __toESM(require_jsx_runtime());
  var BaseInfoRowView = (props) => {
    const { name, icon, value, noWrap = false, allowCopy = true, component = false, containerSx } = props;
    const internalValue = (0, import_react13.useMemo)(() => value || "unknown", [value]);
    const onCopy = async () => {
      await navigator.clipboard.writeText(String(value));
    };
    return /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(Box_default, { sx: __spreadValues({ display: "flex", alignItems: "center" }, containerSx), children: [
      /* @__PURE__ */ (0, import_jsx_runtime52.jsxs)(Typography_default, { noWrap, sx: { display: "flex", alignItems: "center" }, children: [
        name,
        ": ",
        component ? component : internalValue,
        " ",
        icon
      ] }),
      Boolean(value) && allowCopy && /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(Box_default, { sx: { display: "flex" }, children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(IconButton_default, { size: "small", sx: { ml: 1 }, onClick: onCopy, children: /* @__PURE__ */ (0, import_jsx_runtime52.jsx)(ContentCopy_default, { fontSize: "small" }) }) })
    ] });
  };

  // src/Components/Charts/Agent/Elements/ElementHistoryChartView.tsx
  var import_react29 = __toESM(require_react());

  // node_modules/@mui/x-charts/BarChart/BarPlot.js
  var React114 = __toESM(require_react());

  // node_modules/@react-spring/rafz/dist/react-spring_rafz.modern.mjs
  var updateQueue = makeQueue();
  var raf = (fn2) => schedule(fn2, updateQueue);
  var writeQueue = makeQueue();
  raf.write = (fn2) => schedule(fn2, writeQueue);
  var onStartQueue = makeQueue();
  raf.onStart = (fn2) => schedule(fn2, onStartQueue);
  var onFrameQueue = makeQueue();
  raf.onFrame = (fn2) => schedule(fn2, onFrameQueue);
  var onFinishQueue = makeQueue();
  raf.onFinish = (fn2) => schedule(fn2, onFinishQueue);
  var timeouts = [];
  raf.setTimeout = (handler, ms) => {
    const time2 = raf.now() + ms;
    const cancel = () => {
      const i = timeouts.findIndex((t) => t.cancel == cancel);
      if (~i)
        timeouts.splice(i, 1);
      pendingCount -= ~i ? 1 : 0;
    };
    const timeout2 = { time: time2, handler, cancel };
    timeouts.splice(findTimeout(time2), 0, timeout2);
    pendingCount += 1;
    start2();
    return timeout2;
  };
  var findTimeout = (time2) => ~(~timeouts.findIndex((t) => t.time > time2) || ~timeouts.length);
  raf.cancel = (fn2) => {
    onStartQueue.delete(fn2);
    onFrameQueue.delete(fn2);
    onFinishQueue.delete(fn2);
    updateQueue.delete(fn2);
    writeQueue.delete(fn2);
  };
  raf.sync = (fn2) => {
    sync = true;
    raf.batchedUpdates(fn2);
    sync = false;
  };
  raf.throttle = (fn2) => {
    let lastArgs;
    function queuedFn() {
      try {
        fn2(...lastArgs);
      } finally {
        lastArgs = null;
      }
    }
    function throttled(...args) {
      lastArgs = args;
      raf.onStart(queuedFn);
    }
    throttled.handler = fn2;
    throttled.cancel = () => {
      onStartQueue.delete(queuedFn);
      lastArgs = null;
    };
    return throttled;
  };
  var nativeRaf = typeof window != "undefined" ? window.requestAnimationFrame : (
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    () => {
    }
  );
  raf.use = (impl) => nativeRaf = impl;
  raf.now = typeof performance != "undefined" ? () => performance.now() : Date.now;
  raf.batchedUpdates = (fn2) => fn2();
  raf.catch = console.error;
  raf.frameLoop = "always";
  raf.advance = () => {
    if (raf.frameLoop !== "demand") {
      console.warn(
        "Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"
      );
    } else {
      update();
    }
  };
  var ts = -1;
  var pendingCount = 0;
  var sync = false;
  function schedule(fn2, queue) {
    if (sync) {
      queue.delete(fn2);
      fn2(0);
    } else {
      queue.add(fn2);
      start2();
    }
  }
  function start2() {
    if (ts < 0) {
      ts = 0;
      if (raf.frameLoop !== "demand") {
        nativeRaf(loop);
      }
    }
  }
  function stop() {
    ts = -1;
  }
  function loop() {
    if (~ts) {
      nativeRaf(loop);
      raf.batchedUpdates(update);
    }
  }
  function update() {
    const prevTs = ts;
    ts = raf.now();
    const count = findTimeout(ts);
    if (count) {
      eachSafely(timeouts.splice(0, count), (t) => t.handler());
      pendingCount -= count;
    }
    if (!pendingCount) {
      stop();
      return;
    }
    onStartQueue.flush();
    updateQueue.flush(prevTs ? Math.min(64, ts - prevTs) : 16.667);
    onFrameQueue.flush();
    writeQueue.flush();
    onFinishQueue.flush();
  }
  function makeQueue() {
    let next2 = /* @__PURE__ */ new Set();
    let current = next2;
    return {
      add(fn2) {
        pendingCount += current == next2 && !next2.has(fn2) ? 1 : 0;
        next2.add(fn2);
      },
      delete(fn2) {
        pendingCount -= current == next2 && next2.has(fn2) ? 1 : 0;
        return next2.delete(fn2);
      },
      flush(arg2) {
        if (current.size) {
          next2 = /* @__PURE__ */ new Set();
          pendingCount -= current.size;
          eachSafely(current, (fn2) => fn2(arg2) && next2.add(fn2));
          pendingCount += next2.size;
          current = next2;
        }
      }
    };
  }
  function eachSafely(values3, each2) {
    values3.forEach((value) => {
      try {
        each2(value);
      } catch (e) {
        raf.catch(e);
      }
    });
  }

  // node_modules/@react-spring/shared/dist/react-spring_shared.modern.mjs
  var import_react14 = __toESM(require_react(), 1);
  var import_react15 = __toESM(require_react(), 1);
  var import_react16 = __toESM(require_react(), 1);
  var import_react17 = __toESM(require_react(), 1);
  var import_react18 = __toESM(require_react(), 1);
  var import_react19 = __toESM(require_react(), 1);
  var import_react20 = __toESM(require_react(), 1);
  var import_react21 = __toESM(require_react(), 1);
  var __defProp2 = Object.defineProperty;
  var __export = (target, all) => {
    for (var name in all)
      __defProp2(target, name, { get: all[name], enumerable: true });
  };
  var globals_exports = {};
  __export(globals_exports, {
    assign: () => assign2,
    colors: () => colors,
    createStringInterpolator: () => createStringInterpolator,
    skipAnimation: () => skipAnimation,
    to: () => to,
    willAdvance: () => willAdvance
  });
  function noop5() {
  }
  var defineHidden = (obj, key, value) => Object.defineProperty(obj, key, { value, writable: true, configurable: true });
  var is = {
    arr: Array.isArray,
    obj: (a) => !!a && a.constructor.name === "Object",
    fun: (a) => typeof a === "function",
    str: (a) => typeof a === "string",
    num: (a) => typeof a === "number",
    und: (a) => a === void 0
  };
  function isEqual(a, b) {
    if (is.arr(a)) {
      if (!is.arr(b) || a.length !== b.length)
        return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    return a === b;
  }
  var each = (obj, fn2) => obj.forEach(fn2);
  function eachProp(obj, fn2, ctx2) {
    if (is.arr(obj)) {
      for (let i = 0; i < obj.length; i++) {
        fn2.call(ctx2, obj[i], `${i}`);
      }
      return;
    }
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        fn2.call(ctx2, obj[key], key);
      }
    }
  }
  var toArray = (a) => is.und(a) ? [] : is.arr(a) ? a : [a];
  function flush(queue, iterator) {
    if (queue.size) {
      const items = Array.from(queue);
      queue.clear();
      each(items, iterator);
    }
  }
  var flushCalls = (queue, ...args) => flush(queue, (fn2) => fn2(...args));
  var isSSR = () => typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
  var createStringInterpolator;
  var to;
  var colors = null;
  var skipAnimation = false;
  var willAdvance = noop5;
  var assign2 = (globals) => {
    if (globals.to)
      to = globals.to;
    if (globals.now)
      raf.now = globals.now;
    if (globals.colors !== void 0)
      colors = globals.colors;
    if (globals.skipAnimation != null)
      skipAnimation = globals.skipAnimation;
    if (globals.createStringInterpolator)
      createStringInterpolator = globals.createStringInterpolator;
    if (globals.requestAnimationFrame)
      raf.use(globals.requestAnimationFrame);
    if (globals.batchedUpdates)
      raf.batchedUpdates = globals.batchedUpdates;
    if (globals.willAdvance)
      willAdvance = globals.willAdvance;
    if (globals.frameLoop)
      raf.frameLoop = globals.frameLoop;
  };
  var startQueue = /* @__PURE__ */ new Set();
  var currentFrame = [];
  var prevFrame = [];
  var priority = 0;
  var frameLoop = {
    get idle() {
      return !startQueue.size && !currentFrame.length;
    },
    /** Advance the given animation on every frame until idle. */
    start(animation) {
      if (priority > animation.priority) {
        startQueue.add(animation);
        raf.onStart(flushStartQueue);
      } else {
        startSafely(animation);
        raf(advance);
      }
    },
    /** Advance all animations by the given time. */
    advance,
    /** Call this when an animation's priority changes. */
    sort(animation) {
      if (priority) {
        raf.onFrame(() => frameLoop.sort(animation));
      } else {
        const prevIndex = currentFrame.indexOf(animation);
        if (~prevIndex) {
          currentFrame.splice(prevIndex, 1);
          startUnsafely(animation);
        }
      }
    },
    /**
     * Clear all animations. For testing purposes.
     *
     * ☠️ Never call this from within the frameloop.
     */
    clear() {
      currentFrame = [];
      startQueue.clear();
    }
  };
  function flushStartQueue() {
    startQueue.forEach(startSafely);
    startQueue.clear();
    raf(advance);
  }
  function startSafely(animation) {
    if (!currentFrame.includes(animation))
      startUnsafely(animation);
  }
  function startUnsafely(animation) {
    currentFrame.splice(
      findIndex(currentFrame, (other) => other.priority > animation.priority),
      0,
      animation
    );
  }
  function advance(dt) {
    const nextFrame = prevFrame;
    for (let i = 0; i < currentFrame.length; i++) {
      const animation = currentFrame[i];
      priority = animation.priority;
      if (!animation.idle) {
        willAdvance(animation);
        animation.advance(dt);
        if (!animation.idle) {
          nextFrame.push(animation);
        }
      }
    }
    priority = 0;
    prevFrame = currentFrame;
    prevFrame.length = 0;
    currentFrame = nextFrame;
    return currentFrame.length > 0;
  }
  function findIndex(arr, test) {
    const index = arr.findIndex(test);
    return index < 0 ? arr.length : index;
  }
  var clamp2 = (min2, max2, v) => Math.min(Math.max(v, min2), max2);
  var colors2 = {
    transparent: 0,
    aliceblue: 4042850303,
    antiquewhite: 4209760255,
    aqua: 16777215,
    aquamarine: 2147472639,
    azure: 4043309055,
    beige: 4126530815,
    bisque: 4293182719,
    black: 255,
    blanchedalmond: 4293643775,
    blue: 65535,
    blueviolet: 2318131967,
    brown: 2771004159,
    burlywood: 3736635391,
    burntsienna: 3934150143,
    cadetblue: 1604231423,
    chartreuse: 2147418367,
    chocolate: 3530104575,
    coral: 4286533887,
    cornflowerblue: 1687547391,
    cornsilk: 4294499583,
    crimson: 3692313855,
    cyan: 16777215,
    darkblue: 35839,
    darkcyan: 9145343,
    darkgoldenrod: 3095792639,
    darkgray: 2846468607,
    darkgreen: 6553855,
    darkgrey: 2846468607,
    darkkhaki: 3182914559,
    darkmagenta: 2332068863,
    darkolivegreen: 1433087999,
    darkorange: 4287365375,
    darkorchid: 2570243327,
    darkred: 2332033279,
    darksalmon: 3918953215,
    darkseagreen: 2411499519,
    darkslateblue: 1211993087,
    darkslategray: 793726975,
    darkslategrey: 793726975,
    darkturquoise: 13554175,
    darkviolet: 2483082239,
    deeppink: 4279538687,
    deepskyblue: 12582911,
    dimgray: 1768516095,
    dimgrey: 1768516095,
    dodgerblue: 512819199,
    firebrick: 2988581631,
    floralwhite: 4294635775,
    forestgreen: 579543807,
    fuchsia: 4278255615,
    gainsboro: 3705462015,
    ghostwhite: 4177068031,
    gold: 4292280575,
    goldenrod: 3668254975,
    gray: 2155905279,
    green: 8388863,
    greenyellow: 2919182335,
    grey: 2155905279,
    honeydew: 4043305215,
    hotpink: 4285117695,
    indianred: 3445382399,
    indigo: 1258324735,
    ivory: 4294963455,
    khaki: 4041641215,
    lavender: 3873897215,
    lavenderblush: 4293981695,
    lawngreen: 2096890111,
    lemonchiffon: 4294626815,
    lightblue: 2916673279,
    lightcoral: 4034953471,
    lightcyan: 3774873599,
    lightgoldenrodyellow: 4210742015,
    lightgray: 3553874943,
    lightgreen: 2431553791,
    lightgrey: 3553874943,
    lightpink: 4290167295,
    lightsalmon: 4288707327,
    lightseagreen: 548580095,
    lightskyblue: 2278488831,
    lightslategray: 2005441023,
    lightslategrey: 2005441023,
    lightsteelblue: 2965692159,
    lightyellow: 4294959359,
    lime: 16711935,
    limegreen: 852308735,
    linen: 4210091775,
    magenta: 4278255615,
    maroon: 2147483903,
    mediumaquamarine: 1724754687,
    mediumblue: 52735,
    mediumorchid: 3126187007,
    mediumpurple: 2473647103,
    mediumseagreen: 1018393087,
    mediumslateblue: 2070474495,
    mediumspringgreen: 16423679,
    mediumturquoise: 1221709055,
    mediumvioletred: 3340076543,
    midnightblue: 421097727,
    mintcream: 4127193855,
    mistyrose: 4293190143,
    moccasin: 4293178879,
    navajowhite: 4292783615,
    navy: 33023,
    oldlace: 4260751103,
    olive: 2155872511,
    olivedrab: 1804477439,
    orange: 4289003775,
    orangered: 4282712319,
    orchid: 3664828159,
    palegoldenrod: 4008225535,
    palegreen: 2566625535,
    paleturquoise: 2951671551,
    palevioletred: 3681588223,
    papayawhip: 4293907967,
    peachpuff: 4292524543,
    peru: 3448061951,
    pink: 4290825215,
    plum: 3718307327,
    powderblue: 2967529215,
    purple: 2147516671,
    rebeccapurple: 1714657791,
    red: 4278190335,
    rosybrown: 3163525119,
    royalblue: 1097458175,
    saddlebrown: 2336560127,
    salmon: 4202722047,
    sandybrown: 4104413439,
    seagreen: 780883967,
    seashell: 4294307583,
    sienna: 2689740287,
    silver: 3233857791,
    skyblue: 2278484991,
    slateblue: 1784335871,
    slategray: 1887473919,
    slategrey: 1887473919,
    snow: 4294638335,
    springgreen: 16744447,
    steelblue: 1182971135,
    tan: 3535047935,
    teal: 8421631,
    thistle: 3636451583,
    tomato: 4284696575,
    turquoise: 1088475391,
    violet: 4001558271,
    wheat: 4125012991,
    white: 4294967295,
    whitesmoke: 4126537215,
    yellow: 4294902015,
    yellowgreen: 2597139199
  };
  var NUMBER = "[-+]?\\d*\\.?\\d+";
  var PERCENTAGE = NUMBER + "%";
  function call(...parts) {
    return "\\(\\s*(" + parts.join(")\\s*,\\s*(") + ")\\s*\\)";
  }
  var rgb = new RegExp("rgb" + call(NUMBER, NUMBER, NUMBER));
  var rgba = new RegExp("rgba" + call(NUMBER, NUMBER, NUMBER, NUMBER));
  var hsl = new RegExp("hsl" + call(NUMBER, PERCENTAGE, PERCENTAGE));
  var hsla = new RegExp(
    "hsla" + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER)
  );
  var hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  var hex4 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;
  var hex6 = /^#([0-9a-fA-F]{6})$/;
  var hex8 = /^#([0-9a-fA-F]{8})$/;
  function normalizeColor(color3) {
    let match2;
    if (typeof color3 === "number") {
      return color3 >>> 0 === color3 && color3 >= 0 && color3 <= 4294967295 ? color3 : null;
    }
    if (match2 = hex6.exec(color3))
      return parseInt(match2[1] + "ff", 16) >>> 0;
    if (colors && colors[color3] !== void 0) {
      return colors[color3];
    }
    if (match2 = rgb.exec(color3)) {
      return (parse255(match2[1]) << 24 | // r
      parse255(match2[2]) << 16 | // g
      parse255(match2[3]) << 8 | // b
      255) >>> // a
      0;
    }
    if (match2 = rgba.exec(color3)) {
      return (parse255(match2[1]) << 24 | // r
      parse255(match2[2]) << 16 | // g
      parse255(match2[3]) << 8 | // b
      parse1(match2[4])) >>> // a
      0;
    }
    if (match2 = hex3.exec(color3)) {
      return parseInt(
        match2[1] + match2[1] + // r
        match2[2] + match2[2] + // g
        match2[3] + match2[3] + // b
        "ff",
        // a
        16
      ) >>> 0;
    }
    if (match2 = hex8.exec(color3))
      return parseInt(match2[1], 16) >>> 0;
    if (match2 = hex4.exec(color3)) {
      return parseInt(
        match2[1] + match2[1] + // r
        match2[2] + match2[2] + // g
        match2[3] + match2[3] + // b
        match2[4] + match2[4],
        // a
        16
      ) >>> 0;
    }
    if (match2 = hsl.exec(color3)) {
      return (hslToRgb2(
        parse360(match2[1]),
        // h
        parsePercentage(match2[2]),
        // s
        parsePercentage(match2[3])
        // l
      ) | 255) >>> // a
      0;
    }
    if (match2 = hsla.exec(color3)) {
      return (hslToRgb2(
        parse360(match2[1]),
        // h
        parsePercentage(match2[2]),
        // s
        parsePercentage(match2[3])
        // l
      ) | parse1(match2[4])) >>> // a
      0;
    }
    return null;
  }
  function hue2rgb(p, q, t) {
    if (t < 0)
      t += 1;
    if (t > 1)
      t -= 1;
    if (t < 1 / 6)
      return p + (q - p) * 6 * t;
    if (t < 1 / 2)
      return q;
    if (t < 2 / 3)
      return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  }
  function hslToRgb2(h, s, l) {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    const r2 = hue2rgb(p, q, h + 1 / 3);
    const g = hue2rgb(p, q, h);
    const b = hue2rgb(p, q, h - 1 / 3);
    return Math.round(r2 * 255) << 24 | Math.round(g * 255) << 16 | Math.round(b * 255) << 8;
  }
  function parse255(str) {
    const int = parseInt(str, 10);
    if (int < 0)
      return 0;
    if (int > 255)
      return 255;
    return int;
  }
  function parse360(str) {
    const int = parseFloat(str);
    return (int % 360 + 360) % 360 / 360;
  }
  function parse1(str) {
    const num = parseFloat(str);
    if (num < 0)
      return 0;
    if (num > 1)
      return 255;
    return Math.round(num * 255);
  }
  function parsePercentage(str) {
    const int = parseFloat(str);
    if (int < 0)
      return 0;
    if (int > 100)
      return 1;
    return int / 100;
  }
  function colorToRgba(input) {
    let int32Color = normalizeColor(input);
    if (int32Color === null)
      return input;
    int32Color = int32Color || 0;
    const r2 = (int32Color & 4278190080) >>> 24;
    const g = (int32Color & 16711680) >>> 16;
    const b = (int32Color & 65280) >>> 8;
    const a = (int32Color & 255) / 255;
    return `rgba(${r2}, ${g}, ${b}, ${a})`;
  }
  var createInterpolator = (range2, output, extrapolate) => {
    if (is.fun(range2)) {
      return range2;
    }
    if (is.arr(range2)) {
      return createInterpolator({
        range: range2,
        output,
        extrapolate
      });
    }
    if (is.str(range2.output[0])) {
      return createStringInterpolator(range2);
    }
    const config2 = range2;
    const outputRange = config2.output;
    const inputRange = config2.range || [0, 1];
    const extrapolateLeft = config2.extrapolateLeft || config2.extrapolate || "extend";
    const extrapolateRight = config2.extrapolateRight || config2.extrapolate || "extend";
    const easing2 = config2.easing || ((t) => t);
    return (input) => {
      const range22 = findRange(input, inputRange);
      return interpolate(
        input,
        inputRange[range22],
        inputRange[range22 + 1],
        outputRange[range22],
        outputRange[range22 + 1],
        easing2,
        extrapolateLeft,
        extrapolateRight,
        config2.map
      );
    };
  };
  function interpolate(input, inputMin, inputMax, outputMin, outputMax, easing2, extrapolateLeft, extrapolateRight, map2) {
    let result = map2 ? map2(input) : input;
    if (result < inputMin) {
      if (extrapolateLeft === "identity")
        return result;
      else if (extrapolateLeft === "clamp")
        result = inputMin;
    }
    if (result > inputMax) {
      if (extrapolateRight === "identity")
        return result;
      else if (extrapolateRight === "clamp")
        result = inputMax;
    }
    if (outputMin === outputMax)
      return outputMin;
    if (inputMin === inputMax)
      return input <= inputMin ? outputMin : outputMax;
    if (inputMin === -Infinity)
      result = -result;
    else if (inputMax === Infinity)
      result = result - inputMin;
    else
      result = (result - inputMin) / (inputMax - inputMin);
    result = easing2(result);
    if (outputMin === -Infinity)
      result = -result;
    else if (outputMax === Infinity)
      result = result + outputMin;
    else
      result = result * (outputMax - outputMin) + outputMin;
    return result;
  }
  function findRange(input, inputRange) {
    for (var i = 1; i < inputRange.length - 1; ++i)
      if (inputRange[i] >= input)
        break;
    return i - 1;
  }
  var steps = (steps2, direction = "end") => (progress2) => {
    progress2 = direction === "end" ? Math.min(progress2, 0.999) : Math.max(progress2, 1e-3);
    const expanded = progress2 * steps2;
    const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
    return clamp2(0, 1, rounded / steps2);
  };
  var c1 = 1.70158;
  var c2 = c1 * 1.525;
  var c3 = c1 + 1;
  var c4 = 2 * Math.PI / 3;
  var c5 = 2 * Math.PI / 4.5;
  var bounceOut = (x) => {
    const n1 = 7.5625;
    const d1 = 2.75;
    if (x < 1 / d1) {
      return n1 * x * x;
    } else if (x < 2 / d1) {
      return n1 * (x -= 1.5 / d1) * x + 0.75;
    } else if (x < 2.5 / d1) {
      return n1 * (x -= 2.25 / d1) * x + 0.9375;
    } else {
      return n1 * (x -= 2.625 / d1) * x + 0.984375;
    }
  };
  var easings = {
    linear: (x) => x,
    easeInQuad: (x) => x * x,
    easeOutQuad: (x) => 1 - (1 - x) * (1 - x),
    easeInOutQuad: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
    easeInCubic: (x) => x * x * x,
    easeOutCubic: (x) => 1 - Math.pow(1 - x, 3),
    easeInOutCubic: (x) => x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2,
    easeInQuart: (x) => x * x * x * x,
    easeOutQuart: (x) => 1 - Math.pow(1 - x, 4),
    easeInOutQuart: (x) => x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2,
    easeInQuint: (x) => x * x * x * x * x,
    easeOutQuint: (x) => 1 - Math.pow(1 - x, 5),
    easeInOutQuint: (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2,
    easeInSine: (x) => 1 - Math.cos(x * Math.PI / 2),
    easeOutSine: (x) => Math.sin(x * Math.PI / 2),
    easeInOutSine: (x) => -(Math.cos(Math.PI * x) - 1) / 2,
    easeInExpo: (x) => x === 0 ? 0 : Math.pow(2, 10 * x - 10),
    easeOutExpo: (x) => x === 1 ? 1 : 1 - Math.pow(2, -10 * x),
    easeInOutExpo: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? Math.pow(2, 20 * x - 10) / 2 : (2 - Math.pow(2, -20 * x + 10)) / 2,
    easeInCirc: (x) => 1 - Math.sqrt(1 - Math.pow(x, 2)),
    easeOutCirc: (x) => Math.sqrt(1 - Math.pow(x - 1, 2)),
    easeInOutCirc: (x) => x < 0.5 ? (1 - Math.sqrt(1 - Math.pow(2 * x, 2))) / 2 : (Math.sqrt(1 - Math.pow(-2 * x + 2, 2)) + 1) / 2,
    easeInBack: (x) => c3 * x * x * x - c1 * x * x,
    easeOutBack: (x) => 1 + c3 * Math.pow(x - 1, 3) + c1 * Math.pow(x - 1, 2),
    easeInOutBack: (x) => x < 0.5 ? Math.pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2) / 2 : (Math.pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2,
    easeInElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : -Math.pow(2, 10 * x - 10) * Math.sin((x * 10 - 10.75) * c4),
    easeOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : Math.pow(2, -10 * x) * Math.sin((x * 10 - 0.75) * c4) + 1,
    easeInOutElastic: (x) => x === 0 ? 0 : x === 1 ? 1 : x < 0.5 ? -(Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5)) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1,
    easeInBounce: (x) => 1 - bounceOut(1 - x),
    easeOutBounce: bounceOut,
    easeInOutBounce: (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2,
    steps
  };
  var $get = Symbol.for("FluidValue.get");
  var $observers = Symbol.for("FluidValue.observers");
  var hasFluidValue = (arg2) => Boolean(arg2 && arg2[$get]);
  var getFluidValue = (arg2) => arg2 && arg2[$get] ? arg2[$get]() : arg2;
  var getFluidObservers = (target) => target[$observers] || null;
  function callFluidObserver(observer2, event) {
    if (observer2.eventObserved) {
      observer2.eventObserved(event);
    } else {
      observer2(event);
    }
  }
  function callFluidObservers(target, event) {
    const observers = target[$observers];
    if (observers) {
      observers.forEach((observer2) => {
        callFluidObserver(observer2, event);
      });
    }
  }
  var FluidValue = class {
    constructor(get) {
      if (!get && !(get = this.get)) {
        throw Error("Unknown getter");
      }
      setFluidGetter(this, get);
    }
  };
  var setFluidGetter = (target, get) => setHidden(target, $get, get);
  function addFluidObserver(target, observer2) {
    if (target[$get]) {
      let observers = target[$observers];
      if (!observers) {
        setHidden(target, $observers, observers = /* @__PURE__ */ new Set());
      }
      if (!observers.has(observer2)) {
        observers.add(observer2);
        if (target.observerAdded) {
          target.observerAdded(observers.size, observer2);
        }
      }
    }
    return observer2;
  }
  function removeFluidObserver(target, observer2) {
    const observers = target[$observers];
    if (observers && observers.has(observer2)) {
      const count = observers.size - 1;
      if (count) {
        observers.delete(observer2);
      } else {
        target[$observers] = null;
      }
      if (target.observerRemoved) {
        target.observerRemoved(count, observer2);
      }
    }
  }
  var setHidden = (target, key, value) => Object.defineProperty(target, key, {
    value,
    writable: true,
    configurable: true
  });
  var numberRegex = /[+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
  var colorRegex = /(#(?:[0-9a-f]{2}){2,4}|(#[0-9a-f]{3})|(rgb|hsl)a?\((-?\d+%?[,\s]+){2,3}\s*[\d\.]+%?\))/gi;
  var unitRegex = new RegExp(`(${numberRegex.source})(%|[a-z]+)`, "i");
  var rgbaRegex = /rgba\(([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+), ([0-9\.-]+)\)/gi;
  var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
  var variableToRgba = (input) => {
    const [token2, fallback] = parseCSSVariable(input);
    if (!token2 || isSSR()) {
      return input;
    }
    const value = window.getComputedStyle(document.documentElement).getPropertyValue(token2);
    if (value) {
      return value.trim();
    } else if (fallback && fallback.startsWith("--")) {
      const value2 = window.getComputedStyle(document.documentElement).getPropertyValue(fallback);
      if (value2) {
        return value2;
      } else {
        return input;
      }
    } else if (fallback && cssVariableRegex.test(fallback)) {
      return variableToRgba(fallback);
    } else if (fallback) {
      return fallback;
    }
    return input;
  };
  var parseCSSVariable = (current) => {
    const match2 = cssVariableRegex.exec(current);
    if (!match2)
      return [,];
    const [, token2, fallback] = match2;
    return [token2, fallback];
  };
  var namedColorRegex;
  var rgbaRound = (_2, p1, p2, p3, p4) => `rgba(${Math.round(p1)}, ${Math.round(p2)}, ${Math.round(p3)}, ${p4})`;
  var createStringInterpolator2 = (config2) => {
    if (!namedColorRegex)
      namedColorRegex = colors ? (
        // match color names, ignore partial matches
        new RegExp(`(${Object.keys(colors).join("|")})(?!\\w)`, "g")
      ) : (
        // never match
        /^\b$/
      );
    const output = config2.output.map((value) => {
      return getFluidValue(value).replace(cssVariableRegex, variableToRgba).replace(colorRegex, colorToRgba).replace(namedColorRegex, colorToRgba);
    });
    const keyframes2 = output.map((value) => value.match(numberRegex).map(Number));
    const outputRanges = keyframes2[0].map(
      (_2, i) => keyframes2.map((values3) => {
        if (!(i in values3)) {
          throw Error('The arity of each "output" value must be equal');
        }
        return values3[i];
      })
    );
    const interpolators = outputRanges.map(
      (output2) => createInterpolator(__spreadProps(__spreadValues({}, config2), { output: output2 }))
    );
    return (input) => {
      var _a;
      const missingUnit = !unitRegex.test(output[0]) && ((_a = output.find((value) => unitRegex.test(value))) == null ? void 0 : _a.replace(numberRegex, ""));
      let i = 0;
      return output[0].replace(
        numberRegex,
        () => `${interpolators[i++](input)}${missingUnit || ""}`
      ).replace(rgbaRegex, rgbaRound);
    };
  };
  var prefix2 = "react-spring: ";
  var once = (fn2) => {
    const func = fn2;
    let called = false;
    if (typeof func != "function") {
      throw new TypeError(`${prefix2}once requires a function parameter`);
    }
    return (...args) => {
      if (!called) {
        func(...args);
        called = true;
      }
    };
  };
  var warnInterpolate = once(console.warn);
  function deprecateInterpolate() {
    warnInterpolate(
      `${prefix2}The "interpolate" function is deprecated in v9 (use "to" instead)`
    );
  }
  var warnDirectCall = once(console.warn);
  function deprecateDirectCall() {
    warnDirectCall(
      `${prefix2}Directly calling start instead of using the api object is deprecated in v9 (use ".start" instead), this will be removed in later 0.X.0 versions`
    );
  }
  function isAnimatedString(value) {
    return is.str(value) && (value[0] == "#" || /\d/.test(value) || // Do not identify a CSS variable as an AnimatedString if its SSR
    !isSSR() && cssVariableRegex.test(value) || value in (colors || {}));
  }
  var useIsomorphicLayoutEffect = isSSR() ? import_react17.useEffect : import_react17.useLayoutEffect;
  var useIsMounted = () => {
    const isMounted = (0, import_react16.useRef)(false);
    useIsomorphicLayoutEffect(() => {
      isMounted.current = true;
      return () => {
        isMounted.current = false;
      };
    }, []);
    return isMounted;
  };
  function useForceUpdate() {
    const update3 = (0, import_react15.useState)()[1];
    const isMounted = useIsMounted();
    return () => {
      if (isMounted.current) {
        update3(Math.random());
      }
    };
  }
  function useMemoOne(getResult, inputs) {
    const [initial] = (0, import_react18.useState)(
      () => ({
        inputs,
        result: getResult()
      })
    );
    const committed = (0, import_react18.useRef)();
    const prevCache = committed.current;
    let cache = prevCache;
    if (cache) {
      const useCache = Boolean(
        inputs && cache.inputs && areInputsEqual(inputs, cache.inputs)
      );
      if (!useCache) {
        cache = {
          inputs,
          result: getResult()
        };
      }
    } else {
      cache = initial;
    }
    (0, import_react18.useEffect)(() => {
      committed.current = cache;
      if (prevCache == initial) {
        initial.inputs = initial.result = void 0;
      }
    }, [cache]);
    return cache.result;
  }
  function areInputsEqual(next2, prev2) {
    if (next2.length !== prev2.length) {
      return false;
    }
    for (let i = 0; i < next2.length; i++) {
      if (next2[i] !== prev2[i]) {
        return false;
      }
    }
    return true;
  }
  var useOnce = (effect4) => (0, import_react19.useEffect)(effect4, emptyDeps);
  var emptyDeps = [];
  function usePrev(value) {
    const prevRef = (0, import_react20.useRef)();
    (0, import_react20.useEffect)(() => {
      prevRef.current = value;
    });
    return prevRef.current;
  }

  // node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
  var import_react23 = __toESM(require_react(), 1);

  // node_modules/@react-spring/animated/dist/react-spring_animated.modern.mjs
  var React77 = __toESM(require_react(), 1);
  var import_react22 = __toESM(require_react(), 1);
  var $node = Symbol.for("Animated:node");
  var isAnimated = (value) => !!value && value[$node] === value;
  var getAnimated = (owner) => owner && owner[$node];
  var setAnimated = (owner, node2) => defineHidden(owner, $node, node2);
  var getPayload = (owner) => owner && owner[$node] && owner[$node].getPayload();
  var Animated = class {
    constructor() {
      setAnimated(this, this);
    }
    /** Get every `AnimatedValue` used by this node. */
    getPayload() {
      return this.payload || [];
    }
  };
  var AnimatedValue = class extends Animated {
    constructor(_value) {
      super();
      this._value = _value;
      this.done = true;
      this.durationProgress = 0;
      if (is.num(this._value)) {
        this.lastPosition = this._value;
      }
    }
    /** @internal */
    static create(value) {
      return new AnimatedValue(value);
    }
    getPayload() {
      return [this];
    }
    getValue() {
      return this._value;
    }
    setValue(value, step) {
      if (is.num(value)) {
        this.lastPosition = value;
        if (step) {
          value = Math.round(value / step) * step;
          if (this.done) {
            this.lastPosition = value;
          }
        }
      }
      if (this._value === value) {
        return false;
      }
      this._value = value;
      return true;
    }
    reset() {
      const { done } = this;
      this.done = false;
      if (is.num(this._value)) {
        this.elapsedTime = 0;
        this.durationProgress = 0;
        this.lastPosition = this._value;
        if (done)
          this.lastVelocity = null;
        this.v0 = null;
      }
    }
  };
  var AnimatedString = class extends AnimatedValue {
    constructor(value) {
      super(0);
      this._string = null;
      this._toString = createInterpolator({
        output: [value, value]
      });
    }
    /** @internal */
    static create(value) {
      return new AnimatedString(value);
    }
    getValue() {
      const value = this._string;
      return value == null ? this._string = this._toString(this._value) : value;
    }
    setValue(value) {
      if (is.str(value)) {
        if (value == this._string) {
          return false;
        }
        this._string = value;
        this._value = 1;
      } else if (super.setValue(value)) {
        this._string = null;
      } else {
        return false;
      }
      return true;
    }
    reset(goal) {
      if (goal) {
        this._toString = createInterpolator({
          output: [this.getValue(), goal]
        });
      }
      this._value = 0;
      super.reset();
    }
  };
  var TreeContext = { dependencies: null };
  var AnimatedObject = class extends Animated {
    constructor(source) {
      super();
      this.source = source;
      this.setValue(source);
    }
    getValue(animated2) {
      const values3 = {};
      eachProp(this.source, (source, key) => {
        if (isAnimated(source)) {
          values3[key] = source.getValue(animated2);
        } else if (hasFluidValue(source)) {
          values3[key] = getFluidValue(source);
        } else if (!animated2) {
          values3[key] = source;
        }
      });
      return values3;
    }
    /** Replace the raw object data */
    setValue(source) {
      this.source = source;
      this.payload = this._makePayload(source);
    }
    reset() {
      if (this.payload) {
        each(this.payload, (node2) => node2.reset());
      }
    }
    /** Create a payload set. */
    _makePayload(source) {
      if (source) {
        const payload = /* @__PURE__ */ new Set();
        eachProp(source, this._addToPayload, payload);
        return Array.from(payload);
      }
    }
    /** Add to a payload set. */
    _addToPayload(source) {
      if (TreeContext.dependencies && hasFluidValue(source)) {
        TreeContext.dependencies.add(source);
      }
      const payload = getPayload(source);
      if (payload) {
        each(payload, (node2) => this.add(node2));
      }
    }
  };
  var AnimatedArray = class extends AnimatedObject {
    constructor(source) {
      super(source);
    }
    /** @internal */
    static create(source) {
      return new AnimatedArray(source);
    }
    getValue() {
      return this.source.map((node2) => node2.getValue());
    }
    setValue(source) {
      const payload = this.getPayload();
      if (source.length == payload.length) {
        return payload.map((node2, i) => node2.setValue(source[i])).some(Boolean);
      }
      super.setValue(source.map(makeAnimated));
      return true;
    }
  };
  function makeAnimated(value) {
    const nodeType = isAnimatedString(value) ? AnimatedString : AnimatedValue;
    return nodeType.create(value);
  }
  function getAnimatedType(value) {
    const parentNode = getAnimated(value);
    return parentNode ? parentNode.constructor : is.arr(value) ? AnimatedArray : isAnimatedString(value) ? AnimatedString : AnimatedValue;
  }
  var withAnimated = (Component, host2) => {
    const hasInstance = (
      // Function components must use "forwardRef" to avoid being
      // re-rendered on every animation frame.
      !is.fun(Component) || Component.prototype && Component.prototype.isReactComponent
    );
    return (0, import_react22.forwardRef)((givenProps, givenRef) => {
      const instanceRef = (0, import_react22.useRef)(null);
      const ref = hasInstance && // eslint-disable-next-line react-hooks/rules-of-hooks
      (0, import_react22.useCallback)(
        (value) => {
          instanceRef.current = updateRef(givenRef, value);
        },
        [givenRef]
      );
      const [props, deps] = getAnimatedState(givenProps, host2);
      const forceUpdate = useForceUpdate();
      const callback = () => {
        const instance2 = instanceRef.current;
        if (hasInstance && !instance2) {
          return;
        }
        const didUpdate = instance2 ? host2.applyAnimatedValues(instance2, props.getValue(true)) : false;
        if (didUpdate === false) {
          forceUpdate();
        }
      };
      const observer = new PropsObserver(callback, deps);
      const observerRef = (0, import_react22.useRef)();
      useIsomorphicLayoutEffect(() => {
        observerRef.current = observer;
        each(deps, (dep) => addFluidObserver(dep, observer));
        return () => {
          if (observerRef.current) {
            each(
              observerRef.current.deps,
              (dep) => removeFluidObserver(dep, observerRef.current)
            );
            raf.cancel(observerRef.current.update);
          }
        };
      });
      (0, import_react22.useEffect)(callback, []);
      useOnce(() => () => {
        const observer2 = observerRef.current;
        each(observer2.deps, (dep) => removeFluidObserver(dep, observer2));
      });
      const usedProps = host2.getComponentProps(props.getValue());
      return /* @__PURE__ */ React77.createElement(Component, __spreadProps(__spreadValues({}, usedProps), { ref }));
    });
  };
  var PropsObserver = class {
    constructor(update3, deps) {
      this.update = update3;
      this.deps = deps;
    }
    eventObserved(event) {
      if (event.type == "change") {
        raf.write(this.update);
      }
    }
  };
  function getAnimatedState(props, host2) {
    const dependencies = /* @__PURE__ */ new Set();
    TreeContext.dependencies = dependencies;
    if (props.style)
      props = __spreadProps(__spreadValues({}, props), {
        style: host2.createAnimatedStyle(props.style)
      });
    props = new AnimatedObject(props);
    TreeContext.dependencies = null;
    return [props, dependencies];
  }
  function updateRef(ref, value) {
    if (ref) {
      if (is.fun(ref))
        ref(value);
      else
        ref.current = value;
    }
    return value;
  }
  var cacheKey = Symbol.for("AnimatedComponent");
  var createHost = (components, {
    applyAnimatedValues: applyAnimatedValues2 = () => false,
    createAnimatedStyle = (style4) => new AnimatedObject(style4),
    getComponentProps = (props) => props
  } = {}) => {
    const hostConfig = {
      applyAnimatedValues: applyAnimatedValues2,
      createAnimatedStyle,
      getComponentProps
    };
    const animated2 = (Component) => {
      const displayName = getDisplayName(Component) || "Anonymous";
      if (is.str(Component)) {
        Component = animated2[Component] || (animated2[Component] = withAnimated(Component, hostConfig));
      } else {
        Component = Component[cacheKey] || (Component[cacheKey] = withAnimated(Component, hostConfig));
      }
      Component.displayName = `Animated(${displayName})`;
      return Component;
    };
    eachProp(components, (Component, key) => {
      if (is.arr(components)) {
        key = getDisplayName(Component);
      }
      animated2[key] = animated2(Component);
    });
    return {
      animated: animated2
    };
  };
  var getDisplayName = (arg2) => is.str(arg2) ? arg2 : arg2 && is.str(arg2.displayName) ? arg2.displayName : is.fun(arg2) && arg2.name || null;

  // node_modules/@react-spring/core/dist/react-spring_core.modern.mjs
  var React78 = __toESM(require_react(), 1);
  var import_react24 = __toESM(require_react(), 1);
  var import_react25 = __toESM(require_react(), 1);
  var React210 = __toESM(require_react(), 1);
  var import_react26 = __toESM(require_react(), 1);
  var import_react27 = __toESM(require_react(), 1);
  function callProp(value, ...args) {
    return is.fun(value) ? value(...args) : value;
  }
  var matchProp = (value, key) => value === true || !!(key && value && (is.fun(value) ? value(key) : toArray(value).includes(key)));
  var resolveProp = (prop, key) => is.obj(prop) ? key && prop[key] : prop;
  var getDefaultProp = (props, key) => props.default === true ? props[key] : props.default ? props.default[key] : void 0;
  var noopTransform = (value) => value;
  var getDefaultProps = (props, transform = noopTransform) => {
    let keys = DEFAULT_PROPS;
    if (props.default && props.default !== true) {
      props = props.default;
      keys = Object.keys(props);
    }
    const defaults2 = {};
    for (const key of keys) {
      const value = transform(props[key], key);
      if (!is.und(value)) {
        defaults2[key] = value;
      }
    }
    return defaults2;
  };
  var DEFAULT_PROPS = [
    "config",
    "onProps",
    "onStart",
    "onChange",
    "onPause",
    "onResume",
    "onRest"
  ];
  var RESERVED_PROPS = {
    config: 1,
    from: 1,
    to: 1,
    ref: 1,
    loop: 1,
    reset: 1,
    pause: 1,
    cancel: 1,
    reverse: 1,
    immediate: 1,
    default: 1,
    delay: 1,
    onProps: 1,
    onStart: 1,
    onChange: 1,
    onPause: 1,
    onResume: 1,
    onRest: 1,
    onResolve: 1,
    // Transition props
    items: 1,
    trail: 1,
    sort: 1,
    expires: 1,
    initial: 1,
    enter: 1,
    update: 1,
    leave: 1,
    children: 1,
    onDestroyed: 1,
    // Internal props
    keys: 1,
    callId: 1,
    parentId: 1
  };
  function getForwardProps(props) {
    const forward = {};
    let count = 0;
    eachProp(props, (value, prop) => {
      if (!RESERVED_PROPS[prop]) {
        forward[prop] = value;
        count++;
      }
    });
    if (count) {
      return forward;
    }
  }
  function inferTo(props) {
    const to2 = getForwardProps(props);
    if (to2) {
      const out = { to: to2 };
      eachProp(props, (val, key) => key in to2 || (out[key] = val));
      return out;
    }
    return __spreadValues({}, props);
  }
  function computeGoal(value) {
    value = getFluidValue(value);
    return is.arr(value) ? value.map(computeGoal) : isAnimatedString(value) ? globals_exports.createStringInterpolator({
      range: [0, 1],
      output: [value, value]
    })(1) : value;
  }
  function hasProps(props) {
    for (const _2 in props)
      return true;
    return false;
  }
  function isAsyncTo(to2) {
    return is.fun(to2) || is.arr(to2) && is.obj(to2[0]);
  }
  function detachRefs(ctrl, ref) {
    var _a;
    (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
    ref == null ? void 0 : ref.delete(ctrl);
  }
  function replaceRef(ctrl, ref) {
    var _a;
    if (ref && ctrl.ref !== ref) {
      (_a = ctrl.ref) == null ? void 0 : _a.delete(ctrl);
      ref.add(ctrl);
      ctrl.ref = ref;
    }
  }
  var config = {
    default: { tension: 170, friction: 26 },
    gentle: { tension: 120, friction: 14 },
    wobbly: { tension: 180, friction: 12 },
    stiff: { tension: 210, friction: 20 },
    slow: { tension: 280, friction: 60 },
    molasses: { tension: 280, friction: 120 }
  };
  var defaults = __spreadProps(__spreadValues({}, config.default), {
    mass: 1,
    damping: 1,
    easing: easings.linear,
    clamp: false
  });
  var AnimationConfig = class {
    constructor() {
      this.velocity = 0;
      Object.assign(this, defaults);
    }
  };
  function mergeConfig(config2, newConfig, defaultConfig2) {
    if (defaultConfig2) {
      defaultConfig2 = __spreadValues({}, defaultConfig2);
      sanitizeConfig(defaultConfig2, newConfig);
      newConfig = __spreadValues(__spreadValues({}, defaultConfig2), newConfig);
    }
    sanitizeConfig(config2, newConfig);
    Object.assign(config2, newConfig);
    for (const key in defaults) {
      if (config2[key] == null) {
        config2[key] = defaults[key];
      }
    }
    let { frequency, damping } = config2;
    const { mass } = config2;
    if (!is.und(frequency)) {
      if (frequency < 0.01)
        frequency = 0.01;
      if (damping < 0)
        damping = 0;
      config2.tension = Math.pow(2 * Math.PI / frequency, 2) * mass;
      config2.friction = 4 * Math.PI * damping * mass / frequency;
    }
    return config2;
  }
  function sanitizeConfig(config2, props) {
    if (!is.und(props.decay)) {
      config2.duration = void 0;
    } else {
      const isTensionConfig = !is.und(props.tension) || !is.und(props.friction);
      if (isTensionConfig || !is.und(props.frequency) || !is.und(props.damping) || !is.und(props.mass)) {
        config2.duration = void 0;
        config2.decay = void 0;
      }
      if (isTensionConfig) {
        config2.frequency = void 0;
      }
    }
  }
  var emptyArray = [];
  var Animation = class {
    constructor() {
      this.changed = false;
      this.values = emptyArray;
      this.toValues = null;
      this.fromValues = emptyArray;
      this.config = new AnimationConfig();
      this.immediate = false;
    }
  };
  function scheduleProps(callId, { key, props, defaultProps: defaultProps4, state, actions }) {
    return new Promise((resolve, reject) => {
      var _a;
      let delay;
      let timeout2;
      let cancel = matchProp((_a = props.cancel) != null ? _a : defaultProps4 == null ? void 0 : defaultProps4.cancel, key);
      if (cancel) {
        onStart();
      } else {
        if (!is.und(props.pause)) {
          state.paused = matchProp(props.pause, key);
        }
        let pause = defaultProps4 == null ? void 0 : defaultProps4.pause;
        if (pause !== true) {
          pause = state.paused || matchProp(pause, key);
        }
        delay = callProp(props.delay || 0, key);
        if (pause) {
          state.resumeQueue.add(onResume);
          actions.pause();
        } else {
          actions.resume();
          onResume();
        }
      }
      function onPause() {
        state.resumeQueue.add(onResume);
        state.timeouts.delete(timeout2);
        timeout2.cancel();
        delay = timeout2.time - raf.now();
      }
      function onResume() {
        if (delay > 0 && !globals_exports.skipAnimation) {
          state.delayed = true;
          timeout2 = raf.setTimeout(onStart, delay);
          state.pauseQueue.add(onPause);
          state.timeouts.add(timeout2);
        } else {
          onStart();
        }
      }
      function onStart() {
        if (state.delayed) {
          state.delayed = false;
        }
        state.pauseQueue.delete(onPause);
        state.timeouts.delete(timeout2);
        if (callId <= (state.cancelId || 0)) {
          cancel = true;
        }
        try {
          actions.start(__spreadProps(__spreadValues({}, props), { callId, cancel }), resolve);
        } catch (err) {
          reject(err);
        }
      }
    });
  }
  var getCombinedResult = (target, results) => results.length == 1 ? results[0] : results.some((result) => result.cancelled) ? getCancelledResult(target.get()) : results.every((result) => result.noop) ? getNoopResult(target.get()) : getFinishedResult(
    target.get(),
    results.every((result) => result.finished)
  );
  var getNoopResult = (value) => ({
    value,
    noop: true,
    finished: true,
    cancelled: false
  });
  var getFinishedResult = (value, finished, cancelled = false) => ({
    value,
    finished,
    cancelled
  });
  var getCancelledResult = (value) => ({
    value,
    cancelled: true,
    finished: false
  });
  function runAsync(to2, props, state, target) {
    const { callId, parentId, onRest } = props;
    const { asyncTo: prevTo, promise: prevPromise } = state;
    if (!parentId && to2 === prevTo && !props.reset) {
      return prevPromise;
    }
    return state.promise = (async () => {
      state.asyncId = callId;
      state.asyncTo = to2;
      const defaultProps4 = getDefaultProps(
        props,
        (value, key) => (
          // The `onRest` prop is only called when the `runAsync` promise is resolved.
          key === "onRest" ? void 0 : value
        )
      );
      let preventBail;
      let bail;
      const bailPromise = new Promise(
        (resolve, reject) => (preventBail = resolve, bail = reject)
      );
      const bailIfEnded = (bailSignal) => {
        const bailResult = (
          // The `cancel` prop or `stop` method was used.
          callId <= (state.cancelId || 0) && getCancelledResult(target) || // The async `to` prop was replaced.
          callId !== state.asyncId && getFinishedResult(target, false)
        );
        if (bailResult) {
          bailSignal.result = bailResult;
          bail(bailSignal);
          throw bailSignal;
        }
      };
      const animate = (arg1, arg2) => {
        const bailSignal = new BailSignal();
        const skipAnimationSignal = new SkipAnimationSignal();
        return (async () => {
          if (globals_exports.skipAnimation) {
            stopAsync(state);
            skipAnimationSignal.result = getFinishedResult(target, false);
            bail(skipAnimationSignal);
            throw skipAnimationSignal;
          }
          bailIfEnded(bailSignal);
          const props2 = is.obj(arg1) ? __spreadValues({}, arg1) : __spreadProps(__spreadValues({}, arg2), { to: arg1 });
          props2.parentId = callId;
          eachProp(defaultProps4, (value, key) => {
            if (is.und(props2[key])) {
              props2[key] = value;
            }
          });
          const result2 = await target.start(props2);
          bailIfEnded(bailSignal);
          if (state.paused) {
            await new Promise((resume) => {
              state.resumeQueue.add(resume);
            });
          }
          return result2;
        })();
      };
      let result;
      if (globals_exports.skipAnimation) {
        stopAsync(state);
        return getFinishedResult(target, false);
      }
      try {
        let animating;
        if (is.arr(to2)) {
          animating = (async (queue) => {
            for (const props2 of queue) {
              await animate(props2);
            }
          })(to2);
        } else {
          animating = Promise.resolve(to2(animate, target.stop.bind(target)));
        }
        await Promise.all([animating.then(preventBail), bailPromise]);
        result = getFinishedResult(target.get(), true, false);
      } catch (err) {
        if (err instanceof BailSignal) {
          result = err.result;
        } else if (err instanceof SkipAnimationSignal) {
          result = err.result;
        } else {
          throw err;
        }
      } finally {
        if (callId == state.asyncId) {
          state.asyncId = parentId;
          state.asyncTo = parentId ? prevTo : void 0;
          state.promise = parentId ? prevPromise : void 0;
        }
      }
      if (is.fun(onRest)) {
        raf.batchedUpdates(() => {
          onRest(result, target, target.item);
        });
      }
      return result;
    })();
  }
  function stopAsync(state, cancelId) {
    flush(state.timeouts, (t) => t.cancel());
    state.pauseQueue.clear();
    state.resumeQueue.clear();
    state.asyncId = state.asyncTo = state.promise = void 0;
    if (cancelId)
      state.cancelId = cancelId;
  }
  var BailSignal = class extends Error {
    constructor() {
      super(
        "An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise."
      );
    }
  };
  var SkipAnimationSignal = class extends Error {
    constructor() {
      super("SkipAnimationSignal");
    }
  };
  var isFrameValue = (value) => value instanceof FrameValue;
  var nextId = 1;
  var FrameValue = class extends FluidValue {
    constructor() {
      super(...arguments);
      this.id = nextId++;
      this._priority = 0;
    }
    get priority() {
      return this._priority;
    }
    set priority(priority2) {
      if (this._priority != priority2) {
        this._priority = priority2;
        this._onPriorityChange(priority2);
      }
    }
    /** Get the current value */
    get() {
      const node2 = getAnimated(this);
      return node2 && node2.getValue();
    }
    /** Create a spring that maps our value to another value */
    to(...args) {
      return globals_exports.to(this, args);
    }
    /** @deprecated Use the `to` method instead. */
    interpolate(...args) {
      deprecateInterpolate();
      return globals_exports.to(this, args);
    }
    toJSON() {
      return this.get();
    }
    observerAdded(count) {
      if (count == 1)
        this._attach();
    }
    observerRemoved(count) {
      if (count == 0)
        this._detach();
    }
    /** Called when the first child is added. */
    _attach() {
    }
    /** Called when the last child is removed. */
    _detach() {
    }
    /** Tell our children about our new value */
    _onChange(value, idle = false) {
      callFluidObservers(this, {
        type: "change",
        parent: this,
        value,
        idle
      });
    }
    /** Tell our children about our new priority */
    _onPriorityChange(priority2) {
      if (!this.idle) {
        frameLoop.sort(this);
      }
      callFluidObservers(this, {
        type: "priority",
        parent: this,
        priority: priority2
      });
    }
  };
  var $P = Symbol.for("SpringPhase");
  var HAS_ANIMATED = 1;
  var IS_ANIMATING = 2;
  var IS_PAUSED = 4;
  var hasAnimated = (target) => (target[$P] & HAS_ANIMATED) > 0;
  var isAnimating = (target) => (target[$P] & IS_ANIMATING) > 0;
  var isPaused = (target) => (target[$P] & IS_PAUSED) > 0;
  var setActiveBit = (target, active) => active ? target[$P] |= IS_ANIMATING | HAS_ANIMATED : target[$P] &= ~IS_ANIMATING;
  var setPausedBit = (target, paused) => paused ? target[$P] |= IS_PAUSED : target[$P] &= ~IS_PAUSED;
  var SpringValue = class extends FrameValue {
    constructor(arg1, arg2) {
      super();
      this.animation = new Animation();
      this.defaultProps = {};
      this._state = {
        paused: false,
        delayed: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._pendingCalls = /* @__PURE__ */ new Set();
      this._lastCallId = 0;
      this._lastToId = 0;
      this._memoizedDuration = 0;
      if (!is.und(arg1) || !is.und(arg2)) {
        const props = is.obj(arg1) ? __spreadValues({}, arg1) : __spreadProps(__spreadValues({}, arg2), { from: arg1 });
        if (is.und(props.default)) {
          props.default = true;
        }
        this.start(props);
      }
    }
    /** Equals true when not advancing on each frame. */
    get idle() {
      return !(isAnimating(this) || this._state.asyncTo) || isPaused(this);
    }
    get goal() {
      return getFluidValue(this.animation.to);
    }
    get velocity() {
      const node2 = getAnimated(this);
      return node2 instanceof AnimatedValue ? node2.lastVelocity || 0 : node2.getPayload().map((node22) => node22.lastVelocity || 0);
    }
    /**
     * When true, this value has been animated at least once.
     */
    get hasAnimated() {
      return hasAnimated(this);
    }
    /**
     * When true, this value has an unfinished animation,
     * which is either active or paused.
     */
    get isAnimating() {
      return isAnimating(this);
    }
    /**
     * When true, all current and future animations are paused.
     */
    get isPaused() {
      return isPaused(this);
    }
    /**
     *
     *
     */
    get isDelayed() {
      return this._state.delayed;
    }
    /** Advance the current animation by a number of milliseconds */
    advance(dt) {
      let idle = true;
      let changed = false;
      const anim = this.animation;
      let { toValues } = anim;
      const { config: config2 } = anim;
      const payload = getPayload(anim.to);
      if (!payload && hasFluidValue(anim.to)) {
        toValues = toArray(getFluidValue(anim.to));
      }
      anim.values.forEach((node22, i) => {
        if (node22.done)
          return;
        const to2 = (
          // Animated strings always go from 0 to 1.
          node22.constructor == AnimatedString ? 1 : payload ? payload[i].lastPosition : toValues[i]
        );
        let finished = anim.immediate;
        let position2 = to2;
        if (!finished) {
          position2 = node22.lastPosition;
          if (config2.tension <= 0) {
            node22.done = true;
            return;
          }
          let elapsed = node22.elapsedTime += dt;
          const from2 = anim.fromValues[i];
          const v0 = node22.v0 != null ? node22.v0 : node22.v0 = is.arr(config2.velocity) ? config2.velocity[i] : config2.velocity;
          let velocity;
          const precision = config2.precision || (from2 == to2 ? 5e-3 : Math.min(1, Math.abs(to2 - from2) * 1e-3));
          if (!is.und(config2.duration)) {
            let p = 1;
            if (config2.duration > 0) {
              if (this._memoizedDuration !== config2.duration) {
                this._memoizedDuration = config2.duration;
                if (node22.durationProgress > 0) {
                  node22.elapsedTime = config2.duration * node22.durationProgress;
                  elapsed = node22.elapsedTime += dt;
                }
              }
              p = (config2.progress || 0) + elapsed / this._memoizedDuration;
              p = p > 1 ? 1 : p < 0 ? 0 : p;
              node22.durationProgress = p;
            }
            position2 = from2 + config2.easing(p) * (to2 - from2);
            velocity = (position2 - node22.lastPosition) / dt;
            finished = p == 1;
          } else if (config2.decay) {
            const decay = config2.decay === true ? 0.998 : config2.decay;
            const e = Math.exp(-(1 - decay) * elapsed);
            position2 = from2 + v0 / (1 - decay) * (1 - e);
            finished = Math.abs(node22.lastPosition - position2) <= precision;
            velocity = v0 * e;
          } else {
            velocity = node22.lastVelocity == null ? v0 : node22.lastVelocity;
            const restVelocity = config2.restVelocity || precision / 10;
            const bounceFactor = config2.clamp ? 0 : config2.bounce;
            const canBounce = !is.und(bounceFactor);
            const isGrowing = from2 == to2 ? node22.v0 > 0 : from2 < to2;
            let isMoving;
            let isBouncing = false;
            const step = 1;
            const numSteps = Math.ceil(dt / step);
            for (let n = 0; n < numSteps; ++n) {
              isMoving = Math.abs(velocity) > restVelocity;
              if (!isMoving) {
                finished = Math.abs(to2 - position2) <= precision;
                if (finished) {
                  break;
                }
              }
              if (canBounce) {
                isBouncing = position2 == to2 || position2 > to2 == isGrowing;
                if (isBouncing) {
                  velocity = -velocity * bounceFactor;
                  position2 = to2;
                }
              }
              const springForce = -config2.tension * 1e-6 * (position2 - to2);
              const dampingForce = -config2.friction * 1e-3 * velocity;
              const acceleration = (springForce + dampingForce) / config2.mass;
              velocity = velocity + acceleration * step;
              position2 = position2 + velocity * step;
            }
          }
          node22.lastVelocity = velocity;
          if (Number.isNaN(position2)) {
            console.warn(`Got NaN while animating:`, this);
            finished = true;
          }
        }
        if (payload && !payload[i].done) {
          finished = false;
        }
        if (finished) {
          node22.done = true;
        } else {
          idle = false;
        }
        if (node22.setValue(position2, config2.round)) {
          changed = true;
        }
      });
      const node2 = getAnimated(this);
      const currVal = node2.getValue();
      if (idle) {
        const finalVal = getFluidValue(anim.to);
        if ((currVal !== finalVal || changed) && !config2.decay) {
          node2.setValue(finalVal);
          this._onChange(finalVal);
        } else if (changed && config2.decay) {
          this._onChange(currVal);
        }
        this._stop();
      } else if (changed) {
        this._onChange(currVal);
      }
    }
    /** Set the current value, while stopping the current animation */
    set(value) {
      raf.batchedUpdates(() => {
        this._stop();
        this._focus(value);
        this._set(value);
      });
      return this;
    }
    /**
     * Freeze the active animation in time, as well as any updates merged
     * before `resume` is called.
     */
    pause() {
      this._update({ pause: true });
    }
    /** Resume the animation if paused. */
    resume() {
      this._update({ pause: false });
    }
    /** Skip to the end of the current animation. */
    finish() {
      if (isAnimating(this)) {
        const { to: to2, config: config2 } = this.animation;
        raf.batchedUpdates(() => {
          this._onStart();
          if (!config2.decay) {
            this._set(to2, false);
          }
          this._stop();
        });
      }
      return this;
    }
    /** Push props into the pending queue. */
    update(props) {
      const queue = this.queue || (this.queue = []);
      queue.push(props);
      return this;
    }
    start(to2, arg2) {
      let queue;
      if (!is.und(to2)) {
        queue = [is.obj(to2) ? to2 : __spreadProps(__spreadValues({}, arg2), { to: to2 })];
      } else {
        queue = this.queue || [];
        this.queue = [];
      }
      return Promise.all(
        queue.map((props) => {
          const up = this._update(props);
          return up;
        })
      ).then((results) => getCombinedResult(this, results));
    }
    /**
     * Stop the current animation, and cancel any delayed updates.
     *
     * Pass `true` to call `onRest` with `cancelled: true`.
     */
    stop(cancel) {
      const { to: to2 } = this.animation;
      this._focus(this.get());
      stopAsync(this._state, cancel && this._lastCallId);
      raf.batchedUpdates(() => this._stop(to2, cancel));
      return this;
    }
    /** Restart the animation. */
    reset() {
      this._update({ reset: true });
    }
    /** @internal */
    eventObserved(event) {
      if (event.type == "change") {
        this._start();
      } else if (event.type == "priority") {
        this.priority = event.priority + 1;
      }
    }
    /**
     * Parse the `to` and `from` range from the given `props` object.
     *
     * This also ensures the initial value is available to animated components
     * during the render phase.
     */
    _prepareNode(props) {
      const key = this.key || "";
      let { to: to2, from: from2 } = props;
      to2 = is.obj(to2) ? to2[key] : to2;
      if (to2 == null || isAsyncTo(to2)) {
        to2 = void 0;
      }
      from2 = is.obj(from2) ? from2[key] : from2;
      if (from2 == null) {
        from2 = void 0;
      }
      const range2 = { to: to2, from: from2 };
      if (!hasAnimated(this)) {
        if (props.reverse)
          [to2, from2] = [from2, to2];
        from2 = getFluidValue(from2);
        if (!is.und(from2)) {
          this._set(from2);
        } else if (!getAnimated(this)) {
          this._set(to2);
        }
      }
      return range2;
    }
    /** Every update is processed by this method before merging. */
    _update(_a, isLoop) {
      var props = __objRest(_a, []);
      const { key, defaultProps: defaultProps4 } = this;
      if (props.default)
        Object.assign(
          defaultProps4,
          getDefaultProps(
            props,
            (value, prop) => /^on/.test(prop) ? resolveProp(value, key) : value
          )
        );
      mergeActiveFn(this, props, "onProps");
      sendEvent(this, "onProps", props, this);
      const range2 = this._prepareNode(props);
      if (Object.isFrozen(this)) {
        throw Error(
          "Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?"
        );
      }
      const state = this._state;
      return scheduleProps(++this._lastCallId, {
        key,
        props,
        defaultProps: defaultProps4,
        state,
        actions: {
          pause: () => {
            if (!isPaused(this)) {
              setPausedBit(this, true);
              flushCalls(state.pauseQueue);
              sendEvent(
                this,
                "onPause",
                getFinishedResult(this, checkFinished(this, this.animation.to)),
                this
              );
            }
          },
          resume: () => {
            if (isPaused(this)) {
              setPausedBit(this, false);
              if (isAnimating(this)) {
                this._resume();
              }
              flushCalls(state.resumeQueue);
              sendEvent(
                this,
                "onResume",
                getFinishedResult(this, checkFinished(this, this.animation.to)),
                this
              );
            }
          },
          start: this._merge.bind(this, range2)
        }
      }).then((result) => {
        if (props.loop && result.finished && !(isLoop && result.noop)) {
          const nextProps = createLoopUpdate(props);
          if (nextProps) {
            return this._update(nextProps, true);
          }
        }
        return result;
      });
    }
    /** Merge props into the current animation */
    _merge(range2, props, resolve) {
      if (props.cancel) {
        this.stop(true);
        return resolve(getCancelledResult(this));
      }
      const hasToProp = !is.und(range2.to);
      const hasFromProp = !is.und(range2.from);
      if (hasToProp || hasFromProp) {
        if (props.callId > this._lastToId) {
          this._lastToId = props.callId;
        } else {
          return resolve(getCancelledResult(this));
        }
      }
      const { key, defaultProps: defaultProps4, animation: anim } = this;
      const { to: prevTo, from: prevFrom } = anim;
      let { to: to2 = prevTo, from: from2 = prevFrom } = range2;
      if (hasFromProp && !hasToProp && (!props.default || is.und(to2))) {
        to2 = from2;
      }
      if (props.reverse)
        [to2, from2] = [from2, to2];
      const hasFromChanged = !isEqual(from2, prevFrom);
      if (hasFromChanged) {
        anim.from = from2;
      }
      from2 = getFluidValue(from2);
      const hasToChanged = !isEqual(to2, prevTo);
      if (hasToChanged) {
        this._focus(to2);
      }
      const hasAsyncTo = isAsyncTo(props.to);
      const { config: config2 } = anim;
      const { decay, velocity } = config2;
      if (hasToProp || hasFromProp) {
        config2.velocity = 0;
      }
      if (props.config && !hasAsyncTo) {
        mergeConfig(
          config2,
          callProp(props.config, key),
          // Avoid calling the same "config" prop twice.
          props.config !== defaultProps4.config ? callProp(defaultProps4.config, key) : void 0
        );
      }
      let node2 = getAnimated(this);
      if (!node2 || is.und(to2)) {
        return resolve(getFinishedResult(this, true));
      }
      const reset = (
        // When `reset` is undefined, the `from` prop implies `reset: true`,
        // except for declarative updates. When `reset` is defined, there
        // must exist a value to animate from.
        is.und(props.reset) ? hasFromProp && !props.default : !is.und(from2) && matchProp(props.reset, key)
      );
      const value = reset ? from2 : this.get();
      const goal = computeGoal(to2);
      const isAnimatable = is.num(goal) || is.arr(goal) || isAnimatedString(goal);
      const immediate = !hasAsyncTo && (!isAnimatable || matchProp(defaultProps4.immediate || props.immediate, key));
      if (hasToChanged) {
        const nodeType = getAnimatedType(to2);
        if (nodeType !== node2.constructor) {
          if (immediate) {
            node2 = this._set(goal);
          } else
            throw Error(
              `Cannot animate between ${node2.constructor.name} and ${nodeType.name}, as the "to" prop suggests`
            );
        }
      }
      const goalType = node2.constructor;
      let started = hasFluidValue(to2);
      let finished = false;
      if (!started) {
        const hasValueChanged = reset || !hasAnimated(this) && hasFromChanged;
        if (hasToChanged || hasValueChanged) {
          finished = isEqual(computeGoal(value), goal);
          started = !finished;
        }
        if (!isEqual(anim.immediate, immediate) && !immediate || !isEqual(config2.decay, decay) || !isEqual(config2.velocity, velocity)) {
          started = true;
        }
      }
      if (finished && isAnimating(this)) {
        if (anim.changed && !reset) {
          started = true;
        } else if (!started) {
          this._stop(prevTo);
        }
      }
      if (!hasAsyncTo) {
        if (started || hasFluidValue(prevTo)) {
          anim.values = node2.getPayload();
          anim.toValues = hasFluidValue(to2) ? null : goalType == AnimatedString ? [1] : toArray(goal);
        }
        if (anim.immediate != immediate) {
          anim.immediate = immediate;
          if (!immediate && !reset) {
            this._set(prevTo);
          }
        }
        if (started) {
          const { onRest } = anim;
          each(ACTIVE_EVENTS, (type) => mergeActiveFn(this, props, type));
          const result = getFinishedResult(this, checkFinished(this, prevTo));
          flushCalls(this._pendingCalls, result);
          this._pendingCalls.add(resolve);
          if (anim.changed)
            raf.batchedUpdates(() => {
              var _a;
              anim.changed = !reset;
              onRest == null ? void 0 : onRest(result, this);
              if (reset) {
                callProp(defaultProps4.onRest, result);
              } else {
                (_a = anim.onStart) == null ? void 0 : _a.call(anim, result, this);
              }
            });
        }
      }
      if (reset) {
        this._set(value);
      }
      if (hasAsyncTo) {
        resolve(runAsync(props.to, props, this._state, this));
      } else if (started) {
        this._start();
      } else if (isAnimating(this) && !hasToChanged) {
        this._pendingCalls.add(resolve);
      } else {
        resolve(getNoopResult(value));
      }
    }
    /** Update the `animation.to` value, which might be a `FluidValue` */
    _focus(value) {
      const anim = this.animation;
      if (value !== anim.to) {
        if (getFluidObservers(this)) {
          this._detach();
        }
        anim.to = value;
        if (getFluidObservers(this)) {
          this._attach();
        }
      }
    }
    _attach() {
      let priority2 = 0;
      const { to: to2 } = this.animation;
      if (hasFluidValue(to2)) {
        addFluidObserver(to2, this);
        if (isFrameValue(to2)) {
          priority2 = to2.priority + 1;
        }
      }
      this.priority = priority2;
    }
    _detach() {
      const { to: to2 } = this.animation;
      if (hasFluidValue(to2)) {
        removeFluidObserver(to2, this);
      }
    }
    /**
     * Update the current value from outside the frameloop,
     * and return the `Animated` node.
     */
    _set(arg2, idle = true) {
      const value = getFluidValue(arg2);
      if (!is.und(value)) {
        const oldNode = getAnimated(this);
        if (!oldNode || !isEqual(value, oldNode.getValue())) {
          const nodeType = getAnimatedType(value);
          if (!oldNode || oldNode.constructor != nodeType) {
            setAnimated(this, nodeType.create(value));
          } else {
            oldNode.setValue(value);
          }
          if (oldNode) {
            raf.batchedUpdates(() => {
              this._onChange(value, idle);
            });
          }
        }
      }
      return getAnimated(this);
    }
    _onStart() {
      const anim = this.animation;
      if (!anim.changed) {
        anim.changed = true;
        sendEvent(
          this,
          "onStart",
          getFinishedResult(this, checkFinished(this, anim.to)),
          this
        );
      }
    }
    _onChange(value, idle) {
      if (!idle) {
        this._onStart();
        callProp(this.animation.onChange, value, this);
      }
      callProp(this.defaultProps.onChange, value, this);
      super._onChange(value, idle);
    }
    // This method resets the animation state (even if already animating) to
    // ensure the latest from/to range is used, and it also ensures this spring
    // is added to the frameloop.
    _start() {
      const anim = this.animation;
      getAnimated(this).reset(getFluidValue(anim.to));
      if (!anim.immediate) {
        anim.fromValues = anim.values.map((node2) => node2.lastPosition);
      }
      if (!isAnimating(this)) {
        setActiveBit(this, true);
        if (!isPaused(this)) {
          this._resume();
        }
      }
    }
    _resume() {
      if (globals_exports.skipAnimation) {
        this.finish();
      } else {
        frameLoop.start(this);
      }
    }
    /**
     * Exit the frameloop and notify `onRest` listeners.
     *
     * Always wrap `_stop` calls with `batchedUpdates`.
     */
    _stop(goal, cancel) {
      if (isAnimating(this)) {
        setActiveBit(this, false);
        const anim = this.animation;
        each(anim.values, (node2) => {
          node2.done = true;
        });
        if (anim.toValues) {
          anim.onChange = anim.onPause = anim.onResume = void 0;
        }
        callFluidObservers(this, {
          type: "idle",
          parent: this
        });
        const result = cancel ? getCancelledResult(this.get()) : getFinishedResult(this.get(), checkFinished(this, goal != null ? goal : anim.to));
        flushCalls(this._pendingCalls, result);
        if (anim.changed) {
          anim.changed = false;
          sendEvent(this, "onRest", result, this);
        }
      }
    }
  };
  function checkFinished(target, to2) {
    const goal = computeGoal(to2);
    const value = computeGoal(target.get());
    return isEqual(value, goal);
  }
  function createLoopUpdate(props, loop2 = props.loop, to2 = props.to) {
    const loopRet = callProp(loop2);
    if (loopRet) {
      const overrides = loopRet !== true && inferTo(loopRet);
      const reverse = (overrides || props).reverse;
      const reset = !overrides || overrides.reset;
      return createUpdate(__spreadValues(__spreadProps(__spreadValues({}, props), {
        loop: loop2,
        // Avoid updating default props when looping.
        default: false,
        // Never loop the `pause` prop.
        pause: void 0,
        // For the "reverse" prop to loop as expected, the "to" prop
        // must be undefined. The "reverse" prop is ignored when the
        // "to" prop is an array or function.
        to: !reverse || isAsyncTo(to2) ? to2 : void 0,
        // Ignore the "from" prop except on reset.
        from: reset ? props.from : void 0,
        reset
      }), overrides));
    }
  }
  function createUpdate(props) {
    const { to: to2, from: from2 } = props = inferTo(props);
    const keys = /* @__PURE__ */ new Set();
    if (is.obj(to2))
      findDefined(to2, keys);
    if (is.obj(from2))
      findDefined(from2, keys);
    props.keys = keys.size ? Array.from(keys) : null;
    return props;
  }
  function findDefined(values3, keys) {
    eachProp(values3, (value, key) => value != null && keys.add(key));
  }
  var ACTIVE_EVENTS = [
    "onStart",
    "onRest",
    "onChange",
    "onPause",
    "onResume"
  ];
  function mergeActiveFn(target, props, type) {
    target.animation[type] = props[type] !== getDefaultProp(props, type) ? resolveProp(props[type], target.key) : void 0;
  }
  function sendEvent(target, type, ...args) {
    var _a, _b, _c, _d;
    (_b = (_a = target.animation)[type]) == null ? void 0 : _b.call(_a, ...args);
    (_d = (_c = target.defaultProps)[type]) == null ? void 0 : _d.call(_c, ...args);
  }
  var BATCHED_EVENTS = ["onStart", "onChange", "onRest"];
  var nextId2 = 1;
  var Controller = class {
    constructor(props, flush3) {
      this.id = nextId2++;
      this.springs = {};
      this.queue = [];
      this._lastAsyncId = 0;
      this._active = /* @__PURE__ */ new Set();
      this._changed = /* @__PURE__ */ new Set();
      this._started = false;
      this._state = {
        paused: false,
        pauseQueue: /* @__PURE__ */ new Set(),
        resumeQueue: /* @__PURE__ */ new Set(),
        timeouts: /* @__PURE__ */ new Set()
      };
      this._events = {
        onStart: /* @__PURE__ */ new Map(),
        onChange: /* @__PURE__ */ new Map(),
        onRest: /* @__PURE__ */ new Map()
      };
      this._onFrame = this._onFrame.bind(this);
      if (flush3) {
        this._flush = flush3;
      }
      if (props) {
        this.start(__spreadValues({ default: true }, props));
      }
    }
    /**
     * Equals `true` when no spring values are in the frameloop, and
     * no async animation is currently active.
     */
    get idle() {
      return !this._state.asyncTo && Object.values(this.springs).every((spring) => {
        return spring.idle && !spring.isDelayed && !spring.isPaused;
      });
    }
    get item() {
      return this._item;
    }
    set item(item) {
      this._item = item;
    }
    /** Get the current values of our springs */
    get() {
      const values3 = {};
      this.each((spring, key) => values3[key] = spring.get());
      return values3;
    }
    /** Set the current values without animating. */
    set(values3) {
      for (const key in values3) {
        const value = values3[key];
        if (!is.und(value)) {
          this.springs[key].set(value);
        }
      }
    }
    /** Push an update onto the queue of each value. */
    update(props) {
      if (props) {
        this.queue.push(createUpdate(props));
      }
      return this;
    }
    /**
     * Start the queued animations for every spring, and resolve the returned
     * promise once all queued animations have finished or been cancelled.
     *
     * When you pass a queue (instead of nothing), that queue is used instead of
     * the queued animations added with the `update` method, which are left alone.
     */
    start(props) {
      let { queue } = this;
      if (props) {
        queue = toArray(props).map(createUpdate);
      } else {
        this.queue = [];
      }
      if (this._flush) {
        return this._flush(this, queue);
      }
      prepareKeys(this, queue);
      return flushUpdateQueue(this, queue);
    }
    /** @internal */
    stop(arg2, keys) {
      if (arg2 !== !!arg2) {
        keys = arg2;
      }
      if (keys) {
        const springs = this.springs;
        each(toArray(keys), (key) => springs[key].stop(!!arg2));
      } else {
        stopAsync(this._state, this._lastAsyncId);
        this.each((spring) => spring.stop(!!arg2));
      }
      return this;
    }
    /** Freeze the active animation in time */
    pause(keys) {
      if (is.und(keys)) {
        this.start({ pause: true });
      } else {
        const springs = this.springs;
        each(toArray(keys), (key) => springs[key].pause());
      }
      return this;
    }
    /** Resume the animation if paused. */
    resume(keys) {
      if (is.und(keys)) {
        this.start({ pause: false });
      } else {
        const springs = this.springs;
        each(toArray(keys), (key) => springs[key].resume());
      }
      return this;
    }
    /** Call a function once per spring value */
    each(iterator) {
      eachProp(this.springs, iterator);
    }
    /** @internal Called at the end of every animation frame */
    _onFrame() {
      const { onStart, onChange, onRest } = this._events;
      const active = this._active.size > 0;
      const changed = this._changed.size > 0;
      if (active && !this._started || changed && !this._started) {
        this._started = true;
        flush(onStart, ([onStart2, result]) => {
          result.value = this.get();
          onStart2(result, this, this._item);
        });
      }
      const idle = !active && this._started;
      const values3 = changed || idle && onRest.size ? this.get() : null;
      if (changed && onChange.size) {
        flush(onChange, ([onChange2, result]) => {
          result.value = values3;
          onChange2(result, this, this._item);
        });
      }
      if (idle) {
        this._started = false;
        flush(onRest, ([onRest2, result]) => {
          result.value = values3;
          onRest2(result, this, this._item);
        });
      }
    }
    /** @internal */
    eventObserved(event) {
      if (event.type == "change") {
        this._changed.add(event.parent);
        if (!event.idle) {
          this._active.add(event.parent);
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else
        return;
      raf.onFrame(this._onFrame);
    }
  };
  function flushUpdateQueue(ctrl, queue) {
    return Promise.all(queue.map((props) => flushUpdate(ctrl, props))).then(
      (results) => getCombinedResult(ctrl, results)
    );
  }
  async function flushUpdate(ctrl, props, isLoop) {
    const { keys, to: to2, from: from2, loop: loop2, onRest, onResolve } = props;
    const defaults2 = is.obj(props.default) && props.default;
    if (loop2) {
      props.loop = false;
    }
    if (to2 === false)
      props.to = null;
    if (from2 === false)
      props.from = null;
    const asyncTo = is.arr(to2) || is.fun(to2) ? to2 : void 0;
    if (asyncTo) {
      props.to = void 0;
      props.onRest = void 0;
      if (defaults2) {
        defaults2.onRest = void 0;
      }
    } else {
      each(BATCHED_EVENTS, (key) => {
        const handler = props[key];
        if (is.fun(handler)) {
          const queue = ctrl["_events"][key];
          props[key] = ({ finished, cancelled }) => {
            const result2 = queue.get(handler);
            if (result2) {
              if (!finished)
                result2.finished = false;
              if (cancelled)
                result2.cancelled = true;
            } else {
              queue.set(handler, {
                value: null,
                finished: finished || false,
                cancelled: cancelled || false
              });
            }
          };
          if (defaults2) {
            defaults2[key] = props[key];
          }
        }
      });
    }
    const state = ctrl["_state"];
    if (props.pause === !state.paused) {
      state.paused = props.pause;
      flushCalls(props.pause ? state.pauseQueue : state.resumeQueue);
    } else if (state.paused) {
      props.pause = true;
    }
    const promises = (keys || Object.keys(ctrl.springs)).map(
      (key) => ctrl.springs[key].start(props)
    );
    const cancel = props.cancel === true || getDefaultProp(props, "cancel") === true;
    if (asyncTo || cancel && state.asyncId) {
      promises.push(
        scheduleProps(++ctrl["_lastAsyncId"], {
          props,
          state,
          actions: {
            pause: noop5,
            resume: noop5,
            start(props2, resolve) {
              if (cancel) {
                stopAsync(state, ctrl["_lastAsyncId"]);
                resolve(getCancelledResult(ctrl));
              } else {
                props2.onRest = onRest;
                resolve(
                  runAsync(
                    asyncTo,
                    props2,
                    state,
                    ctrl
                  )
                );
              }
            }
          }
        })
      );
    }
    if (state.paused) {
      await new Promise((resume) => {
        state.resumeQueue.add(resume);
      });
    }
    const result = getCombinedResult(ctrl, await Promise.all(promises));
    if (loop2 && result.finished && !(isLoop && result.noop)) {
      const nextProps = createLoopUpdate(props, loop2, to2);
      if (nextProps) {
        prepareKeys(ctrl, [nextProps]);
        return flushUpdate(ctrl, nextProps, true);
      }
    }
    if (onResolve) {
      raf.batchedUpdates(() => onResolve(result, ctrl, ctrl.item));
    }
    return result;
  }
  function getSprings(ctrl, props) {
    const springs = __spreadValues({}, ctrl.springs);
    if (props) {
      each(toArray(props), (props2) => {
        if (is.und(props2.keys)) {
          props2 = createUpdate(props2);
        }
        if (!is.obj(props2.to)) {
          props2 = __spreadProps(__spreadValues({}, props2), { to: void 0 });
        }
        prepareSprings(springs, props2, (key) => {
          return createSpring(key);
        });
      });
    }
    setSprings(ctrl, springs);
    return springs;
  }
  function setSprings(ctrl, springs) {
    eachProp(springs, (spring, key) => {
      if (!ctrl.springs[key]) {
        ctrl.springs[key] = spring;
        addFluidObserver(spring, ctrl);
      }
    });
  }
  function createSpring(key, observer) {
    const spring = new SpringValue();
    spring.key = key;
    if (observer) {
      addFluidObserver(spring, observer);
    }
    return spring;
  }
  function prepareSprings(springs, props, create) {
    if (props.keys) {
      each(props.keys, (key) => {
        const spring = springs[key] || (springs[key] = create(key));
        spring["_prepareNode"](props);
      });
    }
  }
  function prepareKeys(ctrl, queue) {
    each(queue, (props) => {
      prepareSprings(ctrl.springs, props, (key) => {
        return createSpring(key, ctrl);
      });
    });
  }
  var SpringContext = (_a) => {
    var _b = _a, {
      children
    } = _b, props = __objRest(_b, [
      "children"
    ]);
    const inherited = (0, import_react24.useContext)(ctx);
    const pause = props.pause || !!inherited.pause, immediate = props.immediate || !!inherited.immediate;
    props = useMemoOne(() => ({ pause, immediate }), [pause, immediate]);
    const { Provider } = ctx;
    return /* @__PURE__ */ React78.createElement(Provider, { value: props }, children);
  };
  var ctx = makeContext(SpringContext, {});
  SpringContext.Provider = ctx.Provider;
  SpringContext.Consumer = ctx.Consumer;
  function makeContext(target, init) {
    Object.assign(target, React78.createContext(init));
    target.Provider._context = target;
    target.Consumer._context = target;
    return target;
  }
  var SpringRef = () => {
    const current = [];
    const SpringRef2 = function(props) {
      deprecateDirectCall();
      const results = [];
      each(current, (ctrl, i) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update22 = _getProps(props, ctrl, i);
          if (update22) {
            results.push(ctrl.start(update22));
          }
        }
      });
      return results;
    };
    SpringRef2.current = current;
    SpringRef2.add = function(ctrl) {
      if (!current.includes(ctrl)) {
        current.push(ctrl);
      }
    };
    SpringRef2.delete = function(ctrl) {
      const i = current.indexOf(ctrl);
      if (~i)
        current.splice(i, 1);
    };
    SpringRef2.pause = function() {
      each(current, (ctrl) => ctrl.pause(...arguments));
      return this;
    };
    SpringRef2.resume = function() {
      each(current, (ctrl) => ctrl.resume(...arguments));
      return this;
    };
    SpringRef2.set = function(values3) {
      each(current, (ctrl, i) => {
        const update22 = is.fun(values3) ? values3(i, ctrl) : values3;
        if (update22) {
          ctrl.set(update22);
        }
      });
    };
    SpringRef2.start = function(props) {
      const results = [];
      each(current, (ctrl, i) => {
        if (is.und(props)) {
          results.push(ctrl.start());
        } else {
          const update22 = this._getProps(props, ctrl, i);
          if (update22) {
            results.push(ctrl.start(update22));
          }
        }
      });
      return results;
    };
    SpringRef2.stop = function() {
      each(current, (ctrl) => ctrl.stop(...arguments));
      return this;
    };
    SpringRef2.update = function(props) {
      each(current, (ctrl, i) => ctrl.update(this._getProps(props, ctrl, i)));
      return this;
    };
    const _getProps = function(arg2, ctrl, index) {
      return is.fun(arg2) ? arg2(index, ctrl) : arg2;
    };
    SpringRef2._getProps = _getProps;
    return SpringRef2;
  };
  function useTransition(data, props, deps) {
    const propsFn = is.fun(props) && props;
    const {
      reset,
      sort,
      trail = 0,
      expires = true,
      exitBeforeEnter = false,
      onDestroyed,
      ref: propsRef,
      config: propsConfig
    } = propsFn ? propsFn() : props;
    const ref = (0, import_react26.useMemo)(
      () => propsFn || arguments.length == 3 ? SpringRef() : void 0,
      []
    );
    const items = toArray(data);
    const transitions = [];
    const usedTransitions = (0, import_react26.useRef)(null);
    const prevTransitions = reset ? null : usedTransitions.current;
    useIsomorphicLayoutEffect(() => {
      usedTransitions.current = transitions;
    });
    useOnce(() => {
      each(transitions, (t) => {
        ref == null ? void 0 : ref.add(t.ctrl);
        t.ctrl.ref = ref;
      });
      return () => {
        each(usedTransitions.current, (t) => {
          if (t.expired) {
            clearTimeout(t.expirationId);
          }
          detachRefs(t.ctrl, ref);
          t.ctrl.stop(true);
        });
      };
    });
    const keys = getKeys(items, propsFn ? propsFn() : props, prevTransitions);
    const expired = reset && usedTransitions.current || [];
    useIsomorphicLayoutEffect(
      () => each(expired, ({ ctrl, item, key }) => {
        detachRefs(ctrl, ref);
        callProp(onDestroyed, item, key);
      })
    );
    const reused = [];
    if (prevTransitions)
      each(prevTransitions, (t, i) => {
        if (t.expired) {
          clearTimeout(t.expirationId);
          expired.push(t);
        } else {
          i = reused[i] = keys.indexOf(t.key);
          if (~i)
            transitions[i] = t;
        }
      });
    each(items, (item, i) => {
      if (!transitions[i]) {
        transitions[i] = {
          key: keys[i],
          item,
          phase: "mount",
          ctrl: new Controller()
        };
        transitions[i].ctrl.item = item;
      }
    });
    if (reused.length) {
      let i = -1;
      const { leave } = propsFn ? propsFn() : props;
      each(reused, (keyIndex, prevIndex) => {
        const t = prevTransitions[prevIndex];
        if (~keyIndex) {
          i = transitions.indexOf(t);
          transitions[i] = __spreadProps(__spreadValues({}, t), { item: items[keyIndex] });
        } else if (leave) {
          transitions.splice(++i, 0, t);
        }
      });
    }
    if (is.fun(sort)) {
      transitions.sort((a, b) => sort(a.item, b.item));
    }
    let delay = -trail;
    const forceUpdate = useForceUpdate();
    const defaultProps4 = getDefaultProps(props);
    const changes = /* @__PURE__ */ new Map();
    const exitingTransitions = (0, import_react26.useRef)(/* @__PURE__ */ new Map());
    const forceChange = (0, import_react26.useRef)(false);
    each(transitions, (t, i) => {
      const key = t.key;
      const prevPhase = t.phase;
      const p = propsFn ? propsFn() : props;
      let to2;
      let phase;
      const propsDelay = callProp(p.delay || 0, key);
      if (prevPhase == "mount") {
        to2 = p.enter;
        phase = "enter";
      } else {
        const isLeave = keys.indexOf(key) < 0;
        if (prevPhase != "leave") {
          if (isLeave) {
            to2 = p.leave;
            phase = "leave";
          } else if (to2 = p.update) {
            phase = "update";
          } else
            return;
        } else if (!isLeave) {
          to2 = p.enter;
          phase = "enter";
        } else
          return;
      }
      to2 = callProp(to2, t.item, i);
      to2 = is.obj(to2) ? inferTo(to2) : { to: to2 };
      if (!to2.config) {
        const config2 = propsConfig || defaultProps4.config;
        to2.config = callProp(config2, t.item, i, phase);
      }
      delay += trail;
      const payload = __spreadValues(__spreadProps(__spreadValues({}, defaultProps4), {
        // we need to add our props.delay value you here.
        delay: propsDelay + delay,
        ref: propsRef,
        immediate: p.immediate,
        // This prevents implied resets.
        reset: false
      }), to2);
      if (phase == "enter" && is.und(payload.from)) {
        const p2 = propsFn ? propsFn() : props;
        const from2 = is.und(p2.initial) || prevTransitions ? p2.from : p2.initial;
        payload.from = callProp(from2, t.item, i);
      }
      const { onResolve } = payload;
      payload.onResolve = (result) => {
        callProp(onResolve, result);
        const transitions2 = usedTransitions.current;
        const t2 = transitions2.find((t3) => t3.key === key);
        if (!t2)
          return;
        if (result.cancelled && t2.phase != "update") {
          return;
        }
        if (t2.ctrl.idle) {
          const idle = transitions2.every((t3) => t3.ctrl.idle);
          if (t2.phase == "leave") {
            const expiry = callProp(expires, t2.item);
            if (expiry !== false) {
              const expiryMs = expiry === true ? 0 : expiry;
              t2.expired = true;
              if (!idle && expiryMs > 0) {
                if (expiryMs <= 2147483647)
                  t2.expirationId = setTimeout(forceUpdate, expiryMs);
                return;
              }
            }
          }
          if (idle && transitions2.some((t3) => t3.expired)) {
            exitingTransitions.current.delete(t2);
            if (exitBeforeEnter) {
              forceChange.current = true;
            }
            forceUpdate();
          }
        }
      };
      const springs = getSprings(t.ctrl, payload);
      if (phase === "leave" && exitBeforeEnter) {
        exitingTransitions.current.set(t, { phase, springs, payload });
      } else {
        changes.set(t, { phase, springs, payload });
      }
    });
    const context = (0, import_react26.useContext)(SpringContext);
    const prevContext = usePrev(context);
    const hasContext = context !== prevContext && hasProps(context);
    useIsomorphicLayoutEffect(() => {
      if (hasContext) {
        each(transitions, (t) => {
          t.ctrl.start({ default: context });
        });
      }
    }, [context]);
    each(changes, (_2, t) => {
      if (exitingTransitions.current.size) {
        const ind = transitions.findIndex((state) => state.key === t.key);
        transitions.splice(ind, 1);
      }
    });
    useIsomorphicLayoutEffect(
      () => {
        each(
          exitingTransitions.current.size ? exitingTransitions.current : changes,
          ({ phase, payload }, t) => {
            const { ctrl } = t;
            t.phase = phase;
            ref == null ? void 0 : ref.add(ctrl);
            if (hasContext && phase == "enter") {
              ctrl.start({ default: context });
            }
            if (payload) {
              replaceRef(ctrl, payload.ref);
              if ((ctrl.ref || ref) && !forceChange.current) {
                ctrl.update(payload);
              } else {
                ctrl.start(payload);
                if (forceChange.current) {
                  forceChange.current = false;
                }
              }
            }
          }
        );
      },
      reset ? void 0 : deps
    );
    const renderTransitions = (render) => /* @__PURE__ */ React210.createElement(React210.Fragment, null, transitions.map((t, i) => {
      const { springs } = changes.get(t) || t.ctrl;
      const elem = render(__spreadValues({}, springs), t.item, t, i);
      return elem && elem.type ? /* @__PURE__ */ React210.createElement(
        elem.type,
        __spreadProps(__spreadValues({}, elem.props), {
          key: is.str(t.key) || is.num(t.key) ? t.key : t.ctrl.id,
          ref: elem.ref
        })
      ) : elem;
    }));
    return ref ? [renderTransitions, ref] : renderTransitions;
  }
  var nextKey = 1;
  function getKeys(items, { key, keys = key }, prevTransitions) {
    if (keys === null) {
      const reused = /* @__PURE__ */ new Set();
      return items.map((item) => {
        const t = prevTransitions && prevTransitions.find(
          (t2) => t2.item === item && t2.phase !== "leave" && !reused.has(t2)
        );
        if (t) {
          reused.add(t);
          return t.key;
        }
        return nextKey++;
      });
    }
    return is.und(keys) ? items : is.fun(keys) ? items.map(keys) : toArray(keys);
  }
  var Interpolation = class extends FrameValue {
    constructor(source, args) {
      super();
      this.source = source;
      this.idle = true;
      this._active = /* @__PURE__ */ new Set();
      this.calc = createInterpolator(...args);
      const value = this._get();
      const nodeType = getAnimatedType(value);
      setAnimated(this, nodeType.create(value));
    }
    advance(_dt) {
      const value = this._get();
      const oldValue = this.get();
      if (!isEqual(value, oldValue)) {
        getAnimated(this).setValue(value);
        this._onChange(value, this.idle);
      }
      if (!this.idle && checkIdle(this._active)) {
        becomeIdle(this);
      }
    }
    _get() {
      const inputs = is.arr(this.source) ? this.source.map(getFluidValue) : toArray(getFluidValue(this.source));
      return this.calc(...inputs);
    }
    _start() {
      if (this.idle && !checkIdle(this._active)) {
        this.idle = false;
        each(getPayload(this), (node2) => {
          node2.done = false;
        });
        if (globals_exports.skipAnimation) {
          raf.batchedUpdates(() => this.advance());
          becomeIdle(this);
        } else {
          frameLoop.start(this);
        }
      }
    }
    // Observe our sources only when we're observed.
    _attach() {
      let priority2 = 1;
      each(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          addFluidObserver(source, this);
        }
        if (isFrameValue(source)) {
          if (!source.idle) {
            this._active.add(source);
          }
          priority2 = Math.max(priority2, source.priority + 1);
        }
      });
      this.priority = priority2;
      this._start();
    }
    // Stop observing our sources once we have no observers.
    _detach() {
      each(toArray(this.source), (source) => {
        if (hasFluidValue(source)) {
          removeFluidObserver(source, this);
        }
      });
      this._active.clear();
      becomeIdle(this);
    }
    /** @internal */
    eventObserved(event) {
      if (event.type == "change") {
        if (event.idle) {
          this.advance();
        } else {
          this._active.add(event.parent);
          this._start();
        }
      } else if (event.type == "idle") {
        this._active.delete(event.parent);
      } else if (event.type == "priority") {
        this.priority = toArray(this.source).reduce(
          (highest, parent) => Math.max(highest, (isFrameValue(parent) ? parent.priority : 0) + 1),
          0
        );
      }
    }
  };
  function isIdle(source) {
    return source.idle !== false;
  }
  function checkIdle(active) {
    return !active.size || Array.from(active).every(isIdle);
  }
  function becomeIdle(self2) {
    if (!self2.idle) {
      self2.idle = true;
      each(getPayload(self2), (node2) => {
        node2.done = true;
      });
      callFluidObservers(self2, {
        type: "idle",
        parent: self2
      });
    }
  }
  globals_exports.assign({
    createStringInterpolator: createStringInterpolator2,
    to: (source, args) => new Interpolation(source, args)
  });
  var update2 = frameLoop.advance;

  // node_modules/@react-spring/web/dist/react-spring_web.modern.mjs
  var import_react_dom2 = __toESM(require_react_dom(), 1);
  var isCustomPropRE = /^--/;
  function dangerousStyleValue(name, value) {
    if (value == null || typeof value === "boolean" || value === "")
      return "";
    if (typeof value === "number" && value !== 0 && !isCustomPropRE.test(name) && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]))
      return value + "px";
    return ("" + value).trim();
  }
  var attributeCache = {};
  function applyAnimatedValues(instance2, props) {
    if (!instance2.nodeType || !instance2.setAttribute) {
      return false;
    }
    const isFilterElement = instance2.nodeName === "filter" || instance2.parentNode && instance2.parentNode.nodeName === "filter";
    const _a = props, {
      className,
      style: style4,
      children,
      scrollTop,
      scrollLeft,
      viewBox
    } = _a, attributes = __objRest(_a, [
      "className",
      "style",
      "children",
      "scrollTop",
      "scrollLeft",
      "viewBox"
    ]);
    const values3 = Object.values(attributes);
    const names = Object.keys(attributes).map(
      (name) => isFilterElement || instance2.hasAttribute(name) ? name : attributeCache[name] || (attributeCache[name] = name.replace(
        /([A-Z])/g,
        // Attributes are written in dash case
        (n) => "-" + n.toLowerCase()
      ))
    );
    if (children !== void 0) {
      instance2.textContent = children;
    }
    for (const name in style4) {
      if (style4.hasOwnProperty(name)) {
        const value = dangerousStyleValue(name, style4[name]);
        if (isCustomPropRE.test(name)) {
          instance2.style.setProperty(name, value);
        } else {
          instance2.style[name] = value;
        }
      }
    }
    names.forEach((name, i) => {
      instance2.setAttribute(name, values3[i]);
    });
    if (className !== void 0) {
      instance2.className = className;
    }
    if (scrollTop !== void 0) {
      instance2.scrollTop = scrollTop;
    }
    if (scrollLeft !== void 0) {
      instance2.scrollLeft = scrollLeft;
    }
    if (viewBox !== void 0) {
      instance2.setAttribute("viewBox", viewBox);
    }
  }
  var isUnitlessNumber = {
    animationIterationCount: true,
    borderImageOutset: true,
    borderImageSlice: true,
    borderImageWidth: true,
    boxFlex: true,
    boxFlexGroup: true,
    boxOrdinalGroup: true,
    columnCount: true,
    columns: true,
    flex: true,
    flexGrow: true,
    flexPositive: true,
    flexShrink: true,
    flexNegative: true,
    flexOrder: true,
    gridRow: true,
    gridRowEnd: true,
    gridRowSpan: true,
    gridRowStart: true,
    gridColumn: true,
    gridColumnEnd: true,
    gridColumnSpan: true,
    gridColumnStart: true,
    fontWeight: true,
    lineClamp: true,
    lineHeight: true,
    opacity: true,
    order: true,
    orphans: true,
    tabSize: true,
    widows: true,
    zIndex: true,
    zoom: true,
    // SVG-related properties
    fillOpacity: true,
    floodOpacity: true,
    stopOpacity: true,
    strokeDasharray: true,
    strokeDashoffset: true,
    strokeMiterlimit: true,
    strokeOpacity: true,
    strokeWidth: true
  };
  var prefixKey = (prefix3, key) => prefix3 + key.charAt(0).toUpperCase() + key.substring(1);
  var prefixes = ["Webkit", "Ms", "Moz", "O"];
  isUnitlessNumber = Object.keys(isUnitlessNumber).reduce((acc, prop) => {
    prefixes.forEach((prefix3) => acc[prefixKey(prefix3, prop)] = acc[prop]);
    return acc;
  }, isUnitlessNumber);
  var domTransforms = /^(matrix|translate|scale|rotate|skew)/;
  var pxTransforms = /^(translate)/;
  var degTransforms = /^(rotate|skew)/;
  var addUnit = (value, unit2) => is.num(value) && value !== 0 ? value + unit2 : value;
  var isValueIdentity = (value, id) => is.arr(value) ? value.every((v) => isValueIdentity(v, id)) : is.num(value) ? value === id : parseFloat(value) === id;
  var AnimatedStyle = class extends AnimatedObject {
    constructor(_a) {
      var _b = _a, { x, y, z } = _b, style4 = __objRest(_b, ["x", "y", "z"]);
      const inputs = [];
      const transforms = [];
      if (x || y || z) {
        inputs.push([x || 0, y || 0, z || 0]);
        transforms.push((xyz) => [
          `translate3d(${xyz.map((v) => addUnit(v, "px")).join(",")})`,
          // prettier-ignore
          isValueIdentity(xyz, 0)
        ]);
      }
      eachProp(style4, (value, key) => {
        if (key === "transform") {
          inputs.push([value || ""]);
          transforms.push((transform) => [transform, transform === ""]);
        } else if (domTransforms.test(key)) {
          delete style4[key];
          if (is.und(value))
            return;
          const unit2 = pxTransforms.test(key) ? "px" : degTransforms.test(key) ? "deg" : "";
          inputs.push(toArray(value));
          transforms.push(
            key === "rotate3d" ? ([x2, y2, z2, deg]) => [
              `rotate3d(${x2},${y2},${z2},${addUnit(deg, unit2)})`,
              isValueIdentity(deg, 0)
            ] : (input) => [
              `${key}(${input.map((v) => addUnit(v, unit2)).join(",")})`,
              isValueIdentity(input, key.startsWith("scale") ? 1 : 0)
            ]
          );
        }
      });
      if (inputs.length) {
        style4.transform = new FluidTransform(inputs, transforms);
      }
      super(style4);
    }
  };
  var FluidTransform = class extends FluidValue {
    constructor(inputs, transforms) {
      super();
      this.inputs = inputs;
      this.transforms = transforms;
      this._value = null;
    }
    get() {
      return this._value || (this._value = this._get());
    }
    _get() {
      let transform = "";
      let identity2 = true;
      each(this.inputs, (input, i) => {
        const arg1 = getFluidValue(input[0]);
        const [t, id] = this.transforms[i](
          is.arr(arg1) ? arg1 : input.map(getFluidValue)
        );
        transform += " " + t;
        identity2 = identity2 && id;
      });
      return identity2 ? "none" : transform;
    }
    // Start observing our inputs once we have an observer.
    observerAdded(count) {
      if (count == 1)
        each(
          this.inputs,
          (input) => each(
            input,
            (value) => hasFluidValue(value) && addFluidObserver(value, this)
          )
        );
    }
    // Stop observing our inputs once we have no observers.
    observerRemoved(count) {
      if (count == 0)
        each(
          this.inputs,
          (input) => each(
            input,
            (value) => hasFluidValue(value) && removeFluidObserver(value, this)
          )
        );
    }
    eventObserved(event) {
      if (event.type == "change") {
        this._value = null;
      }
      callFluidObservers(this, event);
    }
  };
  var primitives = [
    "a",
    "abbr",
    "address",
    "area",
    "article",
    "aside",
    "audio",
    "b",
    "base",
    "bdi",
    "bdo",
    "big",
    "blockquote",
    "body",
    "br",
    "button",
    "canvas",
    "caption",
    "cite",
    "code",
    "col",
    "colgroup",
    "data",
    "datalist",
    "dd",
    "del",
    "details",
    "dfn",
    "dialog",
    "div",
    "dl",
    "dt",
    "em",
    "embed",
    "fieldset",
    "figcaption",
    "figure",
    "footer",
    "form",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "head",
    "header",
    "hgroup",
    "hr",
    "html",
    "i",
    "iframe",
    "img",
    "input",
    "ins",
    "kbd",
    "keygen",
    "label",
    "legend",
    "li",
    "link",
    "main",
    "map",
    "mark",
    "menu",
    "menuitem",
    "meta",
    "meter",
    "nav",
    "noscript",
    "object",
    "ol",
    "optgroup",
    "option",
    "output",
    "p",
    "param",
    "picture",
    "pre",
    "progress",
    "q",
    "rp",
    "rt",
    "ruby",
    "s",
    "samp",
    "script",
    "section",
    "select",
    "small",
    "source",
    "span",
    "strong",
    "style",
    "sub",
    "summary",
    "sup",
    "table",
    "tbody",
    "td",
    "textarea",
    "tfoot",
    "th",
    "thead",
    "time",
    "title",
    "tr",
    "track",
    "u",
    "ul",
    "var",
    "video",
    "wbr",
    // SVG
    "circle",
    "clipPath",
    "defs",
    "ellipse",
    "foreignObject",
    "g",
    "image",
    "line",
    "linearGradient",
    "mask",
    "path",
    "pattern",
    "polygon",
    "polyline",
    "radialGradient",
    "rect",
    "stop",
    "svg",
    "text",
    "tspan"
  ];
  globals_exports.assign({
    batchedUpdates: import_react_dom2.unstable_batchedUpdates,
    createStringInterpolator: createStringInterpolator2,
    colors: colors2
  });
  var host = createHost(primitives, {
    applyAnimatedValues,
    createAnimatedStyle: (style4) => new AnimatedStyle(style4),
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getComponentProps: (_a) => {
      var _b = _a, { scrollTop, scrollLeft } = _b, props = __objRest(_b, ["scrollTop", "scrollLeft"]);
      return props;
    }
  });
  var animated = host.animated;

  // node_modules/@mui/x-charts/context/CartesianProvider/CartesianProvider.js
  var React94 = __toESM(require_react());

  // node_modules/d3-array/src/ascending.js
  function ascending(a, b) {
    return a == null || b == null ? NaN : a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }

  // node_modules/d3-array/src/descending.js
  function descending(a, b) {
    return a == null || b == null ? NaN : b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  // node_modules/d3-array/src/bisector.js
  function bisector(f) {
    let compare1, compare2, delta;
    if (f.length !== 2) {
      compare1 = ascending;
      compare2 = (d, x) => ascending(f(d), x);
      delta = (d, x) => f(d) - x;
    } else {
      compare1 = f === ascending || f === descending ? f : zero;
      compare2 = f;
      delta = f;
    }
    function left2(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0) return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x) < 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function right2(a, x, lo = 0, hi = a.length) {
      if (lo < hi) {
        if (compare1(x, x) !== 0) return hi;
        do {
          const mid = lo + hi >>> 1;
          if (compare2(a[mid], x) <= 0) lo = mid + 1;
          else hi = mid;
        } while (lo < hi);
      }
      return lo;
    }
    function center(a, x, lo = 0, hi = a.length) {
      const i = left2(a, x, lo, hi - 1);
      return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;
    }
    return { left: left2, center, right: right2 };
  }
  function zero() {
    return 0;
  }

  // node_modules/d3-array/src/number.js
  function number(x) {
    return x === null ? NaN : +x;
  }

  // node_modules/d3-array/src/bisect.js
  var ascendingBisect = bisector(ascending);
  var bisectRight = ascendingBisect.right;
  var bisectLeft = ascendingBisect.left;
  var bisectCenter = bisector(number).center;
  var bisect_default = bisectRight;

  // node_modules/internmap/src/index.js
  var InternMap = class extends Map {
    constructor(entries, key = keyof) {
      super();
      Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
      if (entries != null) for (const [key2, value] of entries) this.set(key2, value);
    }
    get(key) {
      return super.get(intern_get(this, key));
    }
    has(key) {
      return super.has(intern_get(this, key));
    }
    set(key, value) {
      return super.set(intern_set(this, key), value);
    }
    delete(key) {
      return super.delete(intern_delete(this, key));
    }
  };
  function intern_get({ _intern, _key }, value) {
    const key = _key(value);
    return _intern.has(key) ? _intern.get(key) : value;
  }
  function intern_set({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) return _intern.get(key);
    _intern.set(key, value);
    return value;
  }
  function intern_delete({ _intern, _key }, value) {
    const key = _key(value);
    if (_intern.has(key)) {
      value = _intern.get(key);
      _intern.delete(key);
    }
    return value;
  }
  function keyof(value) {
    return value !== null && typeof value === "object" ? value.valueOf() : value;
  }

  // node_modules/d3-array/src/ticks.js
  var e10 = Math.sqrt(50);
  var e5 = Math.sqrt(10);
  var e2 = Math.sqrt(2);
  function tickSpec(start3, stop2, count) {
    const step = (stop2 - start3) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
    let i1, i2, inc;
    if (power < 0) {
      inc = Math.pow(10, -power) / factor;
      i1 = Math.round(start3 * inc);
      i2 = Math.round(stop2 * inc);
      if (i1 / inc < start3) ++i1;
      if (i2 / inc > stop2) --i2;
      inc = -inc;
    } else {
      inc = Math.pow(10, power) * factor;
      i1 = Math.round(start3 / inc);
      i2 = Math.round(stop2 / inc);
      if (i1 * inc < start3) ++i1;
      if (i2 * inc > stop2) --i2;
    }
    if (i2 < i1 && 0.5 <= count && count < 2) return tickSpec(start3, stop2, count * 2);
    return [i1, i2, inc];
  }
  function ticks(start3, stop2, count) {
    stop2 = +stop2, start3 = +start3, count = +count;
    if (!(count > 0)) return [];
    if (start3 === stop2) return [start3];
    const reverse = stop2 < start3, [i1, i2, inc] = reverse ? tickSpec(stop2, start3, count) : tickSpec(start3, stop2, count);
    if (!(i2 >= i1)) return [];
    const n = i2 - i1 + 1, ticks2 = new Array(n);
    if (reverse) {
      if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) / -inc;
      else for (let i = 0; i < n; ++i) ticks2[i] = (i2 - i) * inc;
    } else {
      if (inc < 0) for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) / -inc;
      else for (let i = 0; i < n; ++i) ticks2[i] = (i1 + i) * inc;
    }
    return ticks2;
  }
  function tickIncrement(start3, stop2, count) {
    stop2 = +stop2, start3 = +start3, count = +count;
    return tickSpec(start3, stop2, count)[2];
  }
  function tickStep(start3, stop2, count) {
    stop2 = +stop2, start3 = +start3, count = +count;
    const reverse = stop2 < start3, inc = reverse ? tickIncrement(stop2, start3, count) : tickIncrement(start3, stop2, count);
    return (reverse ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
  }

  // node_modules/d3-array/src/range.js
  function range(start3, stop2, step) {
    start3 = +start3, stop2 = +stop2, step = (n = arguments.length) < 2 ? (stop2 = start3, start3 = 0, 1) : n < 3 ? 1 : +step;
    var i = -1, n = Math.max(0, Math.ceil((stop2 - start3) / step)) | 0, range2 = new Array(n);
    while (++i < n) {
      range2[i] = start3 + i * step;
    }
    return range2;
  }

  // node_modules/d3-scale/src/init.js
  function initRange(domain, range2) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(domain);
        break;
      default:
        this.range(range2).domain(domain);
        break;
    }
    return this;
  }
  function initInterpolator(domain, interpolator) {
    switch (arguments.length) {
      case 0:
        break;
      case 1: {
        if (typeof domain === "function") this.interpolator(domain);
        else this.range(domain);
        break;
      }
      default: {
        this.domain(domain);
        if (typeof interpolator === "function") this.interpolator(interpolator);
        else this.range(interpolator);
        break;
      }
    }
    return this;
  }

  // node_modules/d3-scale/src/ordinal.js
  var implicit = Symbol("implicit");
  function ordinal() {
    var index = new InternMap(), domain = [], range2 = [], unknown = implicit;
    function scale(d) {
      let i = index.get(d);
      if (i === void 0) {
        if (unknown !== implicit) return unknown;
        index.set(d, i = domain.push(d) - 1);
      }
      return range2[i % range2.length];
    }
    scale.domain = function(_2) {
      if (!arguments.length) return domain.slice();
      domain = [], index = new InternMap();
      for (const value of _2) {
        if (index.has(value)) continue;
        index.set(value, domain.push(value) - 1);
      }
      return scale;
    };
    scale.range = function(_2) {
      return arguments.length ? (range2 = Array.from(_2), scale) : range2.slice();
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    scale.copy = function() {
      return ordinal(domain, range2).unknown(unknown);
    };
    initRange.apply(scale, arguments);
    return scale;
  }

  // node_modules/d3-scale/src/band.js
  function band() {
    var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, r0 = 0, r1 = 1, step, bandwidth, round3 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
    delete scale.unknown;
    function rescale() {
      var n = domain().length, reverse = r1 < r0, start3 = reverse ? r1 : r0, stop2 = reverse ? r0 : r1;
      step = (stop2 - start3) / Math.max(1, n - paddingInner + paddingOuter * 2);
      if (round3) step = Math.floor(step);
      start3 += (stop2 - start3 - step * (n - paddingInner)) * align;
      bandwidth = step * (1 - paddingInner);
      if (round3) start3 = Math.round(start3), bandwidth = Math.round(bandwidth);
      var values3 = range(n).map(function(i) {
        return start3 + step * i;
      });
      return ordinalRange(reverse ? values3.reverse() : values3);
    }
    scale.domain = function(_2) {
      return arguments.length ? (domain(_2), rescale()) : domain();
    };
    scale.range = function(_2) {
      return arguments.length ? ([r0, r1] = _2, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
    };
    scale.rangeRound = function(_2) {
      return [r0, r1] = _2, r0 = +r0, r1 = +r1, round3 = true, rescale();
    };
    scale.bandwidth = function() {
      return bandwidth;
    };
    scale.step = function() {
      return step;
    };
    scale.round = function(_2) {
      return arguments.length ? (round3 = !!_2, rescale()) : round3;
    };
    scale.padding = function(_2) {
      return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_2), rescale()) : paddingInner;
    };
    scale.paddingInner = function(_2) {
      return arguments.length ? (paddingInner = Math.min(1, _2), rescale()) : paddingInner;
    };
    scale.paddingOuter = function(_2) {
      return arguments.length ? (paddingOuter = +_2, rescale()) : paddingOuter;
    };
    scale.align = function(_2) {
      return arguments.length ? (align = Math.max(0, Math.min(1, _2)), rescale()) : align;
    };
    scale.copy = function() {
      return band(domain(), [r0, r1]).round(round3).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
    };
    return initRange.apply(rescale(), arguments);
  }
  function pointish(scale) {
    var copy4 = scale.copy;
    scale.padding = scale.paddingOuter;
    delete scale.paddingInner;
    delete scale.paddingOuter;
    scale.copy = function() {
      return pointish(copy4());
    };
    return scale;
  }
  function point() {
    return pointish(band.apply(null, arguments).paddingInner(1));
  }

  // node_modules/d3-color/src/define.js
  function define_default(constructor, factory, prototype) {
    constructor.prototype = factory.prototype = prototype;
    prototype.constructor = constructor;
  }
  function extend(parent, definition) {
    var prototype = Object.create(parent.prototype);
    for (var key in definition) prototype[key] = definition[key];
    return prototype;
  }

  // node_modules/d3-color/src/color.js
  function Color2() {
  }
  var darker = 0.7;
  var brighter = 1 / darker;
  var reI = "\\s*([+-]?\\d+)\\s*";
  var reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*";
  var reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*";
  var reHex = /^#([0-9a-f]{3,8})$/;
  var reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`);
  var reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`);
  var reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`);
  var reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`);
  var reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`);
  var reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
  var named = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  define_default(Color2, color2, {
    copy(channels) {
      return Object.assign(new this.constructor(), this, channels);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: color_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: color_formatHex,
    formatHex8: color_formatHex8,
    formatHsl: color_formatHsl,
    formatRgb: color_formatRgb,
    toString: color_formatRgb
  });
  function color_formatHex() {
    return this.rgb().formatHex();
  }
  function color_formatHex8() {
    return this.rgb().formatHex8();
  }
  function color_formatHsl() {
    return hslConvert(this).formatHsl();
  }
  function color_formatRgb() {
    return this.rgb().formatRgb();
  }
  function color2(format2) {
    var m, l;
    format2 = (format2 + "").trim().toLowerCase();
    return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba2(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba2(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba2(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba2(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla2(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla2(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
  }
  function rgbn(n) {
    return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function rgba2(r2, g, b, a) {
    if (a <= 0) r2 = g = b = NaN;
    return new Rgb(r2, g, b, a);
  }
  function rgbConvert(o) {
    if (!(o instanceof Color2)) o = color2(o);
    if (!o) return new Rgb();
    o = o.rgb();
    return new Rgb(o.r, o.g, o.b, o.opacity);
  }
  function rgb2(r2, g, b, opacity) {
    return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g, b, opacity == null ? 1 : opacity);
  }
  function Rgb(r2, g, b, opacity) {
    this.r = +r2;
    this.g = +g;
    this.b = +b;
    this.opacity = +opacity;
  }
  define_default(Rgb, rgb2, extend(Color2, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
    },
    hex: rgb_formatHex,
    // Deprecated! Use color.formatHex.
    formatHex: rgb_formatHex,
    formatHex8: rgb_formatHex8,
    formatRgb: rgb_formatRgb,
    toString: rgb_formatRgb
  }));
  function rgb_formatHex() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
  }
  function rgb_formatHex8() {
    return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function rgb_formatRgb() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
  }
  function clampa(opacity) {
    return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
  }
  function clampi(value) {
    return Math.max(0, Math.min(255, Math.round(value) || 0));
  }
  function hex(value) {
    value = clampi(value);
    return (value < 16 ? "0" : "") + value.toString(16);
  }
  function hsla2(h, s, l, a) {
    if (a <= 0) h = s = l = NaN;
    else if (l <= 0 || l >= 1) h = s = NaN;
    else if (s <= 0) h = NaN;
    return new Hsl(h, s, l, a);
  }
  function hslConvert(o) {
    if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
    if (!(o instanceof Color2)) o = color2(o);
    if (!o) return new Hsl();
    if (o instanceof Hsl) return o;
    o = o.rgb();
    var r2 = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r2, g, b), max2 = Math.max(r2, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
    if (s) {
      if (r2 === max2) h = (g - b) / s + (g < b) * 6;
      else if (g === max2) h = (b - r2) / s + 2;
      else h = (r2 - g) / s + 4;
      s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
      h *= 60;
    } else {
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new Hsl(h, s, l, o.opacity);
  }
  function hsl2(h, s, l, opacity) {
    return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
  }
  function Hsl(h, s, l, opacity) {
    this.h = +h;
    this.s = +s;
    this.l = +l;
    this.opacity = +opacity;
  }
  define_default(Hsl, hsl2, extend(Color2, {
    brighter(k) {
      k = k == null ? brighter : Math.pow(brighter, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    darker(k) {
      k = k == null ? darker : Math.pow(darker, k);
      return new Hsl(this.h, this.s, this.l * k, this.opacity);
    },
    rgb() {
      var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
      return new Rgb(
        hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
        hsl2rgb(h, m1, m2),
        hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
        this.opacity
      );
    },
    clamp() {
      return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
    },
    formatHsl() {
      const a = clampa(this.opacity);
      return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
    }
  }));
  function clamph(value) {
    value = (value || 0) % 360;
    return value < 0 ? value + 360 : value;
  }
  function clampt(value) {
    return Math.max(0, Math.min(1, value || 0));
  }
  function hsl2rgb(h, m1, m2) {
    return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
  }

  // node_modules/d3-interpolate/src/basis.js
  function basis(t12, v0, v1, v2, v3) {
    var t2 = t12 * t12, t3 = t2 * t12;
    return ((1 - 3 * t12 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t12 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
  }
  function basis_default(values3) {
    var n = values3.length - 1;
    return function(t) {
      var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values3[i], v2 = values3[i + 1], v0 = i > 0 ? values3[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values3[i + 2] : 2 * v2 - v1;
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/basisClosed.js
  function basisClosed_default(values3) {
    var n = values3.length;
    return function(t) {
      var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values3[(i + n - 1) % n], v1 = values3[i % n], v2 = values3[(i + 1) % n], v3 = values3[(i + 2) % n];
      return basis((t - i / n) * n, v0, v1, v2, v3);
    };
  }

  // node_modules/d3-interpolate/src/constant.js
  var constant_default = (x) => () => x;

  // node_modules/d3-interpolate/src/color.js
  function linear(a, d) {
    return function(t) {
      return a + t * d;
    };
  }
  function exponential(a, b, y) {
    return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
      return Math.pow(a + t * b, y);
    };
  }
  function gamma(y) {
    return (y = +y) === 1 ? nogamma : function(a, b) {
      return b - a ? exponential(a, b, y) : constant_default(isNaN(a) ? b : a);
    };
  }
  function nogamma(a, b) {
    var d = b - a;
    return d ? linear(a, d) : constant_default(isNaN(a) ? b : a);
  }

  // node_modules/d3-interpolate/src/rgb.js
  var rgb_default = function rgbGamma(y) {
    var color3 = gamma(y);
    function rgb3(start3, end2) {
      var r2 = color3((start3 = rgb2(start3)).r, (end2 = rgb2(end2)).r), g = color3(start3.g, end2.g), b = color3(start3.b, end2.b), opacity = nogamma(start3.opacity, end2.opacity);
      return function(t) {
        start3.r = r2(t);
        start3.g = g(t);
        start3.b = b(t);
        start3.opacity = opacity(t);
        return start3 + "";
      };
    }
    rgb3.gamma = rgbGamma;
    return rgb3;
  }(1);
  function rgbSpline(spline) {
    return function(colors3) {
      var n = colors3.length, r2 = new Array(n), g = new Array(n), b = new Array(n), i, color3;
      for (i = 0; i < n; ++i) {
        color3 = rgb2(colors3[i]);
        r2[i] = color3.r || 0;
        g[i] = color3.g || 0;
        b[i] = color3.b || 0;
      }
      r2 = spline(r2);
      g = spline(g);
      b = spline(b);
      color3.opacity = 1;
      return function(t) {
        color3.r = r2(t);
        color3.g = g(t);
        color3.b = b(t);
        return color3 + "";
      };
    };
  }
  var rgbBasis = rgbSpline(basis_default);
  var rgbBasisClosed = rgbSpline(basisClosed_default);

  // node_modules/d3-interpolate/src/numberArray.js
  function numberArray_default(a, b) {
    if (!b) b = [];
    var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
    return function(t) {
      for (i = 0; i < n; ++i) c[i] = a[i] * (1 - t) + b[i] * t;
      return c;
    };
  }
  function isNumberArray(x) {
    return ArrayBuffer.isView(x) && !(x instanceof DataView);
  }

  // node_modules/d3-interpolate/src/array.js
  function genericArray(a, b) {
    var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
    for (i = 0; i < na; ++i) x[i] = value_default(a[i], b[i]);
    for (; i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < na; ++i) c[i] = x[i](t);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/date.js
  function date_default(a, b) {
    var d = /* @__PURE__ */ new Date();
    return a = +a, b = +b, function(t) {
      return d.setTime(a * (1 - t) + b * t), d;
    };
  }

  // node_modules/d3-interpolate/src/number.js
  function number_default(a, b) {
    return a = +a, b = +b, function(t) {
      return a * (1 - t) + b * t;
    };
  }

  // node_modules/d3-interpolate/src/object.js
  function object_default(a, b) {
    var i = {}, c = {}, k;
    if (a === null || typeof a !== "object") a = {};
    if (b === null || typeof b !== "object") b = {};
    for (k in b) {
      if (k in a) {
        i[k] = value_default(a[k], b[k]);
      } else {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }

  // node_modules/d3-interpolate/src/string.js
  var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g;
  var reB = new RegExp(reA.source, "g");
  function zero2(b) {
    return function() {
      return b;
    };
  }
  function one(b) {
    return function(t) {
      return b(t) + "";
    };
  }
  function string_default(a, b) {
    var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs;
        else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm;
        else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({ i, x: number_default(am, bm) });
      }
      bi = reB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs;
      else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? one(q[0].x) : zero2(b) : (b = q.length, function(t) {
      for (var i2 = 0, o; i2 < b; ++i2) s[(o = q[i2]).i] = o.x(t);
      return s.join("");
    });
  }

  // node_modules/d3-interpolate/src/value.js
  function value_default(a, b) {
    var t = typeof b, c;
    return b == null || t === "boolean" ? constant_default(b) : (t === "number" ? number_default : t === "string" ? (c = color2(b)) ? (b = c, rgb_default) : string_default : b instanceof color2 ? rgb_default : b instanceof Date ? date_default : isNumberArray(b) ? numberArray_default : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object_default : number_default)(a, b);
  }

  // node_modules/d3-interpolate/src/round.js
  function round_default(a, b) {
    return a = +a, b = +b, function(t) {
      return Math.round(a * (1 - t) + b * t);
    };
  }

  // node_modules/d3-scale/src/constant.js
  function constants(x) {
    return function() {
      return x;
    };
  }

  // node_modules/d3-scale/src/number.js
  function number2(x) {
    return +x;
  }

  // node_modules/d3-scale/src/continuous.js
  var unit = [0, 1];
  function identity(x) {
    return x;
  }
  function normalize(a, b) {
    return (b -= a = +a) ? function(x) {
      return (x - a) / b;
    } : constants(isNaN(b) ? NaN : 0.5);
  }
  function clamper(a, b) {
    var t;
    if (a > b) t = a, a = b, b = t;
    return function(x) {
      return Math.max(a, Math.min(b, x));
    };
  }
  function bimap(domain, range2, interpolate2) {
    var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
    if (d1 < d0) d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
    else d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
    return function(x) {
      return r0(d0(x));
    };
  }
  function polymap(domain, range2, interpolate2) {
    var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r2 = new Array(j), i = -1;
    if (domain[j] < domain[0]) {
      domain = domain.slice().reverse();
      range2 = range2.slice().reverse();
    }
    while (++i < j) {
      d[i] = normalize(domain[i], domain[i + 1]);
      r2[i] = interpolate2(range2[i], range2[i + 1]);
    }
    return function(x) {
      var i2 = bisect_default(domain, x, 1, j) - 1;
      return r2[i2](d[i2](x));
    };
  }
  function copy2(source, target) {
    return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
  }
  function transformer() {
    var domain = unit, range2 = unit, interpolate2 = value_default, transform, untransform, unknown, clamp3 = identity, piecewise, output, input;
    function rescale() {
      var n = Math.min(domain.length, range2.length);
      if (clamp3 !== identity) clamp3 = clamper(domain[0], domain[n - 1]);
      piecewise = n > 2 ? polymap : bimap;
      output = input = null;
      return scale;
    }
    function scale(x) {
      return x == null || isNaN(x = +x) ? unknown : (output || (output = piecewise(domain.map(transform), range2, interpolate2)))(transform(clamp3(x)));
    }
    scale.invert = function(y) {
      return clamp3(untransform((input || (input = piecewise(range2, domain.map(transform), number_default)))(y)));
    };
    scale.domain = function(_2) {
      return arguments.length ? (domain = Array.from(_2, number2), rescale()) : domain.slice();
    };
    scale.range = function(_2) {
      return arguments.length ? (range2 = Array.from(_2), rescale()) : range2.slice();
    };
    scale.rangeRound = function(_2) {
      return range2 = Array.from(_2), interpolate2 = round_default, rescale();
    };
    scale.clamp = function(_2) {
      return arguments.length ? (clamp3 = _2 ? true : identity, rescale()) : clamp3 !== identity;
    };
    scale.interpolate = function(_2) {
      return arguments.length ? (interpolate2 = _2, rescale()) : interpolate2;
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    return function(t, u) {
      transform = t, untransform = u;
      return rescale();
    };
  }
  function continuous() {
    return transformer()(identity, identity);
  }

  // node_modules/d3-format/src/formatDecimal.js
  function formatDecimal_default(x) {
    return Math.abs(x = Math.round(x)) >= 1e21 ? x.toLocaleString("en").replace(/,/g, "") : x.toString(10);
  }
  function formatDecimalParts(x, p) {
    if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null;
    var i, coefficient = x.slice(0, i);
    return [
      coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
      +x.slice(i + 1)
    ];
  }

  // node_modules/d3-format/src/exponent.js
  function exponent_default(x) {
    return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;
  }

  // node_modules/d3-format/src/formatGroup.js
  function formatGroup_default(grouping, thousands) {
    return function(value, width2) {
      var i = value.length, t = [], j = 0, g = grouping[0], length2 = 0;
      while (i > 0 && g > 0) {
        if (length2 + g + 1 > width2) g = Math.max(1, width2 - length2);
        t.push(value.substring(i -= g, i + g));
        if ((length2 += g + 1) > width2) break;
        g = grouping[j = (j + 1) % grouping.length];
      }
      return t.reverse().join(thousands);
    };
  }

  // node_modules/d3-format/src/formatNumerals.js
  function formatNumerals_default(numerals) {
    return function(value) {
      return value.replace(/[0-9]/g, function(i) {
        return numerals[+i];
      });
    };
  }

  // node_modules/d3-format/src/formatSpecifier.js
  var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function formatSpecifier(specifier) {
    if (!(match2 = re.exec(specifier))) throw new Error("invalid format: " + specifier);
    var match2;
    return new FormatSpecifier({
      fill: match2[1],
      align: match2[2],
      sign: match2[3],
      symbol: match2[4],
      zero: match2[5],
      width: match2[6],
      comma: match2[7],
      precision: match2[8] && match2[8].slice(1),
      trim: match2[9],
      type: match2[10]
    });
  }
  formatSpecifier.prototype = FormatSpecifier.prototype;
  function FormatSpecifier(specifier) {
    this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
    this.align = specifier.align === void 0 ? ">" : specifier.align + "";
    this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
    this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
    this.zero = !!specifier.zero;
    this.width = specifier.width === void 0 ? void 0 : +specifier.width;
    this.comma = !!specifier.comma;
    this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
    this.trim = !!specifier.trim;
    this.type = specifier.type === void 0 ? "" : specifier.type + "";
  }
  FormatSpecifier.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };

  // node_modules/d3-format/src/formatTrim.js
  function formatTrim_default(s) {
    out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0) i0 = i;
          i1 = i;
          break;
        default:
          if (!+s[i]) break out;
          if (i0 > 0) i0 = 0;
          break;
      }
    }
    return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;
  }

  // node_modules/d3-format/src/formatPrefixAuto.js
  var prefixExponent;
  function formatPrefixAuto_default(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1], i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1, n = coefficient.length;
    return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x, Math.max(0, p + i - 1))[0];
  }

  // node_modules/d3-format/src/formatRounded.js
  function formatRounded_default(x, p) {
    var d = formatDecimalParts(x, p);
    if (!d) return x + "";
    var coefficient = d[0], exponent = d[1];
    return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
  }

  // node_modules/d3-format/src/formatTypes.js
  var formatTypes_default = {
    "%": (x, p) => (x * 100).toFixed(p),
    "b": (x) => Math.round(x).toString(2),
    "c": (x) => x + "",
    "d": formatDecimal_default,
    "e": (x, p) => x.toExponential(p),
    "f": (x, p) => x.toFixed(p),
    "g": (x, p) => x.toPrecision(p),
    "o": (x) => Math.round(x).toString(8),
    "p": (x, p) => formatRounded_default(x * 100, p),
    "r": formatRounded_default,
    "s": formatPrefixAuto_default,
    "X": (x) => Math.round(x).toString(16).toUpperCase(),
    "x": (x) => Math.round(x).toString(16)
  };

  // node_modules/d3-format/src/identity.js
  function identity_default(x) {
    return x;
  }

  // node_modules/d3-format/src/locale.js
  var map = Array.prototype.map;
  var prefixes2 = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
  function locale_default(locale3) {
    var group = locale3.grouping === void 0 || locale3.thousands === void 0 ? identity_default : formatGroup_default(map.call(locale3.grouping, Number), locale3.thousands + ""), currencyPrefix = locale3.currency === void 0 ? "" : locale3.currency[0] + "", currencySuffix = locale3.currency === void 0 ? "" : locale3.currency[1] + "", decimal = locale3.decimal === void 0 ? "." : locale3.decimal + "", numerals = locale3.numerals === void 0 ? identity_default : formatNumerals_default(map.call(locale3.numerals, String)), percent = locale3.percent === void 0 ? "%" : locale3.percent + "", minus = locale3.minus === void 0 ? "\u2212" : locale3.minus + "", nan = locale3.nan === void 0 ? "NaN" : locale3.nan + "";
    function newFormat(specifier) {
      specifier = formatSpecifier(specifier);
      var fill = specifier.fill, align = specifier.align, sign = specifier.sign, symbol = specifier.symbol, zero3 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type = specifier.type;
      if (type === "n") comma = true, type = "g";
      else if (!formatTypes_default[type]) precision === void 0 && (precision = 12), trim2 = true, type = "g";
      if (zero3 || fill === "0" && align === "=") zero3 = true, fill = "0", align = "=";
      var prefix3 = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
      var formatType = formatTypes_default[type], maybeSuffix = /[defgprs%]/.test(type);
      precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
      function format2(value) {
        var valuePrefix = prefix3, valueSuffix = suffix, i, n, c;
        if (type === "c") {
          valueSuffix = formatType(value) + valueSuffix;
          value = "";
        } else {
          value = +value;
          var valueNegative = value < 0 || 1 / value < 0;
          value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
          if (trim2) value = formatTrim_default(value);
          if (valueNegative && +value === 0 && sign !== "+") valueNegative = false;
          valuePrefix = (valueNegative ? sign === "(" ? sign : minus : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
          valueSuffix = (type === "s" ? prefixes2[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : "");
          if (maybeSuffix) {
            i = -1, n = value.length;
            while (++i < n) {
              if (c = value.charCodeAt(i), 48 > c || c > 57) {
                valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
                value = value.slice(0, i);
                break;
              }
            }
          }
        }
        if (comma && !zero3) value = group(value, Infinity);
        var length2 = valuePrefix.length + value.length + valueSuffix.length, padding2 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill) : "";
        if (comma && zero3) value = group(padding2 + value, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
        switch (align) {
          case "<":
            value = valuePrefix + value + valueSuffix + padding2;
            break;
          case "=":
            value = valuePrefix + padding2 + value + valueSuffix;
            break;
          case "^":
            value = padding2.slice(0, length2 = padding2.length >> 1) + valuePrefix + value + valueSuffix + padding2.slice(length2);
            break;
          default:
            value = padding2 + valuePrefix + value + valueSuffix;
            break;
        }
        return numerals(value);
      }
      format2.toString = function() {
        return specifier + "";
      };
      return format2;
    }
    function formatPrefix2(specifier, value) {
      var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3, k = Math.pow(10, -e), prefix3 = prefixes2[8 + e / 3];
      return function(value2) {
        return f(k * value2) + prefix3;
      };
    }
    return {
      format: newFormat,
      formatPrefix: formatPrefix2
    };
  }

  // node_modules/d3-format/src/defaultLocale.js
  var locale;
  var format;
  var formatPrefix;
  defaultLocale({
    thousands: ",",
    grouping: [3],
    currency: ["$", ""]
  });
  function defaultLocale(definition) {
    locale = locale_default(definition);
    format = locale.format;
    formatPrefix = locale.formatPrefix;
    return locale;
  }

  // node_modules/d3-format/src/precisionFixed.js
  function precisionFixed_default(step) {
    return Math.max(0, -exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionPrefix.js
  function precisionPrefix_default(step, value) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent_default(value) / 3))) * 3 - exponent_default(Math.abs(step)));
  }

  // node_modules/d3-format/src/precisionRound.js
  function precisionRound_default(step, max2) {
    step = Math.abs(step), max2 = Math.abs(max2) - step;
    return Math.max(0, exponent_default(max2) - exponent_default(step)) + 1;
  }

  // node_modules/d3-scale/src/tickFormat.js
  function tickFormat(start3, stop2, count, specifier) {
    var step = tickStep(start3, stop2, count), precision;
    specifier = formatSpecifier(specifier == null ? ",f" : specifier);
    switch (specifier.type) {
      case "s": {
        var value = Math.max(Math.abs(start3), Math.abs(stop2));
        if (specifier.precision == null && !isNaN(precision = precisionPrefix_default(step, value))) specifier.precision = precision;
        return formatPrefix(specifier, value);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        if (specifier.precision == null && !isNaN(precision = precisionRound_default(step, Math.max(Math.abs(start3), Math.abs(stop2))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }
      case "f":
      case "%": {
        if (specifier.precision == null && !isNaN(precision = precisionFixed_default(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
    }
    return format(specifier);
  }

  // node_modules/d3-scale/src/linear.js
  function linearish(scale) {
    var domain = scale.domain;
    scale.ticks = function(count) {
      var d = domain();
      return ticks(d[0], d[d.length - 1], count == null ? 10 : count);
    };
    scale.tickFormat = function(count, specifier) {
      var d = domain();
      return tickFormat(d[0], d[d.length - 1], count == null ? 10 : count, specifier);
    };
    scale.nice = function(count) {
      if (count == null) count = 10;
      var d = domain();
      var i0 = 0;
      var i1 = d.length - 1;
      var start3 = d[i0];
      var stop2 = d[i1];
      var prestep;
      var step;
      var maxIter = 10;
      if (stop2 < start3) {
        step = start3, start3 = stop2, stop2 = step;
        step = i0, i0 = i1, i1 = step;
      }
      while (maxIter-- > 0) {
        step = tickIncrement(start3, stop2, count);
        if (step === prestep) {
          d[i0] = start3;
          d[i1] = stop2;
          return domain(d);
        } else if (step > 0) {
          start3 = Math.floor(start3 / step) * step;
          stop2 = Math.ceil(stop2 / step) * step;
        } else if (step < 0) {
          start3 = Math.ceil(start3 * step) / step;
          stop2 = Math.floor(stop2 * step) / step;
        } else {
          break;
        }
        prestep = step;
      }
      return scale;
    };
    return scale;
  }
  function linear2() {
    var scale = continuous();
    scale.copy = function() {
      return copy2(scale, linear2());
    };
    initRange.apply(scale, arguments);
    return linearish(scale);
  }

  // node_modules/d3-scale/src/nice.js
  function nice(domain, interval) {
    domain = domain.slice();
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t;
    if (x1 < x0) {
      t = i0, i0 = i1, i1 = t;
      t = x0, x0 = x1, x1 = t;
    }
    domain[i0] = interval.floor(x0);
    domain[i1] = interval.ceil(x1);
    return domain;
  }

  // node_modules/d3-scale/src/log.js
  function transformLog(x) {
    return Math.log(x);
  }
  function transformExp(x) {
    return Math.exp(x);
  }
  function transformLogn(x) {
    return -Math.log(-x);
  }
  function transformExpn(x) {
    return -Math.exp(-x);
  }
  function pow10(x) {
    return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
  }
  function powp(base) {
    return base === 10 ? pow10 : base === Math.E ? Math.exp : (x) => Math.pow(base, x);
  }
  function logp(base) {
    return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x) => Math.log(x) / base);
  }
  function reflect(f) {
    return (x, k) => -f(-x, k);
  }
  function loggish(transform) {
    const scale = transform(transformLog, transformExp);
    const domain = scale.domain;
    let base = 10;
    let logs;
    let pows;
    function rescale() {
      logs = logp(base), pows = powp(base);
      if (domain()[0] < 0) {
        logs = reflect(logs), pows = reflect(pows);
        transform(transformLogn, transformExpn);
      } else {
        transform(transformLog, transformExp);
      }
      return scale;
    }
    scale.base = function(_2) {
      return arguments.length ? (base = +_2, rescale()) : base;
    };
    scale.domain = function(_2) {
      return arguments.length ? (domain(_2), rescale()) : domain();
    };
    scale.ticks = (count) => {
      const d = domain();
      let u = d[0];
      let v = d[d.length - 1];
      const r2 = v < u;
      if (r2) [u, v] = [v, u];
      let i = logs(u);
      let j = logs(v);
      let k;
      let t;
      const n = count == null ? 10 : +count;
      let z = [];
      if (!(base % 1) && j - i < n) {
        i = Math.floor(i), j = Math.ceil(j);
        if (u > 0) for (; i <= j; ++i) {
          for (k = 1; k < base; ++k) {
            t = i < 0 ? k / pows(-i) : k * pows(i);
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        }
        else for (; i <= j; ++i) {
          for (k = base - 1; k >= 1; --k) {
            t = i > 0 ? k / pows(-i) : k * pows(i);
            if (t < u) continue;
            if (t > v) break;
            z.push(t);
          }
        }
        if (z.length * 2 < n) z = ticks(u, v, n);
      } else {
        z = ticks(i, j, Math.min(j - i, n)).map(pows);
      }
      return r2 ? z.reverse() : z;
    };
    scale.tickFormat = (count, specifier) => {
      if (count == null) count = 10;
      if (specifier == null) specifier = base === 10 ? "s" : ",";
      if (typeof specifier !== "function") {
        if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
        specifier = format(specifier);
      }
      if (count === Infinity) return specifier;
      const k = Math.max(1, base * count / scale.ticks().length);
      return (d) => {
        let i = d / pows(Math.round(logs(d)));
        if (i * base < base - 0.5) i *= base;
        return i <= k ? specifier(d) : "";
      };
    };
    scale.nice = () => {
      return domain(nice(domain(), {
        floor: (x) => pows(Math.floor(logs(x))),
        ceil: (x) => pows(Math.ceil(logs(x)))
      }));
    };
    return scale;
  }
  function log() {
    const scale = loggish(transformer()).domain([1, 10]);
    scale.copy = () => copy2(scale, log()).base(scale.base());
    initRange.apply(scale, arguments);
    return scale;
  }

  // node_modules/d3-scale/src/pow.js
  function transformPow(exponent) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
    };
  }
  function transformSqrt(x) {
    return x < 0 ? -Math.sqrt(-x) : Math.sqrt(x);
  }
  function transformSquare(x) {
    return x < 0 ? -x * x : x * x;
  }
  function powish(transform) {
    var scale = transform(identity, identity), exponent = 1;
    function rescale() {
      return exponent === 1 ? transform(identity, identity) : exponent === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent), transformPow(1 / exponent));
    }
    scale.exponent = function(_2) {
      return arguments.length ? (exponent = +_2, rescale()) : exponent;
    };
    return linearish(scale);
  }
  function pow() {
    var scale = powish(transformer());
    scale.copy = function() {
      return copy2(scale, pow()).exponent(scale.exponent());
    };
    initRange.apply(scale, arguments);
    return scale;
  }
  function sqrt() {
    return pow.apply(null, arguments).exponent(0.5);
  }

  // node_modules/d3-scale/src/threshold.js
  function threshold() {
    var domain = [0.5], range2 = [0, 1], unknown, n = 1;
    function scale(x) {
      return x != null && x <= x ? range2[bisect_default(domain, x, 0, n)] : unknown;
    }
    scale.domain = function(_2) {
      return arguments.length ? (domain = Array.from(_2), n = Math.min(domain.length, range2.length - 1), scale) : domain.slice();
    };
    scale.range = function(_2) {
      return arguments.length ? (range2 = Array.from(_2), n = Math.min(domain.length, range2.length - 1), scale) : range2.slice();
    };
    scale.invertExtent = function(y) {
      var i = range2.indexOf(y);
      return [domain[i - 1], domain[i]];
    };
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    scale.copy = function() {
      return threshold().domain(domain).range(range2).unknown(unknown);
    };
    return initRange.apply(scale, arguments);
  }

  // node_modules/d3-time/src/interval.js
  var t0 = /* @__PURE__ */ new Date();
  var t1 = /* @__PURE__ */ new Date();
  function timeInterval(floori, offseti, count, field) {
    function interval(date2) {
      return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
    }
    interval.floor = (date2) => {
      return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
    };
    interval.ceil = (date2) => {
      return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
    };
    interval.round = (date2) => {
      const d0 = interval(date2), d1 = interval.ceil(date2);
      return date2 - d0 < d1 - date2 ? d0 : d1;
    };
    interval.offset = (date2, step) => {
      return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
    };
    interval.range = (start3, stop2, step) => {
      const range2 = [];
      start3 = interval.ceil(start3);
      step = step == null ? 1 : Math.floor(step);
      if (!(start3 < stop2) || !(step > 0)) return range2;
      let previous;
      do
        range2.push(previous = /* @__PURE__ */ new Date(+start3)), offseti(start3, step), floori(start3);
      while (previous < start3 && start3 < stop2);
      return range2;
    };
    interval.filter = (test) => {
      return timeInterval((date2) => {
        if (date2 >= date2) while (floori(date2), !test(date2)) date2.setTime(date2 - 1);
      }, (date2, step) => {
        if (date2 >= date2) {
          if (step < 0) while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
          else while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
        }
      });
    };
    if (count) {
      interval.count = (start3, end2) => {
        t0.setTime(+start3), t1.setTime(+end2);
        floori(t0), floori(t1);
        return Math.floor(count(t0, t1));
      };
      interval.every = (step) => {
        step = Math.floor(step);
        return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d) => field(d) % step === 0 : (d) => interval.count(0, d) % step === 0);
      };
    }
    return interval;
  }

  // node_modules/d3-time/src/millisecond.js
  var millisecond = timeInterval(() => {
  }, (date2, step) => {
    date2.setTime(+date2 + step);
  }, (start3, end2) => {
    return end2 - start3;
  });
  millisecond.every = (k) => {
    k = Math.floor(k);
    if (!isFinite(k) || !(k > 0)) return null;
    if (!(k > 1)) return millisecond;
    return timeInterval((date2) => {
      date2.setTime(Math.floor(date2 / k) * k);
    }, (date2, step) => {
      date2.setTime(+date2 + step * k);
    }, (start3, end2) => {
      return (end2 - start3) / k;
    });
  };
  var milliseconds = millisecond.range;

  // node_modules/d3-time/src/duration.js
  var durationSecond = 1e3;
  var durationMinute = durationSecond * 60;
  var durationHour = durationMinute * 60;
  var durationDay = durationHour * 24;
  var durationWeek = durationDay * 7;
  var durationMonth = durationDay * 30;
  var durationYear = durationDay * 365;

  // node_modules/d3-time/src/second.js
  var second = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds());
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationSecond);
  }, (start3, end2) => {
    return (end2 - start3) / durationSecond;
  }, (date2) => {
    return date2.getUTCSeconds();
  });
  var seconds = second.range;

  // node_modules/d3-time/src/minute.js
  var timeMinute = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationMinute);
  }, (start3, end2) => {
    return (end2 - start3) / durationMinute;
  }, (date2) => {
    return date2.getMinutes();
  });
  var timeMinutes = timeMinute.range;
  var utcMinute = timeInterval((date2) => {
    date2.setUTCSeconds(0, 0);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationMinute);
  }, (start3, end2) => {
    return (end2 - start3) / durationMinute;
  }, (date2) => {
    return date2.getUTCMinutes();
  });
  var utcMinutes = utcMinute.range;

  // node_modules/d3-time/src/hour.js
  var timeHour = timeInterval((date2) => {
    date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationHour);
  }, (start3, end2) => {
    return (end2 - start3) / durationHour;
  }, (date2) => {
    return date2.getHours();
  });
  var timeHours = timeHour.range;
  var utcHour = timeInterval((date2) => {
    date2.setUTCMinutes(0, 0, 0);
  }, (date2, step) => {
    date2.setTime(+date2 + step * durationHour);
  }, (start3, end2) => {
    return (end2 - start3) / durationHour;
  }, (date2) => {
    return date2.getUTCHours();
  });
  var utcHours = utcHour.range;

  // node_modules/d3-time/src/day.js
  var timeDay = timeInterval(
    (date2) => date2.setHours(0, 0, 0, 0),
    (date2, step) => date2.setDate(date2.getDate() + step),
    (start3, end2) => (end2 - start3 - (end2.getTimezoneOffset() - start3.getTimezoneOffset()) * durationMinute) / durationDay,
    (date2) => date2.getDate() - 1
  );
  var timeDays = timeDay.range;
  var utcDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step);
  }, (start3, end2) => {
    return (end2 - start3) / durationDay;
  }, (date2) => {
    return date2.getUTCDate() - 1;
  });
  var utcDays = utcDay.range;
  var unixDay = timeInterval((date2) => {
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step);
  }, (start3, end2) => {
    return (end2 - start3) / durationDay;
  }, (date2) => {
    return Math.floor(date2 / durationDay);
  });
  var unixDays = unixDay.range;

  // node_modules/d3-time/src/week.js
  function timeWeekday(i) {
    return timeInterval((date2) => {
      date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setDate(date2.getDate() + step * 7);
    }, (start3, end2) => {
      return (end2 - start3 - (end2.getTimezoneOffset() - start3.getTimezoneOffset()) * durationMinute) / durationWeek;
    });
  }
  var timeSunday = timeWeekday(0);
  var timeMonday = timeWeekday(1);
  var timeTuesday = timeWeekday(2);
  var timeWednesday = timeWeekday(3);
  var timeThursday = timeWeekday(4);
  var timeFriday = timeWeekday(5);
  var timeSaturday = timeWeekday(6);
  var timeSundays = timeSunday.range;
  var timeMondays = timeMonday.range;
  var timeTuesdays = timeTuesday.range;
  var timeWednesdays = timeWednesday.range;
  var timeThursdays = timeThursday.range;
  var timeFridays = timeFriday.range;
  var timeSaturdays = timeSaturday.range;
  function utcWeekday(i) {
    return timeInterval((date2) => {
      date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCDate(date2.getUTCDate() + step * 7);
    }, (start3, end2) => {
      return (end2 - start3) / durationWeek;
    });
  }
  var utcSunday = utcWeekday(0);
  var utcMonday = utcWeekday(1);
  var utcTuesday = utcWeekday(2);
  var utcWednesday = utcWeekday(3);
  var utcThursday = utcWeekday(4);
  var utcFriday = utcWeekday(5);
  var utcSaturday = utcWeekday(6);
  var utcSundays = utcSunday.range;
  var utcMondays = utcMonday.range;
  var utcTuesdays = utcTuesday.range;
  var utcWednesdays = utcWednesday.range;
  var utcThursdays = utcThursday.range;
  var utcFridays = utcFriday.range;
  var utcSaturdays = utcSaturday.range;

  // node_modules/d3-time/src/month.js
  var timeMonth = timeInterval((date2) => {
    date2.setDate(1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setMonth(date2.getMonth() + step);
  }, (start3, end2) => {
    return end2.getMonth() - start3.getMonth() + (end2.getFullYear() - start3.getFullYear()) * 12;
  }, (date2) => {
    return date2.getMonth();
  });
  var timeMonths = timeMonth.range;
  var utcMonth = timeInterval((date2) => {
    date2.setUTCDate(1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCMonth(date2.getUTCMonth() + step);
  }, (start3, end2) => {
    return end2.getUTCMonth() - start3.getUTCMonth() + (end2.getUTCFullYear() - start3.getUTCFullYear()) * 12;
  }, (date2) => {
    return date2.getUTCMonth();
  });
  var utcMonths = utcMonth.range;

  // node_modules/d3-time/src/year.js
  var timeYear = timeInterval((date2) => {
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step);
  }, (start3, end2) => {
    return end2.getFullYear() - start3.getFullYear();
  }, (date2) => {
    return date2.getFullYear();
  });
  timeYear.every = (k) => {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date2) => {
      date2.setFullYear(Math.floor(date2.getFullYear() / k) * k);
      date2.setMonth(0, 1);
      date2.setHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setFullYear(date2.getFullYear() + step * k);
    });
  };
  var timeYears = timeYear.range;
  var utcYear = timeInterval((date2) => {
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step);
  }, (start3, end2) => {
    return end2.getUTCFullYear() - start3.getUTCFullYear();
  }, (date2) => {
    return date2.getUTCFullYear();
  });
  utcYear.every = (k) => {
    return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date2) => {
      date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k) * k);
      date2.setUTCMonth(0, 1);
      date2.setUTCHours(0, 0, 0, 0);
    }, (date2, step) => {
      date2.setUTCFullYear(date2.getUTCFullYear() + step * k);
    });
  };
  var utcYears = utcYear.range;

  // node_modules/d3-time/src/ticks.js
  function ticker(year, month, week, day, hour, minute) {
    const tickIntervals = [
      [second, 1, durationSecond],
      [second, 5, 5 * durationSecond],
      [second, 15, 15 * durationSecond],
      [second, 30, 30 * durationSecond],
      [minute, 1, durationMinute],
      [minute, 5, 5 * durationMinute],
      [minute, 15, 15 * durationMinute],
      [minute, 30, 30 * durationMinute],
      [hour, 1, durationHour],
      [hour, 3, 3 * durationHour],
      [hour, 6, 6 * durationHour],
      [hour, 12, 12 * durationHour],
      [day, 1, durationDay],
      [day, 2, 2 * durationDay],
      [week, 1, durationWeek],
      [month, 1, durationMonth],
      [month, 3, 3 * durationMonth],
      [year, 1, durationYear]
    ];
    function ticks2(start3, stop2, count) {
      const reverse = stop2 < start3;
      if (reverse) [start3, stop2] = [stop2, start3];
      const interval = count && typeof count.range === "function" ? count : tickInterval(start3, stop2, count);
      const ticks3 = interval ? interval.range(start3, +stop2 + 1) : [];
      return reverse ? ticks3.reverse() : ticks3;
    }
    function tickInterval(start3, stop2, count) {
      const target = Math.abs(stop2 - start3) / count;
      const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
      if (i === tickIntervals.length) return year.every(tickStep(start3 / durationYear, stop2 / durationYear, count));
      if (i === 0) return millisecond.every(Math.max(tickStep(start3, stop2, count), 1));
      const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
      return t.every(step);
    }
    return [ticks2, tickInterval];
  }
  var [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
  var [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

  // node_modules/d3-time-format/src/locale.js
  function localDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
      date2.setFullYear(d.y);
      return date2;
    }
    return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
  }
  function utcDate(d) {
    if (0 <= d.y && d.y < 100) {
      var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
      date2.setUTCFullYear(d.y);
      return date2;
    }
    return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
  }
  function newDate(y, m, d) {
    return { y, m, d, H: 0, M: 0, S: 0, L: 0 };
  }
  function formatLocale(locale3) {
    var locale_dateTime = locale3.dateTime, locale_date = locale3.date, locale_time = locale3.time, locale_periods = locale3.periods, locale_weekdays = locale3.days, locale_shortWeekdays = locale3.shortDays, locale_months = locale3.months, locale_shortMonths = locale3.shortMonths;
    var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
    var formats = {
      "a": formatShortWeekday,
      "A": formatWeekday,
      "b": formatShortMonth,
      "B": formatMonth,
      "c": null,
      "d": formatDayOfMonth,
      "e": formatDayOfMonth,
      "f": formatMicroseconds,
      "g": formatYearISO,
      "G": formatFullYearISO,
      "H": formatHour24,
      "I": formatHour12,
      "j": formatDayOfYear,
      "L": formatMilliseconds,
      "m": formatMonthNumber,
      "M": formatMinutes,
      "p": formatPeriod,
      "q": formatQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatSeconds,
      "u": formatWeekdayNumberMonday,
      "U": formatWeekNumberSunday,
      "V": formatWeekNumberISO,
      "w": formatWeekdayNumberSunday,
      "W": formatWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatYear,
      "Y": formatFullYear,
      "Z": formatZone,
      "%": formatLiteralPercent
    };
    var utcFormats = {
      "a": formatUTCShortWeekday,
      "A": formatUTCWeekday,
      "b": formatUTCShortMonth,
      "B": formatUTCMonth,
      "c": null,
      "d": formatUTCDayOfMonth,
      "e": formatUTCDayOfMonth,
      "f": formatUTCMicroseconds,
      "g": formatUTCYearISO,
      "G": formatUTCFullYearISO,
      "H": formatUTCHour24,
      "I": formatUTCHour12,
      "j": formatUTCDayOfYear,
      "L": formatUTCMilliseconds,
      "m": formatUTCMonthNumber,
      "M": formatUTCMinutes,
      "p": formatUTCPeriod,
      "q": formatUTCQuarter,
      "Q": formatUnixTimestamp,
      "s": formatUnixTimestampSeconds,
      "S": formatUTCSeconds,
      "u": formatUTCWeekdayNumberMonday,
      "U": formatUTCWeekNumberSunday,
      "V": formatUTCWeekNumberISO,
      "w": formatUTCWeekdayNumberSunday,
      "W": formatUTCWeekNumberMonday,
      "x": null,
      "X": null,
      "y": formatUTCYear,
      "Y": formatUTCFullYear,
      "Z": formatUTCZone,
      "%": formatLiteralPercent
    };
    var parses = {
      "a": parseShortWeekday,
      "A": parseWeekday,
      "b": parseShortMonth,
      "B": parseMonth,
      "c": parseLocaleDateTime,
      "d": parseDayOfMonth,
      "e": parseDayOfMonth,
      "f": parseMicroseconds,
      "g": parseYear,
      "G": parseFullYear,
      "H": parseHour24,
      "I": parseHour24,
      "j": parseDayOfYear,
      "L": parseMilliseconds,
      "m": parseMonthNumber,
      "M": parseMinutes,
      "p": parsePeriod,
      "q": parseQuarter,
      "Q": parseUnixTimestamp,
      "s": parseUnixTimestampSeconds,
      "S": parseSeconds,
      "u": parseWeekdayNumberMonday,
      "U": parseWeekNumberSunday,
      "V": parseWeekNumberISO,
      "w": parseWeekdayNumberSunday,
      "W": parseWeekNumberMonday,
      "x": parseLocaleDate,
      "X": parseLocaleTime,
      "y": parseYear,
      "Y": parseFullYear,
      "Z": parseZone,
      "%": parseLiteralPercent
    };
    formats.x = newFormat(locale_date, formats);
    formats.X = newFormat(locale_time, formats);
    formats.c = newFormat(locale_dateTime, formats);
    utcFormats.x = newFormat(locale_date, utcFormats);
    utcFormats.X = newFormat(locale_time, utcFormats);
    utcFormats.c = newFormat(locale_dateTime, utcFormats);
    function newFormat(specifier, formats2) {
      return function(date2) {
        var string = [], i = -1, j = 0, n = specifier.length, c, pad2, format2;
        if (!(date2 instanceof Date)) date2 = /* @__PURE__ */ new Date(+date2);
        while (++i < n) {
          if (specifier.charCodeAt(i) === 37) {
            string.push(specifier.slice(j, i));
            if ((pad2 = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
            else pad2 = c === "e" ? " " : "0";
            if (format2 = formats2[c]) c = format2(date2, pad2);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(specifier.slice(j, i));
        return string.join("");
      };
    }
    function newParse(specifier, Z) {
      return function(string) {
        var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day;
        if (i != string.length) return null;
        if ("Q" in d) return new Date(d.Q);
        if ("s" in d) return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
        if (Z && !("Z" in d)) d.Z = 0;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        if (d.m === void 0) d.m = "q" in d ? d.q : 0;
        if ("V" in d) {
          if (d.V < 1 || d.V > 53) return null;
          if (!("w" in d)) d.w = 1;
          if ("Z" in d) {
            week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
            week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
            week = utcDay.offset(week, (d.V - 1) * 7);
            d.y = week.getUTCFullYear();
            d.m = week.getUTCMonth();
            d.d = week.getUTCDate() + (d.w + 6) % 7;
          } else {
            week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
            week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
            week = timeDay.offset(week, (d.V - 1) * 7);
            d.y = week.getFullYear();
            d.m = week.getMonth();
            d.d = week.getDate() + (d.w + 6) % 7;
          }
        } else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
          day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
          d.m = 0;
          d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
        }
        if ("Z" in d) {
          d.H += d.Z / 100 | 0;
          d.M += d.Z % 100;
          return utcDate(d);
        }
        return localDate(d);
      };
    }
    function parseSpecifier(d, specifier, string, j) {
      var i = 0, n = specifier.length, m = string.length, c, parse2;
      while (i < n) {
        if (j >= m) return -1;
        c = specifier.charCodeAt(i++);
        if (c === 37) {
          c = specifier.charAt(i++);
          parse2 = parses[c in pads ? specifier.charAt(i++) : c];
          if (!parse2 || (j = parse2(d, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    function parsePeriod(d, string, i) {
      var n = periodRe.exec(string.slice(i));
      return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseShortWeekday(d, string, i) {
      var n = shortWeekdayRe.exec(string.slice(i));
      return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseWeekday(d, string, i) {
      var n = weekdayRe.exec(string.slice(i));
      return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseShortMonth(d, string, i) {
      var n = shortMonthRe.exec(string.slice(i));
      return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseMonth(d, string, i) {
      var n = monthRe.exec(string.slice(i));
      return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function parseLocaleDateTime(d, string, i) {
      return parseSpecifier(d, locale_dateTime, string, i);
    }
    function parseLocaleDate(d, string, i) {
      return parseSpecifier(d, locale_date, string, i);
    }
    function parseLocaleTime(d, string, i) {
      return parseSpecifier(d, locale_time, string, i);
    }
    function formatShortWeekday(d) {
      return locale_shortWeekdays[d.getDay()];
    }
    function formatWeekday(d) {
      return locale_weekdays[d.getDay()];
    }
    function formatShortMonth(d) {
      return locale_shortMonths[d.getMonth()];
    }
    function formatMonth(d) {
      return locale_months[d.getMonth()];
    }
    function formatPeriod(d) {
      return locale_periods[+(d.getHours() >= 12)];
    }
    function formatQuarter(d) {
      return 1 + ~~(d.getMonth() / 3);
    }
    function formatUTCShortWeekday(d) {
      return locale_shortWeekdays[d.getUTCDay()];
    }
    function formatUTCWeekday(d) {
      return locale_weekdays[d.getUTCDay()];
    }
    function formatUTCShortMonth(d) {
      return locale_shortMonths[d.getUTCMonth()];
    }
    function formatUTCMonth(d) {
      return locale_months[d.getUTCMonth()];
    }
    function formatUTCPeriod(d) {
      return locale_periods[+(d.getUTCHours() >= 12)];
    }
    function formatUTCQuarter(d) {
      return 1 + ~~(d.getUTCMonth() / 3);
    }
    return {
      format: function(specifier) {
        var f = newFormat(specifier += "", formats);
        f.toString = function() {
          return specifier;
        };
        return f;
      },
      parse: function(specifier) {
        var p = newParse(specifier += "", false);
        p.toString = function() {
          return specifier;
        };
        return p;
      },
      utcFormat: function(specifier) {
        var f = newFormat(specifier += "", utcFormats);
        f.toString = function() {
          return specifier;
        };
        return f;
      },
      utcParse: function(specifier) {
        var p = newParse(specifier += "", true);
        p.toString = function() {
          return specifier;
        };
        return p;
      }
    };
  }
  var pads = { "-": "", "_": " ", "0": "0" };
  var numberRe = /^\s*\d+/;
  var percentRe = /^%/;
  var requoteRe = /[\\^$*+?|[\]().{}]/g;
  function pad(value, fill, width2) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length2 = string.length;
    return sign + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill) + string : string);
  }
  function requote(s) {
    return s.replace(requoteRe, "\\$&");
  }
  function formatRe(names) {
    return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
  }
  function formatLookup(names) {
    return new Map(names.map((name, i) => [name.toLowerCase(), i]));
  }
  function parseWeekdayNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.w = +n[0], i + n[0].length) : -1;
  }
  function parseWeekdayNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.u = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberSunday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.U = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberISO(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.V = +n[0], i + n[0].length) : -1;
  }
  function parseWeekNumberMonday(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.W = +n[0], i + n[0].length) : -1;
  }
  function parseFullYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 4));
    return n ? (d.y = +n[0], i + n[0].length) : -1;
  }
  function parseYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
  }
  function parseZone(d, string, i) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
    return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
  }
  function parseQuarter(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 1));
    return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
  }
  function parseMonthNumber(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
  }
  function parseDayOfMonth(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.d = +n[0], i + n[0].length) : -1;
  }
  function parseDayOfYear(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
  }
  function parseHour24(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.H = +n[0], i + n[0].length) : -1;
  }
  function parseMinutes(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.M = +n[0], i + n[0].length) : -1;
  }
  function parseSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 2));
    return n ? (d.S = +n[0], i + n[0].length) : -1;
  }
  function parseMilliseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 3));
    return n ? (d.L = +n[0], i + n[0].length) : -1;
  }
  function parseMicroseconds(d, string, i) {
    var n = numberRe.exec(string.slice(i, i + 6));
    return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
  }
  function parseLiteralPercent(d, string, i) {
    var n = percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function parseUnixTimestamp(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.Q = +n[0], i + n[0].length) : -1;
  }
  function parseUnixTimestampSeconds(d, string, i) {
    var n = numberRe.exec(string.slice(i));
    return n ? (d.s = +n[0], i + n[0].length) : -1;
  }
  function formatDayOfMonth(d, p) {
    return pad(d.getDate(), p, 2);
  }
  function formatHour24(d, p) {
    return pad(d.getHours(), p, 2);
  }
  function formatHour12(d, p) {
    return pad(d.getHours() % 12 || 12, p, 2);
  }
  function formatDayOfYear(d, p) {
    return pad(1 + timeDay.count(timeYear(d), d), p, 3);
  }
  function formatMilliseconds(d, p) {
    return pad(d.getMilliseconds(), p, 3);
  }
  function formatMicroseconds(d, p) {
    return formatMilliseconds(d, p) + "000";
  }
  function formatMonthNumber(d, p) {
    return pad(d.getMonth() + 1, p, 2);
  }
  function formatMinutes(d, p) {
    return pad(d.getMinutes(), p, 2);
  }
  function formatSeconds(d, p) {
    return pad(d.getSeconds(), p, 2);
  }
  function formatWeekdayNumberMonday(d) {
    var day = d.getDay();
    return day === 0 ? 7 : day;
  }
  function formatWeekNumberSunday(d, p) {
    return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
  }
  function dISO(d) {
    var day = d.getDay();
    return day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
  }
  function formatWeekNumberISO(d, p) {
    d = dISO(d);
    return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
  }
  function formatWeekdayNumberSunday(d) {
    return d.getDay();
  }
  function formatWeekNumberMonday(d, p) {
    return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
  }
  function formatYear(d, p) {
    return pad(d.getFullYear() % 100, p, 2);
  }
  function formatYearISO(d, p) {
    d = dISO(d);
    return pad(d.getFullYear() % 100, p, 2);
  }
  function formatFullYear(d, p) {
    return pad(d.getFullYear() % 1e4, p, 4);
  }
  function formatFullYearISO(d, p) {
    var day = d.getDay();
    d = day >= 4 || day === 0 ? timeThursday(d) : timeThursday.ceil(d);
    return pad(d.getFullYear() % 1e4, p, 4);
  }
  function formatZone(d) {
    var z = d.getTimezoneOffset();
    return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
  }
  function formatUTCDayOfMonth(d, p) {
    return pad(d.getUTCDate(), p, 2);
  }
  function formatUTCHour24(d, p) {
    return pad(d.getUTCHours(), p, 2);
  }
  function formatUTCHour12(d, p) {
    return pad(d.getUTCHours() % 12 || 12, p, 2);
  }
  function formatUTCDayOfYear(d, p) {
    return pad(1 + utcDay.count(utcYear(d), d), p, 3);
  }
  function formatUTCMilliseconds(d, p) {
    return pad(d.getUTCMilliseconds(), p, 3);
  }
  function formatUTCMicroseconds(d, p) {
    return formatUTCMilliseconds(d, p) + "000";
  }
  function formatUTCMonthNumber(d, p) {
    return pad(d.getUTCMonth() + 1, p, 2);
  }
  function formatUTCMinutes(d, p) {
    return pad(d.getUTCMinutes(), p, 2);
  }
  function formatUTCSeconds(d, p) {
    return pad(d.getUTCSeconds(), p, 2);
  }
  function formatUTCWeekdayNumberMonday(d) {
    var dow = d.getUTCDay();
    return dow === 0 ? 7 : dow;
  }
  function formatUTCWeekNumberSunday(d, p) {
    return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
  }
  function UTCdISO(d) {
    var day = d.getUTCDay();
    return day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
  }
  function formatUTCWeekNumberISO(d, p) {
    d = UTCdISO(d);
    return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
  }
  function formatUTCWeekdayNumberSunday(d) {
    return d.getUTCDay();
  }
  function formatUTCWeekNumberMonday(d, p) {
    return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
  }
  function formatUTCYear(d, p) {
    return pad(d.getUTCFullYear() % 100, p, 2);
  }
  function formatUTCYearISO(d, p) {
    d = UTCdISO(d);
    return pad(d.getUTCFullYear() % 100, p, 2);
  }
  function formatUTCFullYear(d, p) {
    return pad(d.getUTCFullYear() % 1e4, p, 4);
  }
  function formatUTCFullYearISO(d, p) {
    var day = d.getUTCDay();
    d = day >= 4 || day === 0 ? utcThursday(d) : utcThursday.ceil(d);
    return pad(d.getUTCFullYear() % 1e4, p, 4);
  }
  function formatUTCZone() {
    return "+0000";
  }
  function formatLiteralPercent() {
    return "%";
  }
  function formatUnixTimestamp(d) {
    return +d;
  }
  function formatUnixTimestampSeconds(d) {
    return Math.floor(+d / 1e3);
  }

  // node_modules/d3-time-format/src/defaultLocale.js
  var locale2;
  var timeFormat;
  var timeParse;
  var utcFormat;
  var utcParse;
  defaultLocale2({
    dateTime: "%x, %X",
    date: "%-m/%-d/%Y",
    time: "%-I:%M:%S %p",
    periods: ["AM", "PM"],
    days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
  });
  function defaultLocale2(definition) {
    locale2 = formatLocale(definition);
    timeFormat = locale2.format;
    timeParse = locale2.parse;
    utcFormat = locale2.utcFormat;
    utcParse = locale2.utcParse;
    return locale2;
  }

  // node_modules/d3-scale/src/time.js
  function date(t) {
    return new Date(t);
  }
  function number3(t) {
    return t instanceof Date ? +t : +/* @__PURE__ */ new Date(+t);
  }
  function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
    var scale = continuous(), invert = scale.invert, domain = scale.domain;
    var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
    function tickFormat2(date2) {
      return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
    }
    scale.invert = function(y) {
      return new Date(invert(y));
    };
    scale.domain = function(_2) {
      return arguments.length ? domain(Array.from(_2, number3)) : domain().map(date);
    };
    scale.ticks = function(interval) {
      var d = domain();
      return ticks2(d[0], d[d.length - 1], interval == null ? 10 : interval);
    };
    scale.tickFormat = function(count, specifier) {
      return specifier == null ? tickFormat2 : format2(specifier);
    };
    scale.nice = function(interval) {
      var d = domain();
      if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
      return interval ? domain(nice(d, interval)) : scale;
    };
    scale.copy = function() {
      return copy2(scale, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
    };
    return scale;
  }
  function time() {
    return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
  }

  // node_modules/d3-scale/src/utcTime.js
  function utcTime() {
    return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
  }

  // node_modules/d3-scale/src/sequential.js
  function transformer2() {
    var x0 = 0, x1 = 1, t02, t12, k10, transform, interpolator = identity, clamp3 = false, unknown;
    function scale(x) {
      return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t02) * k10, clamp3 ? Math.max(0, Math.min(1, x)) : x));
    }
    scale.domain = function(_2) {
      return arguments.length ? ([x0, x1] = _2, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale) : [x0, x1];
    };
    scale.clamp = function(_2) {
      return arguments.length ? (clamp3 = !!_2, scale) : clamp3;
    };
    scale.interpolator = function(_2) {
      return arguments.length ? (interpolator = _2, scale) : interpolator;
    };
    function range2(interpolate2) {
      return function(_2) {
        var r0, r1;
        return arguments.length ? ([r0, r1] = _2, interpolator = interpolate2(r0, r1), scale) : [interpolator(0), interpolator(1)];
      };
    }
    scale.range = range2(value_default);
    scale.rangeRound = range2(round_default);
    scale.unknown = function(_2) {
      return arguments.length ? (unknown = _2, scale) : unknown;
    };
    return function(t) {
      transform = t, t02 = t(x0), t12 = t(x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
      return scale;
    };
  }
  function copy3(source, target) {
    return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
  }
  function sequential() {
    var scale = linearish(transformer2()(identity));
    scale.copy = function() {
      return copy3(scale, sequential());
    };
    return initInterpolator.apply(scale, arguments);
  }

  // node_modules/@mui/x-charts/models/axis.js
  function isBandScaleConfig(scaleConfig) {
    return scaleConfig.scaleType === "band";
  }
  function isPointScaleConfig(scaleConfig) {
    return scaleConfig.scaleType === "point";
  }

  // node_modules/@mui/x-charts/internals/colorScale.js
  function getSequentialColorScale(config2) {
    var _a, _b;
    if (config2.type === "piecewise") {
      return threshold(config2.thresholds, config2.colors);
    }
    return sequential([(_a = config2.min) != null ? _a : 0, (_b = config2.max) != null ? _b : 100], config2.color);
  }
  function getOrdinalColorScale(config2) {
    var _a, _b;
    if (config2.values) {
      return ordinal(config2.values, config2.colors).unknown((_a = config2.unknownColor) != null ? _a : null);
    }
    return ordinal(config2.colors.map((_2, index) => index), config2.colors).unknown((_b = config2.unknownColor) != null ? _b : null);
  }
  function getColorScale(config2) {
    return config2.type === "ordinal" ? getOrdinalColorScale(config2) : getSequentialColorScale(config2);
  }

  // node_modules/@mui/x-charts/hooks/useTicks.js
  var React79 = __toESM(require_react());

  // node_modules/@mui/x-charts/internals/isBandScale.js
  function isBandScale(scale) {
    return scale.bandwidth !== void 0;
  }

  // node_modules/@mui/x-charts/internals/isInfinity.js
  function isInfinity(v) {
    return typeof v === "number" && !Number.isFinite(v);
  }

  // node_modules/@mui/x-charts/hooks/useTicks.js
  function getTickNumber(params) {
    const {
      tickMaxStep,
      tickMinStep,
      tickNumber,
      range: range2,
      domain
    } = params;
    const maxTicks = tickMinStep === void 0 ? 999 : Math.floor(Math.abs(domain[1] - domain[0]) / tickMinStep);
    const minTicks = tickMaxStep === void 0 ? 2 : Math.ceil(Math.abs(domain[1] - domain[0]) / tickMaxStep);
    const defaultizedTickNumber = tickNumber != null ? tickNumber : Math.floor(Math.abs(range2[1] - range2[0]) / 50);
    return Math.min(maxTicks, Math.max(minTicks, defaultizedTickNumber));
  }
  var offsetRatio = {
    start: 0,
    extremities: 0,
    end: 1,
    middle: 0.5
  };
  function useTicks(options) {
    const {
      scale,
      tickNumber,
      valueFormatter,
      tickInterval,
      tickPlacement = "extremities",
      tickLabelPlacement = "middle"
    } = options;
    return React79.useMemo(() => {
      if (isBandScale(scale)) {
        const domain2 = scale.domain();
        if (scale.bandwidth() > 0) {
          const filteredDomain2 = typeof tickInterval === "function" && domain2.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain2;
          return [...filteredDomain2.map((value) => {
            var _a;
            return {
              value,
              formattedValue: (_a = valueFormatter == null ? void 0 : valueFormatter(value, {
                location: "tick"
              })) != null ? _a : `${value}`,
              offset: scale(value) - (scale.step() - scale.bandwidth()) / 2 + offsetRatio[tickPlacement] * scale.step(),
              labelOffset: tickLabelPlacement === "tick" ? 0 : scale.step() * (offsetRatio[tickLabelPlacement] - offsetRatio[tickPlacement])
            };
          }), ...tickPlacement === "extremities" ? [{
            formattedValue: void 0,
            offset: scale.range()[1],
            labelOffset: 0
          }] : []];
        }
        const filteredDomain = typeof tickInterval === "function" && domain2.filter(tickInterval) || typeof tickInterval === "object" && tickInterval || domain2;
        return filteredDomain.map((value) => {
          var _a;
          return {
            value,
            formattedValue: (_a = valueFormatter == null ? void 0 : valueFormatter(value, {
              location: "tick"
            })) != null ? _a : `${value}`,
            offset: scale(value),
            labelOffset: 0
          };
        });
      }
      const domain = scale.domain();
      if (domain.some(isInfinity)) {
        return [];
      }
      const ticks2 = typeof tickInterval === "object" ? tickInterval : scale.ticks(tickNumber);
      return ticks2.map((value) => {
        var _a;
        return {
          value,
          formattedValue: (_a = valueFormatter == null ? void 0 : valueFormatter(value, {
            location: "tick"
          })) != null ? _a : scale.tickFormat(tickNumber)(value),
          offset: scale(value),
          labelOffset: 0
        };
      });
    }, [scale, tickInterval, tickNumber, valueFormatter, tickPlacement, tickLabelPlacement]);
  }

  // node_modules/@mui/x-charts/internals/getScale.js
  function getScale(scaleType, domain, range2) {
    switch (scaleType) {
      case "log":
        return log(domain, range2);
      case "pow":
        return pow(domain, range2);
      case "sqrt":
        return sqrt(domain, range2);
      case "time":
        return time(domain, range2);
      case "utc":
        return utcTime(domain, range2);
      default:
        return linear2(domain, range2);
    }
  }

  // node_modules/@mui/x-charts/context/CartesianProvider/zoom.js
  var zoomScaleRange = (scaleRange, zoomRange) => {
    const rangeGap = scaleRange[1] - scaleRange[0];
    const zoomGap = zoomRange[1] - zoomRange[0];
    const min2 = scaleRange[0] - zoomRange[0] * rangeGap / zoomGap;
    const max2 = scaleRange[1] + (100 - zoomRange[1]) * rangeGap / zoomGap;
    return [min2, max2];
  };

  // node_modules/@mui/x-charts/context/CartesianProvider/getAxisExtremum.js
  var axisExtremumCallback = (acc, chartType, axis, getters, axisIndex, formattedSeries, getFilters) => {
    var _a, _b, _c;
    const getter = getters[chartType];
    const series = (_b = (_a = formattedSeries[chartType]) == null ? void 0 : _a.series) != null ? _b : {};
    const [minChartTypeData, maxChartTypeData] = (_c = getter == null ? void 0 : getter({
      series,
      axis,
      axisIndex,
      isDefaultAxis: axisIndex === 0,
      getFilters
    })) != null ? _c : [Infinity, -Infinity];
    const [minData, maxData] = acc;
    return [Math.min(minChartTypeData, minData), Math.max(maxChartTypeData, maxData)];
  };
  var getAxisExtremum = (axis, getters, axisIndex, formattedSeries, getFilters) => {
    const charTypes = Object.keys(getters);
    const extremums = charTypes.reduce((acc, charType) => axisExtremumCallback(acc, charType, axis, getters, axisIndex, formattedSeries, getFilters), [Infinity, -Infinity]);
    if (Number.isNaN(extremums[0]) || Number.isNaN(extremums[1])) {
      return [Infinity, -Infinity];
    }
    return extremums;
  };

  // node_modules/@mui/x-charts/internals/computeAxisValue.js
  function getRange(drawingArea, axisDirection, axis) {
    if (axisDirection === "rotation") {
      const {
        startAngle = 0,
        endAngle = startAngle + 360
      } = axis;
      return axis.reverse ? [Math.PI * startAngle / 180, Math.PI * endAngle / 180] : [Math.PI * endAngle / 180, Math.PI * startAngle / 180];
    }
    if (axisDirection === "radius") {
      const {
        minRadius = 0,
        maxRadius = Math.min(drawingArea.width, drawingArea.height) / 2
      } = axis;
      return [minRadius, maxRadius];
    }
    const range2 = axisDirection === "x" ? [drawingArea.left, drawingArea.left + drawingArea.width] : [drawingArea.top + drawingArea.height, drawingArea.top];
    return axis.reverse ? [range2[1], range2[0]] : range2;
  }
  var isDateData = (data) => (data == null ? void 0 : data[0]) instanceof Date;
  function createDateFormatter(axis, range2) {
    const timeScale = time(axis.data, range2);
    return (v, {
      location: location2
    }) => location2 === "tick" ? timeScale.tickFormat(axis.tickNumber)(v) : `${v.toLocaleString()}`;
  }
  var DEFAULT_CATEGORY_GAP_RATIO = 0.2;
  var DEFAULT_BAR_GAP_RATIO = 0.1;
  function computeAxisValue({
    drawingArea,
    formattedSeries,
    axis: allAxis,
    extremumGetters,
    axisDirection,
    zoomData,
    zoomOptions,
    getFilters
  }) {
    const completeAxis = {};
    allAxis.forEach((eachAxis, axisIndex) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      const axis = eachAxis;
      const zoomOption = zoomOptions == null ? void 0 : zoomOptions[axis.id];
      const zoom = zoomData == null ? void 0 : zoomData.find(({
        axisId
      }) => axisId === axis.id);
      const zoomRange = zoom ? [zoom.start, zoom.end] : [0, 100];
      const range2 = getRange(drawingArea, axisDirection, axis);
      const [minData, maxData] = getAxisExtremum(
        axis,
        extremumGetters,
        axisIndex,
        formattedSeries,
        zoom === void 0 && !zoomOption ? getFilters : void 0
        // Do not apply filtering if zoom is already defined.
      );
      const data = (_a = axis.data) != null ? _a : [];
      if (isBandScaleConfig(axis)) {
        const categoryGapRatio = (_b = axis.categoryGapRatio) != null ? _b : DEFAULT_CATEGORY_GAP_RATIO;
        const barGapRatio = (_c = axis.barGapRatio) != null ? _c : DEFAULT_BAR_GAP_RATIO;
        const scaleRange = axisDirection === "y" ? [range2[1], range2[0]] : range2;
        const zoomedRange2 = zoomScaleRange(scaleRange, zoomRange);
        completeAxis[axis.id] = _extends({
          categoryGapRatio,
          barGapRatio
        }, axis, {
          data,
          scale: band(axis.data, zoomedRange2).paddingInner(categoryGapRatio).paddingOuter(categoryGapRatio / 2),
          tickNumber: axis.data.length,
          colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
            values: axis.data
          }, axis.colorMap)) : getColorScale(axis.colorMap))
        });
        if (isDateData(axis.data)) {
          const dateFormatter = createDateFormatter(axis, scaleRange);
          completeAxis[axis.id].valueFormatter = (_d = axis.valueFormatter) != null ? _d : dateFormatter;
        }
      }
      if (isPointScaleConfig(axis)) {
        const scaleRange = axisDirection === "y" ? [...range2].reverse() : range2;
        const zoomedRange2 = zoomScaleRange(scaleRange, zoomRange);
        completeAxis[axis.id] = _extends({}, axis, {
          data,
          scale: point(axis.data, zoomedRange2),
          tickNumber: axis.data.length,
          colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" ? getOrdinalColorScale(_extends({
            values: axis.data
          }, axis.colorMap)) : getColorScale(axis.colorMap))
        });
        if (isDateData(axis.data)) {
          const dateFormatter = createDateFormatter(axis, scaleRange);
          completeAxis[axis.id].valueFormatter = (_e = axis.valueFormatter) != null ? _e : dateFormatter;
        }
      }
      if (axis.scaleType === "band" || axis.scaleType === "point") {
        return;
      }
      const scaleType = (_f = axis.scaleType) != null ? _f : "linear";
      const domainLimit = (_g = axis.domainLimit) != null ? _g : "nice";
      const axisExtremums = [(_h = axis.min) != null ? _h : minData, (_i = axis.max) != null ? _i : maxData];
      if (typeof domainLimit === "function") {
        const {
          min: min2,
          max: max2
        } = domainLimit(minData, maxData);
        axisExtremums[0] = min2;
        axisExtremums[1] = max2;
      }
      const rawTickNumber = getTickNumber(_extends({}, axis, {
        range: range2,
        domain: axisExtremums
      }));
      const tickNumber = rawTickNumber / ((zoomRange[1] - zoomRange[0]) / 100);
      const zoomedRange = zoomScaleRange(range2, zoomRange);
      const scale = getScale(scaleType, axisExtremums, zoomedRange);
      const finalScale = domainLimit === "nice" ? scale.nice(rawTickNumber) : scale;
      const [minDomain, maxDomain] = finalScale.domain();
      const domain = [(_j = axis.min) != null ? _j : minDomain, (_k = axis.max) != null ? _k : maxDomain];
      completeAxis[axis.id] = _extends({}, axis, {
        data,
        scaleType,
        scale: finalScale.domain(domain),
        tickNumber,
        colorScale: axis.colorMap && getColorScale(axis.colorMap)
      });
    });
    return {
      axis: completeAxis,
      axisIds: allAxis.map(({
        id
      }) => id)
    };
  }

  // node_modules/@mui/x-charts/hooks/useDrawingArea.js
  var React83 = __toESM(require_react());

  // node_modules/@mui/x-charts/context/DrawingProvider.js
  var React82 = __toESM(require_react());

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/useId/useId.js
  var React80 = __toESM(require_react(), 1);
  var globalId2 = 0;
  function useGlobalId2(idOverride) {
    const [defaultId, setDefaultId] = React80.useState(idOverride);
    const id = idOverride || defaultId;
    React80.useEffect(() => {
      if (defaultId == null) {
        globalId2 += 1;
        setDefaultId(`mui-${globalId2}`);
      }
    }, [defaultId]);
    return id;
  }
  var safeReact2 = __spreadValues({}, React80);
  var maybeReactUseId2 = safeReact2.useId;
  function useId2(idOverride) {
    if (maybeReactUseId2 !== void 0) {
      const reactId = maybeReactUseId2();
      return idOverride != null ? idOverride : reactId;
    }
    return useGlobalId2(idOverride);
  }

  // node_modules/@mui/x-charts/hooks/useChartDimensions.js
  var React81 = __toESM(require_react());

  // node_modules/@mui/x-charts/constants/index.js
  var DEFAULT_X_AXIS_KEY = "DEFAULT_X_AXIS_KEY";
  var DEFAULT_Y_AXIS_KEY = "DEFAULT_Y_AXIS_KEY";
  var DEFAULT_MARGINS = {
    top: 50,
    bottom: 50,
    left: 50,
    right: 50
  };

  // node_modules/@mui/x-charts/hooks/useChartDimensions.js
  var useChartDimensions = (width2, height2, margin2) => {
    const defaultizedMargin = _extends({}, DEFAULT_MARGINS, margin2);
    const drawingArea = React81.useMemo(() => ({
      left: defaultizedMargin.left,
      top: defaultizedMargin.top,
      right: defaultizedMargin.right,
      bottom: defaultizedMargin.bottom,
      width: Math.max(0, width2 - defaultizedMargin.left - defaultizedMargin.right),
      height: Math.max(0, height2 - defaultizedMargin.top - defaultizedMargin.bottom)
    }), [width2, height2, defaultizedMargin.top, defaultizedMargin.bottom, defaultizedMargin.left, defaultizedMargin.right]);
    return drawingArea;
  };
  var useChartDimensions_default = useChartDimensions;

  // node_modules/@mui/x-charts/context/DrawingProvider.js
  var import_jsx_runtime53 = __toESM(require_jsx_runtime());
  var DrawingContext = /* @__PURE__ */ React82.createContext({
    top: 0,
    left: 0,
    bottom: 0,
    right: 0,
    height: 300,
    width: 400,
    chartId: "",
    isPointInside: () => false
  });
  if (false) {
    DrawingContext.displayName = "DrawingContext";
  }
  var SvgContext = /* @__PURE__ */ React82.createContext({
    isInitialized: false,
    data: {
      current: null
    }
  });
  if (false) {
    SvgContext.displayName = "SvgContext";
  }
  function DrawingProvider(props) {
    const {
      width: width2,
      height: height2,
      margin: margin2,
      svgRef,
      children
    } = props;
    const drawingArea = useChartDimensions_default(width2, height2, margin2);
    const chartId = useId2();
    const isPointInside = React82.useCallback(({
      x,
      y
    }, options) => {
      if ((options == null ? void 0 : options.targetElement) && (options == null ? void 0 : options.targetElement.closest("[data-drawing-container]"))) {
        return true;
      }
      const isInsideX = x >= drawingArea.left - 1 && x <= drawingArea.left + drawingArea.width;
      const isInsideY = y >= drawingArea.top - 1 && y <= drawingArea.top + drawingArea.height;
      if ((options == null ? void 0 : options.direction) === "x") {
        return isInsideX;
      }
      if ((options == null ? void 0 : options.direction) === "y") {
        return isInsideY;
      }
      return isInsideX && isInsideY;
    }, [drawingArea]);
    const value = React82.useMemo(() => _extends({
      chartId: chartId != null ? chartId : ""
    }, drawingArea, {
      isPointInside
    }), [chartId, drawingArea, isPointInside]);
    const refValue = React82.useMemo(() => ({
      isInitialized: true,
      data: svgRef
    }), [svgRef]);
    return /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(SvgContext.Provider, {
      value: refValue,
      children: /* @__PURE__ */ (0, import_jsx_runtime53.jsx)(DrawingContext.Provider, {
        value,
        children
      })
    });
  }

  // node_modules/@mui/x-charts/hooks/useDrawingArea.js
  function useDrawingArea() {
    const {
      left: left2,
      top: top2,
      width: width2,
      height: height2,
      bottom: bottom2,
      right: right2,
      isPointInside
    } = React83.useContext(DrawingContext);
    return React83.useMemo(() => ({
      left: left2,
      top: top2,
      width: width2,
      height: height2,
      bottom: bottom2,
      right: right2,
      isPointInside
    }), [height2, left2, top2, width2, bottom2, right2, isPointInside]);
  }

  // node_modules/@mui/x-charts/hooks/useSeries.js
  var React92 = __toESM(require_react());

  // node_modules/@mui/x-charts/internals/defaultizeColor.js
  var DEFAULT_COLORS = ["#1f77b4", "#ff7f0e", "#2ca02c", "#d62728", "#9467bd", "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"];
  function defaultizeColor(series, seriesIndex, colors3 = DEFAULT_COLORS) {
    if (series.type === "pie") {
      return _extends({}, series, {
        data: series.data.map((d, index) => _extends({
          color: colors3[index % colors3.length]
        }, d))
      });
    }
    return _extends({
      color: colors3[seriesIndex % colors3.length]
    }, series);
  }

  // node_modules/@mui/x-charts/context/SeriesProvider/processSeries.js
  var preprocessSeries = ({
    series,
    colors: colors3,
    seriesFormatters,
    dataset
  }) => {
    const seriesGroups = {};
    series.forEach((seriesData, seriesIndex) => {
      var _a;
      const {
        id = `auto-generated-id-${seriesIndex}`,
        type
      } = seriesData;
      if (seriesGroups[type] === void 0) {
        seriesGroups[type] = {
          series: {},
          seriesOrder: []
        };
      }
      if (((_a = seriesGroups[type]) == null ? void 0 : _a.series[id]) !== void 0) {
        throw new Error(`MUI X: series' id "${id}" is not unique.`);
      }
      seriesGroups[type].series[id] = _extends({
        id
      }, defaultizeColor(seriesData, seriesIndex, colors3));
      seriesGroups[type].seriesOrder.push(id);
    });
    const formattedSeries = {};
    Object.keys(seriesFormatters).forEach((type) => {
      var _a, _b;
      const group = seriesGroups[type];
      if (group !== void 0) {
        formattedSeries[type] = (_b = (_a = seriesFormatters[type]) == null ? void 0 : _a.call(seriesFormatters, group, dataset)) != null ? _b : seriesGroups[type];
      }
    });
    return formattedSeries;
  };

  // node_modules/@mui/x-charts/context/SeriesProvider/SeriesProvider.js
  var React91 = __toESM(require_react());

  // node_modules/@mui/x-charts/colorPalettes/colorPalettes.js
  var blueberryTwilightPaletteLight = ["#02B2AF", "#2E96FF", "#B800D8", "#60009B", "#2731C8", "#03008D"];
  var blueberryTwilightPaletteDark = ["#02B2AF", "#72CCFF", "#DA00FF", "#9001CB", "#2E96FF", "#3B48E0"];
  var blueberryTwilightPalette = (mode) => mode === "dark" ? blueberryTwilightPaletteDark : blueberryTwilightPaletteLight;

  // node_modules/@mui/x-charts/context/SeriesProvider/SeriesContext.js
  var React84 = __toESM(require_react());
  var SeriesContext = /* @__PURE__ */ React84.createContext({
    isInitialized: false,
    data: {}
  });
  if (false) {
    SeriesContext.displayName = "SeriesContext";
  }

  // node_modules/@mui/x-charts/context/PluginProvider/PluginProvider.js
  var React86 = __toESM(require_react());

  // node_modules/@mui/x-charts/context/PluginProvider/PluginContext.js
  var React85 = __toESM(require_react());
  var PluginContext = /* @__PURE__ */ React85.createContext({
    isInitialized: false,
    data: {
      colorProcessors: {},
      seriesFormatters: {},
      xExtremumGetters: {},
      yExtremumGetters: {},
      rotationExtremumGetters: {},
      radiusExtremumGetters: {}
    }
  });
  if (false) {
    PluginContext.displayName = "PluginContext";
  }

  // node_modules/@mui/x-charts/BarChart/extremums.js
  var createResult = (data, direction) => {
    if (direction === "x") {
      return {
        x: data,
        y: null
      };
    }
    return {
      x: null,
      y: data
    };
  };
  var getBaseExtremum = (params) => {
    var _a;
    const {
      axis,
      getFilters,
      isDefaultAxis
    } = params;
    const filter = getFilters == null ? void 0 : getFilters({
      currentAxisId: axis.id,
      isDefaultAxis
    });
    const data = filter ? (_a = axis.data) == null ? void 0 : _a.filter((_2, i) => filter({
      x: null,
      y: null
    }, i)) : axis.data;
    const minX = Math.min(...data != null ? data : []);
    const maxX = Math.max(...data != null ? data : []);
    return [minX, maxX];
  };
  var getValueExtremum = (direction) => (params) => {
    const {
      series,
      axis,
      getFilters,
      isDefaultAxis
    } = params;
    return Object.keys(series).filter((seriesId) => {
      var _a;
      const yAxisId = (_a = series[seriesId].yAxisId) != null ? _a : series[seriesId].yAxisKey;
      return yAxisId === axis.id || isDefaultAxis && yAxisId === void 0;
    }).reduce((acc, seriesId) => {
      var _a, _b, _c;
      const {
        stackedData
      } = series[seriesId];
      const filter = getFilters == null ? void 0 : getFilters({
        currentAxisId: axis.id,
        isDefaultAxis,
        seriesXAxisId: (_a = series[seriesId].xAxisId) != null ? _a : series[seriesId].xAxisKey,
        seriesYAxisId: (_b = series[seriesId].yAxisId) != null ? _b : series[seriesId].yAxisKey
      });
      const [seriesMin, seriesMax] = (_c = stackedData == null ? void 0 : stackedData.reduce((seriesAcc, values3, index) => {
        if (filter && (!filter(createResult(values3[0], direction), index) || !filter(createResult(values3[1], direction), index))) {
          return seriesAcc;
        }
        return [Math.min(...values3, seriesAcc[0]), Math.max(...values3, seriesAcc[1])];
      }, [Infinity, -Infinity])) != null ? _c : [Infinity, -Infinity];
      return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];
    }, [Infinity, -Infinity]);
  };
  var getExtremumX = (params) => {
    const isHorizontal = Object.keys(params.series).some((seriesId) => params.series[seriesId].layout === "horizontal");
    if (isHorizontal) {
      return getValueExtremum("x")(params);
    }
    return getBaseExtremum(params);
  };
  var getExtremumY = (params) => {
    const isHorizontal = Object.keys(params.series).some((seriesId) => params.series[seriesId].layout === "horizontal");
    if (isHorizontal) {
      return getBaseExtremum(params);
    }
    return getValueExtremum("y")(params);
  };

  // node_modules/d3-shape/src/constant.js
  function constant_default2(x) {
    return function constant() {
      return x;
    };
  }

  // node_modules/d3-shape/src/math.js
  var pi = Math.PI;
  var halfPi = pi / 2;
  var tau = 2 * pi;

  // node_modules/d3-shape/src/array.js
  var slice2 = Array.prototype.slice;
  function array_default(x) {
    return typeof x === "object" && "length" in x ? x : Array.from(x);
  }

  // node_modules/d3-shape/src/descending.js
  function descending_default(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  }

  // node_modules/d3-shape/src/identity.js
  function identity_default2(d) {
    return d;
  }

  // node_modules/d3-shape/src/pie.js
  function pie_default() {
    var value = identity_default2, sortValues = descending_default, sort = null, startAngle = constant_default2(0), endAngle = constant_default2(tau), padAngle = constant_default2(0);
    function pie(data) {
      var i, n = (data = array_default(data)).length, j, k, sum2 = 0, index = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
      for (i = 0; i < n; ++i) {
        if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
          sum2 += v;
        }
      }
      if (sortValues != null) index.sort(function(i2, j2) {
        return sortValues(arcs[i2], arcs[j2]);
      });
      else if (sort != null) index.sort(function(i2, j2) {
        return sort(data[i2], data[j2]);
      });
      for (i = 0, k = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
        j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
          data: data[j],
          index: i,
          value: v,
          startAngle: a0,
          endAngle: a1,
          padAngle: p
        };
      }
      return arcs;
    }
    pie.value = function(_2) {
      return arguments.length ? (value = typeof _2 === "function" ? _2 : constant_default2(+_2), pie) : value;
    };
    pie.sortValues = function(_2) {
      return arguments.length ? (sortValues = _2, sort = null, pie) : sortValues;
    };
    pie.sort = function(_2) {
      return arguments.length ? (sort = _2, sortValues = null, pie) : sort;
    };
    pie.startAngle = function(_2) {
      return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant_default2(+_2), pie) : startAngle;
    };
    pie.endAngle = function(_2) {
      return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant_default2(+_2), pie) : endAngle;
    };
    pie.padAngle = function(_2) {
      return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant_default2(+_2), pie) : padAngle;
    };
    return pie;
  }

  // node_modules/d3-shape/src/offset/none.js
  function none_default(series, order2) {
    if (!((n = series.length) > 1)) return;
    for (var i = 1, j, s0, s1 = series[order2[0]], n, m = s1.length; i < n; ++i) {
      s0 = s1, s1 = series[order2[i]];
      for (j = 0; j < m; ++j) {
        s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
      }
    }
  }

  // node_modules/d3-shape/src/order/none.js
  function none_default2(series) {
    var n = series.length, o = new Array(n);
    while (--n >= 0) o[n] = n;
    return o;
  }

  // node_modules/d3-shape/src/stack.js
  function stackValue(d, key) {
    return d[key];
  }
  function stackSeries(key) {
    const series = [];
    series.key = key;
    return series;
  }
  function stack_default() {
    var keys = constant_default2([]), order2 = none_default2, offset2 = none_default, value = stackValue;
    function stack(data) {
      var sz = Array.from(keys.apply(this, arguments), stackSeries), i, n = sz.length, j = -1, oz;
      for (const d of data) {
        for (i = 0, ++j; i < n; ++i) {
          (sz[i][j] = [0, +value(d, sz[i].key, j, data)]).data = d;
        }
      }
      for (i = 0, oz = array_default(order2(sz)); i < n; ++i) {
        sz[oz[i]].index = i;
      }
      offset2(sz, oz);
      return sz;
    }
    stack.keys = function(_2) {
      return arguments.length ? (keys = typeof _2 === "function" ? _2 : constant_default2(Array.from(_2)), stack) : keys;
    };
    stack.value = function(_2) {
      return arguments.length ? (value = typeof _2 === "function" ? _2 : constant_default2(+_2), stack) : value;
    };
    stack.order = function(_2) {
      return arguments.length ? (order2 = _2 == null ? none_default2 : typeof _2 === "function" ? _2 : constant_default2(Array.from(_2)), stack) : order2;
    };
    stack.offset = function(_2) {
      return arguments.length ? (offset2 = _2 == null ? none_default : _2, stack) : offset2;
    };
    return stack;
  }

  // node_modules/d3-shape/src/offset/expand.js
  function expand_default(series, order2) {
    if (!((n = series.length) > 0)) return;
    for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
      for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;
      if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
    }
    none_default(series, order2);
  }

  // node_modules/d3-shape/src/offset/diverging.js
  function diverging_default(series, order2) {
    if (!((n = series.length) > 0)) return;
    for (var i, j = 0, d, dy, yp, yn, n, m = series[order2[0]].length; j < m; ++j) {
      for (yp = yn = 0, i = 0; i < n; ++i) {
        if ((dy = (d = series[order2[i]][j])[1] - d[0]) > 0) {
          d[0] = yp, d[1] = yp += dy;
        } else if (dy < 0) {
          d[1] = yn, d[0] = yn += dy;
        } else {
          d[0] = 0, d[1] = dy;
        }
      }
    }
  }

  // node_modules/d3-shape/src/offset/silhouette.js
  function silhouette_default(series, order2) {
    if (!((n = series.length) > 0)) return;
    for (var j = 0, s0 = series[order2[0]], n, m = s0.length; j < m; ++j) {
      for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;
      s0[j][1] += s0[j][0] = -y / 2;
    }
    none_default(series, order2);
  }

  // node_modules/d3-shape/src/offset/wiggle.js
  function wiggle_default(series, order2) {
    if (!((n = series.length) > 0) || !((m = (s0 = series[order2[0]]).length) > 0)) return;
    for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
      for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
        var si = series[order2[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
        for (var k = 0; k < i; ++k) {
          var sk = series[order2[k]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
          s3 += skj0 - skj1;
        }
        s1 += sij0, s2 += s3 * sij0;
      }
      s0[j - 1][1] += s0[j - 1][0] = y;
      if (s1) y -= s2 / s1;
    }
    s0[j - 1][1] += s0[j - 1][0] = y;
    none_default(series, order2);
  }

  // node_modules/d3-shape/src/order/appearance.js
  function appearance_default(series) {
    var peaks = series.map(peak);
    return none_default2(series).sort(function(a, b) {
      return peaks[a] - peaks[b];
    });
  }
  function peak(series) {
    var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
    while (++i < n) if ((vi = +series[i][1]) > vj) vj = vi, j = i;
    return j;
  }

  // node_modules/d3-shape/src/order/ascending.js
  function ascending_default(series) {
    var sums = series.map(sum);
    return none_default2(series).sort(function(a, b) {
      return sums[a] - sums[b];
    });
  }
  function sum(series) {
    var s = 0, i = -1, n = series.length, v;
    while (++i < n) if (v = +series[i][1]) s += v;
    return s;
  }

  // node_modules/d3-shape/src/order/descending.js
  function descending_default2(series) {
    return ascending_default(series).reverse();
  }

  // node_modules/d3-shape/src/order/insideOut.js
  function insideOut_default(series) {
    var n = series.length, i, j, sums = series.map(sum), order2 = appearance_default(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];
    for (i = 0; i < n; ++i) {
      j = order2[i];
      if (top2 < bottom2) {
        top2 += sums[j];
        tops.push(j);
      } else {
        bottom2 += sums[j];
        bottoms.push(j);
      }
    }
    return bottoms.reverse().concat(tops);
  }

  // node_modules/d3-shape/src/order/reverse.js
  function reverse_default(series) {
    return none_default2(series).reverse();
  }

  // node_modules/@mui/x-charts/internals/stackSeries.js
  var StackOrder = {
    /**
     * Series order such that the earliest series (according to the maximum value) is at the bottom.
     * */
    appearance: appearance_default,
    /**
     *  Series order such that the smallest series (according to the sum of values) is at the bottom.
     * */
    ascending: ascending_default,
    /**
     * Series order such that the largest series (according to the sum of values) is at the bottom.
     */
    descending: descending_default2,
    /**
     * Series order such that the earliest series (according to the maximum value) are on the inside and the later series are on the outside. This order is recommended for streamgraphs in conjunction with the wiggle offset. See Stacked Graphs—Geometry & Aesthetics by Byron & Wattenberg for more information.
     */
    insideOut: insideOut_default,
    /**
     * Given series order [0, 1, … n - 1] where n is the number of elements in series. Thus, the stack order is given by the key accessor.
     */
    none: none_default2,
    /**
     * Reverse of the given series order [n - 1, n - 2, … 0] where n is the number of elements in series. Thus, the stack order is given by the reverse of the key accessor.
     */
    reverse: reverse_default
  };
  var StackOffset = {
    /**
     * Applies a zero baseline and normalizes the values for each point such that the topline is always one.
     * */
    expand: expand_default,
    /**
     * Positive values are stacked above zero, negative values are stacked below zero, and zero values are stacked at zero.
     * */
    diverging: diverging_default,
    /**
     * Applies a zero baseline.
     * */
    none: none_default,
    /**
     * Shifts the baseline down such that the center of the streamgraph is always at zero.
     * */
    silhouette: silhouette_default,
    /**
     * Shifts the baseline so as to minimize the weighted wiggle of layers. This offset is recommended for streamgraphs in conjunction with the inside-out order. See Stacked Graphs—Geometry & Aesthetics by Bryon & Wattenberg for more information.
     * */
    wiggle: wiggle_default
  };
  var getStackingGroups = (params) => {
    const {
      series,
      seriesOrder,
      defaultStrategy
    } = params;
    const stackingGroups = [];
    const stackIndex = {};
    seriesOrder.forEach((id) => {
      var _a, _b;
      const {
        stack,
        stackOrder,
        stackOffset
      } = series[id];
      if (stack === void 0) {
        stackingGroups.push({
          ids: [id],
          stackingOrder: StackOrder.none,
          stackingOffset: StackOffset.none
        });
      } else if (stackIndex[stack] === void 0) {
        stackIndex[stack] = stackingGroups.length;
        stackingGroups.push({
          ids: [id],
          stackingOrder: StackOrder[(_a = stackOrder != null ? stackOrder : defaultStrategy == null ? void 0 : defaultStrategy.stackOrder) != null ? _a : "none"],
          stackingOffset: StackOffset[(_b = stackOffset != null ? stackOffset : defaultStrategy == null ? void 0 : defaultStrategy.stackOffset) != null ? _b : "diverging"]
        });
      } else {
        stackingGroups[stackIndex[stack]].ids.push(id);
        if (stackOrder !== void 0) {
          stackingGroups[stackIndex[stack]].stackingOrder = StackOrder[stackOrder];
        }
        if (stackOffset !== void 0) {
          stackingGroups[stackIndex[stack]].stackingOffset = StackOffset[stackOffset];
        }
      }
    });
    return stackingGroups;
  };

  // node_modules/@mui/x-charts/internals/defaultizeValueFormatter.js
  function defaultizeValueFormatter(series, defaultValueFormatter) {
    const defaultizedSeries = {};
    Object.keys(series).forEach((seriesId) => {
      var _a;
      defaultizedSeries[seriesId] = _extends({}, series[seriesId], {
        valueFormatter: (_a = series[seriesId].valueFormatter) != null ? _a : defaultValueFormatter
      });
    });
    return defaultizedSeries;
  }

  // node_modules/@mui/x-charts/BarChart/formatter.js
  var formatter = (params, dataset) => {
    const {
      seriesOrder,
      series
    } = params;
    const stackingGroups = getStackingGroups(params);
    const d3Dataset = dataset != null ? dataset : [];
    seriesOrder.forEach((id) => {
      const data = series[id].data;
      if (data !== void 0) {
        data.forEach((value, index) => {
          if (d3Dataset.length <= index) {
            d3Dataset.push({
              [id]: value
            });
          } else {
            d3Dataset[index][id] = value;
          }
        });
      } else if (dataset === void 0) {
        throw new Error([`MUI X: bar series with id='${id}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join("\n"));
      }
    });
    const completedSeries = {};
    stackingGroups.forEach((stackingGroup) => {
      const {
        ids,
        stackingOffset,
        stackingOrder
      } = stackingGroup;
      const stackedSeries = stack_default().keys(ids.map((id) => {
        const dataKey = series[id].dataKey;
        return series[id].data === void 0 && dataKey !== void 0 ? dataKey : id;
      })).value((d, key) => {
        var _a;
        return (_a = d[key]) != null ? _a : 0;
      }).order(stackingOrder).offset(stackingOffset)(d3Dataset);
      ids.forEach((id, index) => {
        const dataKey = series[id].dataKey;
        completedSeries[id] = _extends({
          layout: "vertical"
        }, series[id], {
          data: dataKey ? dataset.map((data) => {
            const value = data[dataKey];
            if (typeof value !== "number") {
              if (false) {
                if (value !== null) {
                  warnOnce([`MUI X: your dataset key "${dataKey}" is used for plotting bars, but contains nonnumerical elements.`, "Bar plots only support numbers and null values."]);
                }
              }
              return 0;
            }
            return value;
          }) : series[id].data,
          stackedData: stackedSeries[index].map(([a, b]) => [a, b])
        });
      });
    });
    return {
      seriesOrder,
      stackingGroups,
      series: defaultizeValueFormatter(completedSeries, (v) => v == null ? "" : v.toLocaleString())
    };
  };
  var formatter_default = formatter;

  // node_modules/@mui/x-charts/BarChart/getColor.js
  var getColor = (series, xAxis, yAxis) => {
    const verticalLayout = series.layout === "vertical";
    const bandColorScale = verticalLayout ? xAxis == null ? void 0 : xAxis.colorScale : yAxis == null ? void 0 : yAxis.colorScale;
    const valueColorScale = verticalLayout ? yAxis == null ? void 0 : yAxis.colorScale : xAxis == null ? void 0 : xAxis.colorScale;
    const bandValues = verticalLayout ? xAxis == null ? void 0 : xAxis.data : yAxis == null ? void 0 : yAxis.data;
    if (valueColorScale) {
      return (dataIndex) => {
        const value = series.data[dataIndex];
        const color3 = value === null ? series.color : valueColorScale(value);
        if (color3 === null) {
          return series.color;
        }
        return color3;
      };
    }
    if (bandColorScale && bandValues) {
      return (dataIndex) => {
        const value = bandValues[dataIndex];
        const color3 = value === null ? series.color : bandColorScale(value);
        if (color3 === null) {
          return series.color;
        }
        return color3;
      };
    }
    return () => series.color;
  };
  var getColor_default = getColor;

  // node_modules/@mui/x-charts/BarChart/plugin.js
  var plugin = {
    seriesType: "bar",
    seriesFormatter: formatter_default,
    colorProcessor: getColor_default,
    xExtremumGetter: getExtremumX,
    yExtremumGetter: getExtremumY
  };

  // node_modules/@mui/x-charts/ScatterChart/extremums.js
  var mergeMinMax = (acc, val) => [val[0] === null ? acc[0] : Math.min(acc[0], val[0]), val[1] === null ? acc[1] : Math.max(acc[1], val[1])];
  var getExtremumX2 = (params) => {
    const {
      series,
      axis,
      isDefaultAxis,
      getFilters
    } = params;
    return Object.keys(series).filter((seriesId) => {
      var _a;
      const axisId = (_a = series[seriesId].xAxisId) != null ? _a : series[seriesId].xAxisKey;
      return axisId === axis.id || axisId === void 0 && isDefaultAxis;
    }).reduce((acc, seriesId) => {
      var _a, _b, _c;
      const filter = getFilters == null ? void 0 : getFilters({
        currentAxisId: axis.id,
        isDefaultAxis,
        seriesXAxisId: (_a = series[seriesId].xAxisId) != null ? _a : series[seriesId].xAxisKey,
        seriesYAxisId: (_b = series[seriesId].yAxisId) != null ? _b : series[seriesId].yAxisKey
      });
      const seriesMinMax = (_c = series[seriesId].data) == null ? void 0 : _c.reduce((accSeries, d, dataIndex) => {
        if (filter && !filter(d, dataIndex)) {
          return accSeries;
        }
        return mergeMinMax(accSeries, [d.x, d.x]);
      }, [Infinity, -Infinity]);
      return mergeMinMax(acc, seriesMinMax != null ? seriesMinMax : [Infinity, -Infinity]);
    }, [Infinity, -Infinity]);
  };
  var getExtremumY2 = (params) => {
    const {
      series,
      axis,
      isDefaultAxis,
      getFilters
    } = params;
    return Object.keys(series).filter((seriesId) => {
      var _a;
      const axisId = (_a = series[seriesId].yAxisId) != null ? _a : series[seriesId].yAxisKey;
      return axisId === axis.id || axisId === void 0 && isDefaultAxis;
    }).reduce((acc, seriesId) => {
      var _a, _b, _c;
      const filter = getFilters == null ? void 0 : getFilters({
        currentAxisId: axis.id,
        isDefaultAxis,
        seriesXAxisId: (_a = series[seriesId].xAxisId) != null ? _a : series[seriesId].xAxisKey,
        seriesYAxisId: (_b = series[seriesId].yAxisId) != null ? _b : series[seriesId].yAxisKey
      });
      const seriesMinMax = (_c = series[seriesId].data) == null ? void 0 : _c.reduce((accSeries, d, dataIndex) => {
        if (filter && !filter(d, dataIndex)) {
          return accSeries;
        }
        return mergeMinMax(accSeries, [d.y, d.y]);
      }, [Infinity, -Infinity]);
      return mergeMinMax(acc, seriesMinMax != null ? seriesMinMax : [Infinity, -Infinity]);
    }, [Infinity, -Infinity]);
  };

  // node_modules/@mui/x-charts/ScatterChart/formatter.js
  var formatter2 = ({
    series,
    seriesOrder
  }, dataset) => {
    const completeSeries = Object.fromEntries(Object.entries(series).map(([seriesId, seriesData]) => {
      var _a, _b, _c;
      const datasetKeys = seriesData == null ? void 0 : seriesData.datasetKeys;
      const missingKeys = ["x", "y", "id"].filter((key) => typeof (datasetKeys == null ? void 0 : datasetKeys[key]) !== "string");
      if ((seriesData == null ? void 0 : seriesData.datasetKeys) && missingKeys.length > 0) {
        throw new Error([`MUI X: scatter series with id='${seriesId}' has incomplete datasetKeys.`, `Properties ${missingKeys.map((key) => `"${key}"`).join(", ")} are missing.`].join("\n"));
      }
      const data = !datasetKeys ? (_a = seriesData.data) != null ? _a : [] : (_b = dataset == null ? void 0 : dataset.map((d) => {
        var _a2, _b2;
        return {
          x: (_a2 = d[datasetKeys.x]) != null ? _a2 : null,
          y: (_b2 = d[datasetKeys.y]) != null ? _b2 : null,
          z: datasetKeys.z && d[datasetKeys.z],
          id: d[datasetKeys.id]
        };
      })) != null ? _b : [];
      return [seriesId, _extends({}, seriesData, {
        data,
        valueFormatter: (_c = seriesData.valueFormatter) != null ? _c : (v) => `(${v.x}, ${v.y})`
      })];
    }));
    return {
      series: completeSeries,
      seriesOrder
    };
  };
  var formatter_default2 = formatter2;

  // node_modules/@mui/x-charts/ScatterChart/getColor.js
  var getColor2 = (series, xAxis, yAxis, zAxis) => {
    const zColorScale = zAxis == null ? void 0 : zAxis.colorScale;
    const yColorScale = yAxis == null ? void 0 : yAxis.colorScale;
    const xColorScale = xAxis == null ? void 0 : xAxis.colorScale;
    if (zColorScale) {
      return (dataIndex) => {
        var _a, _b;
        if (((_a = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _a[dataIndex]) !== void 0) {
          const color4 = zColorScale((_b = zAxis == null ? void 0 : zAxis.data) == null ? void 0 : _b[dataIndex]);
          if (color4 !== null) {
            return color4;
          }
        }
        const value = series.data[dataIndex];
        const color3 = value === null ? series.color : zColorScale(value.z);
        if (color3 === null) {
          return series.color;
        }
        return color3;
      };
    }
    if (yColorScale) {
      return (dataIndex) => {
        const value = series.data[dataIndex];
        const color3 = value === null ? series.color : yColorScale(value.y);
        if (color3 === null) {
          return series.color;
        }
        return color3;
      };
    }
    if (xColorScale) {
      return (dataIndex) => {
        const value = series.data[dataIndex];
        const color3 = value === null ? series.color : xColorScale(value.x);
        if (color3 === null) {
          return series.color;
        }
        return color3;
      };
    }
    return () => series.color;
  };
  var getColor_default2 = getColor2;

  // node_modules/@mui/x-charts/ScatterChart/plugin.js
  var plugin2 = {
    seriesType: "scatter",
    seriesFormatter: formatter_default2,
    colorProcessor: getColor_default2,
    xExtremumGetter: getExtremumX2,
    yExtremumGetter: getExtremumY2
  };

  // node_modules/@mui/x-charts/LineChart/extremums.js
  var getExtremumX3 = (params) => {
    var _a, _b;
    const {
      axis
    } = params;
    const minX = Math.min(...(_a = axis.data) != null ? _a : []);
    const maxX = Math.max(...(_b = axis.data) != null ? _b : []);
    return [minX, maxX];
  };
  function getSeriesExtremums(getValues, stackedData, filter) {
    return stackedData.reduce((seriesAcc, stackedValue, index) => {
      const [base, value] = getValues(stackedValue);
      if (filter && (!filter({
        y: base,
        x: null
      }, index) || !filter({
        y: value,
        x: null
      }, index))) {
        return seriesAcc;
      }
      return [Math.min(base, value, seriesAcc[0]), Math.max(base, value, seriesAcc[1])];
    }, [Infinity, -Infinity]);
  }
  var getExtremumY3 = (params) => {
    const {
      series,
      axis,
      isDefaultAxis,
      getFilters
    } = params;
    return Object.keys(series).filter((seriesId) => {
      var _a;
      const yAxisId = (_a = series[seriesId].yAxisId) != null ? _a : series[seriesId].yAxisKey;
      return yAxisId === axis.id || isDefaultAxis && yAxisId === void 0;
    }).reduce((acc, seriesId) => {
      var _a, _b;
      const {
        area,
        stackedData
      } = series[seriesId];
      const isArea = area !== void 0;
      const filter = getFilters == null ? void 0 : getFilters({
        currentAxisId: axis.id,
        isDefaultAxis,
        seriesXAxisId: (_a = series[seriesId].xAxisId) != null ? _a : series[seriesId].xAxisKey,
        seriesYAxisId: (_b = series[seriesId].yAxisId) != null ? _b : series[seriesId].yAxisKey
      });
      const getValues = isArea && axis.scaleType !== "log" && typeof series[seriesId].baseline !== "string" ? (d) => d : (d) => [d[1], d[1]];
      const seriesExtremums = getSeriesExtremums(getValues, stackedData, filter);
      const [seriesMin, seriesMax] = seriesExtremums;
      return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];
    }, [Infinity, -Infinity]);
  };

  // node_modules/@mui/x-charts/LineChart/formatter.js
  var formatter3 = (params, dataset) => {
    const {
      seriesOrder,
      series
    } = params;
    const stackingGroups = getStackingGroups(_extends({}, params, {
      defaultStrategy: {
        stackOffset: "none"
      }
    }));
    const d3Dataset = dataset != null ? dataset : [];
    seriesOrder.forEach((id) => {
      const data = series[id].data;
      if (data !== void 0) {
        data.forEach((value, index) => {
          if (d3Dataset.length <= index) {
            d3Dataset.push({
              [id]: value
            });
          } else {
            d3Dataset[index][id] = value;
          }
        });
      } else if (dataset === void 0 && false) {
        throw new Error([`MUI X: line series with id='${id}' has no data.`, "Either provide a data property to the series or use the dataset prop."].join("\n"));
      }
    });
    const completedSeries = {};
    stackingGroups.forEach((stackingGroup) => {
      const {
        ids,
        stackingOrder,
        stackingOffset
      } = stackingGroup;
      const stackedSeries = stack_default().keys(ids.map((id) => {
        const dataKey = series[id].dataKey;
        return series[id].data === void 0 && dataKey !== void 0 ? dataKey : id;
      })).value((d, key) => {
        var _a;
        return (_a = d[key]) != null ? _a : 0;
      }).order(stackingOrder).offset(stackingOffset)(d3Dataset);
      ids.forEach((id, index) => {
        const dataKey = series[id].dataKey;
        completedSeries[id] = _extends({}, series[id], {
          data: dataKey ? dataset.map((data) => {
            const value = data[dataKey];
            if (typeof value !== "number") {
              if (false) {
                if (value !== null) {
                  warnOnce([`MUI X: Your dataset key "${dataKey}" is used for plotting line, but contains nonnumerical elements.`, "Line plots only support numbers and null values."]);
                }
              }
              return null;
            }
            return value;
          }) : series[id].data,
          stackedData: stackedSeries[index].map(([a, b]) => [a, b])
        });
      });
    });
    return {
      seriesOrder,
      stackingGroups,
      series: defaultizeValueFormatter(completedSeries, (v) => v == null ? "" : v.toLocaleString())
    };
  };
  var formatter_default3 = formatter3;

  // node_modules/@mui/x-charts/LineChart/getColor.js
  var getColor3 = (series, xAxis, yAxis) => {
    const yColorScale = yAxis == null ? void 0 : yAxis.colorScale;
    const xColorScale = xAxis == null ? void 0 : xAxis.colorScale;
    if (yColorScale) {
      return (dataIndex) => {
        const value = series.data[dataIndex];
        const color3 = value === null ? series.color : yColorScale(value);
        if (color3 === null) {
          return series.color;
        }
        return color3;
      };
    }
    if (xColorScale) {
      return (dataIndex) => {
        var _a;
        const value = (_a = xAxis.data) == null ? void 0 : _a[dataIndex];
        const color3 = value === null ? series.color : xColorScale(value);
        if (color3 === null) {
          return series.color;
        }
        return color3;
      };
    }
    return () => series.color;
  };
  var getColor_default3 = getColor3;

  // node_modules/@mui/x-charts/LineChart/plugin.js
  var plugin3 = {
    seriesType: "line",
    colorProcessor: getColor_default3,
    seriesFormatter: formatter_default3,
    xExtremumGetter: getExtremumX3,
    yExtremumGetter: getExtremumY3
  };

  // node_modules/@mui/x-charts/internals/getLabel.js
  function getLabel(value, location2) {
    return typeof value === "function" ? value(location2) : value;
  }

  // node_modules/@mui/x-charts/PieChart/formatter.js
  var getSortingComparator = (comparator = "none") => {
    if (typeof comparator === "function") {
      return comparator;
    }
    switch (comparator) {
      case "none":
        return null;
      case "desc":
        return (a, b) => b - a;
      case "asc":
        return (a, b) => a - b;
      default:
        return null;
    }
  };
  var formatter4 = (params) => {
    const {
      seriesOrder,
      series
    } = params;
    const defaultizedSeries = {};
    seriesOrder.forEach((seriesId) => {
      var _a, _b, _c, _d;
      const arcs = pie_default().startAngle(2 * Math.PI * ((_a = series[seriesId].startAngle) != null ? _a : 0) / 360).endAngle(2 * Math.PI * ((_b = series[seriesId].endAngle) != null ? _b : 360) / 360).padAngle(2 * Math.PI * ((_c = series[seriesId].paddingAngle) != null ? _c : 0) / 360).sortValues(getSortingComparator((_d = series[seriesId].sortingValues) != null ? _d : "none"))(series[seriesId].data.map((piePoint) => piePoint.value));
      defaultizedSeries[seriesId] = _extends({
        valueFormatter: (item) => item.value.toLocaleString()
      }, series[seriesId], {
        data: series[seriesId].data.map((item, index) => {
          var _a2;
          return _extends({}, item, {
            id: (_a2 = item.id) != null ? _a2 : `auto-generated-pie-id-${seriesId}-${index}`
          }, arcs[index]);
        }).map((item, index) => {
          var _a2, _b2, _c2;
          return _extends({}, item, {
            formattedValue: (_c2 = (_b2 = (_a2 = series[seriesId]).valueFormatter) == null ? void 0 : _b2.call(_a2, _extends({}, item, {
              label: getLabel(item.label, "arc")
            }), {
              dataIndex: index
            })) != null ? _c2 : item.value.toLocaleString()
          });
        })
      });
    });
    return {
      seriesOrder,
      series: defaultizedSeries
    };
  };
  var formatter_default4 = formatter4;

  // node_modules/@mui/x-charts/PieChart/getColor.js
  var getColor4 = (series) => {
    return (dataIndex) => {
      return series.data[dataIndex].color;
    };
  };
  var getColor_default4 = getColor4;

  // node_modules/@mui/x-charts/PieChart/plugin.js
  var plugin4 = {
    seriesType: "pie",
    colorProcessor: getColor_default4,
    seriesFormatter: formatter_default4
  };

  // node_modules/@mui/x-charts/context/PluginProvider/mergePlugins.js
  var defaultPlugins = [plugin, plugin2, plugin3, plugin4];
  function mergePlugins(plugins) {
    const defaultizedPlugins = plugins != null ? plugins : defaultPlugins;
    const seriesFormatters = {};
    const colorProcessors = {};
    const xExtremumGetters = {};
    const yExtremumGetters = {};
    const rotationExtremumGetters = {};
    const radiusExtremumGetters = {};
    for (let i = 0; i < defaultizedPlugins.length; i += 1) {
      const plugin5 = defaultizedPlugins[i];
      const seriesType = plugin5.seriesType;
      seriesFormatters[seriesType] = plugin5.seriesFormatter;
      colorProcessors[seriesType] = plugin5.colorProcessor;
      if (plugin5.xExtremumGetter) {
        xExtremumGetters[seriesType] = plugin5.xExtremumGetter;
      }
      if (plugin5.yExtremumGetter) {
        yExtremumGetters[seriesType] = plugin5.yExtremumGetter;
      }
      if (plugin5.rotationExtremumGetter) {
        rotationExtremumGetters[seriesType] = plugin5.rotationExtremumGetter;
      }
      if (plugin5.radiusExtremumGetter) {
        radiusExtremumGetters[seriesType] = plugin5.radiusExtremumGetter;
      }
    }
    return {
      seriesFormatters,
      colorProcessors,
      xExtremumGetters,
      yExtremumGetters,
      rotationExtremumGetters,
      radiusExtremumGetters
    };
  }

  // node_modules/@mui/x-charts/context/PluginProvider/PluginProvider.js
  var import_jsx_runtime54 = __toESM(require_jsx_runtime());
  function PluginProvider(props) {
    const {
      children,
      plugins
    } = props;
    const formattedSeries = React86.useMemo(() => ({
      isInitialized: true,
      data: mergePlugins(plugins)
    }), [plugins]);
    return /* @__PURE__ */ (0, import_jsx_runtime54.jsx)(PluginContext.Provider, {
      value: formattedSeries,
      children
    });
  }

  // node_modules/@mui/x-charts/context/PluginProvider/useColorProcessor.js
  var React87 = __toESM(require_react());
  function useColorProcessor(seriesType) {
    const {
      isInitialized,
      data
    } = React87.useContext(PluginContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    if (!seriesType) {
      return data.colorProcessors;
    }
    return data.colorProcessors[seriesType];
  }

  // node_modules/@mui/x-charts/context/PluginProvider/useSeriesFormatter.js
  var React88 = __toESM(require_react());
  function useSeriesFormatter(seriesType) {
    const {
      isInitialized,
      data
    } = React88.useContext(PluginContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    if (!seriesType) {
      return data.seriesFormatters;
    }
    return data.seriesFormatters[seriesType];
  }

  // node_modules/@mui/x-charts/context/PluginProvider/useXExtremumGetter.js
  var React89 = __toESM(require_react());
  function useXExtremumGetter(seriesType) {
    const {
      isInitialized,
      data
    } = React89.useContext(PluginContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    if (!seriesType) {
      return data.xExtremumGetters;
    }
    return data.xExtremumGetters[seriesType];
  }

  // node_modules/@mui/x-charts/context/PluginProvider/useYExtremumGetter.js
  var React90 = __toESM(require_react());
  function useYExtremumGetter(seriesType) {
    const {
      isInitialized,
      data
    } = React90.useContext(PluginContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the plugin context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    if (!seriesType) {
      return data.yExtremumGetters;
    }
    return data.yExtremumGetters[seriesType];
  }

  // node_modules/@mui/x-charts/context/SeriesProvider/SeriesProvider.js
  var import_jsx_runtime55 = __toESM(require_jsx_runtime());
  function SeriesProvider(props) {
    const {
      series,
      dataset,
      colors: colors3 = blueberryTwilightPalette,
      children
    } = props;
    const seriesFormatters = useSeriesFormatter();
    const theme = useTheme5();
    const formattedSeries = React91.useMemo(() => ({
      isInitialized: true,
      data: preprocessSeries({
        series,
        colors: typeof colors3 === "function" ? colors3(theme.palette.mode) : colors3,
        seriesFormatters,
        dataset
      })
    }), [series, colors3, theme.palette.mode, seriesFormatters, dataset]);
    return /* @__PURE__ */ (0, import_jsx_runtime55.jsx)(SeriesContext.Provider, {
      value: formattedSeries,
      children
    });
  }

  // node_modules/@mui/x-charts/hooks/useSeries.js
  function useSeries() {
    const {
      isInitialized,
      data
    } = React92.useContext(SeriesContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the series ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    return data;
  }
  function useBarSeries() {
    const series = useSeries();
    return React92.useMemo(() => series.bar, [series.bar]);
  }

  // node_modules/@mui/x-charts/context/CartesianProvider/CartesianContext.js
  var React93 = __toESM(require_react());
  var CartesianContext = /* @__PURE__ */ React93.createContext({
    isInitialized: false,
    data: {
      xAxis: {},
      yAxis: {},
      xAxisIds: [],
      yAxisIds: []
    }
  });
  if (false) {
    CartesianContext.displayName = "CartesianContext";
  }

  // node_modules/@mui/x-charts/context/CartesianProvider/CartesianProvider.js
  var import_jsx_runtime56 = __toESM(require_jsx_runtime());
  function CartesianProvider(props) {
    const {
      xAxis,
      yAxis,
      children
    } = props;
    const formattedSeries = useSeries();
    const drawingArea = useDrawingArea();
    const xExtremumGetters = useXExtremumGetter();
    const yExtremumGetters = useYExtremumGetter();
    const xValues = React94.useMemo(() => computeAxisValue({
      drawingArea,
      formattedSeries,
      axis: xAxis,
      extremumGetters: xExtremumGetters,
      axisDirection: "x"
    }), [drawingArea, formattedSeries, xAxis, xExtremumGetters]);
    const yValues = React94.useMemo(() => computeAxisValue({
      drawingArea,
      formattedSeries,
      axis: yAxis,
      extremumGetters: yExtremumGetters,
      axisDirection: "y"
    }), [drawingArea, formattedSeries, yAxis, yExtremumGetters]);
    const value = React94.useMemo(() => ({
      isInitialized: true,
      data: {
        xAxis: xValues.axis,
        yAxis: yValues.axis,
        xAxisIds: xValues.axisIds,
        yAxisIds: yValues.axisIds
      }
    }), [xValues, yValues]);
    return /* @__PURE__ */ (0, import_jsx_runtime56.jsx)(CartesianContext.Provider, {
      value,
      children
    });
  }

  // node_modules/@mui/x-charts/context/CartesianProvider/useCartesianContext.js
  var React95 = __toESM(require_react());
  var useCartesianContext = () => {
    const {
      data
    } = React95.useContext(CartesianContext);
    return data;
  };

  // node_modules/@mui/x-charts/BarChart/BarElement.js
  var React104 = __toESM(require_react());

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/composeClasses/composeClasses.js
  function composeClasses2(slots, getUtilityClass, classes = void 0) {
    const output = {};
    for (const slotName in slots) {
      const slot = slots[slotName];
      let buffer = "";
      let start3 = true;
      for (let i = 0; i < slot.length; i += 1) {
        const value = slot[i];
        if (value) {
          buffer += (start3 === true ? "" : " ") + getUtilityClass(value);
          start3 = false;
          if (classes && classes[value]) {
            buffer += " " + classes[value];
          }
        }
      }
      output[slotName] = buffer;
    }
    return output;
  }

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/useForkRef/useForkRef.js
  var React96 = __toESM(require_react(), 1);
  function useForkRef2(...refs) {
    const cleanupRef = React96.useRef(void 0);
    const refEffect = React96.useCallback((instance2) => {
      const cleanups = refs.map((ref) => {
        if (ref == null) {
          return null;
        }
        if (typeof ref === "function") {
          const refCallback = ref;
          const refCleanup = refCallback(instance2);
          return typeof refCleanup === "function" ? refCleanup : () => {
            refCallback(null);
          };
        }
        ref.current = instance2;
        return () => {
          ref.current = null;
        };
      });
      return () => {
        cleanups.forEach((refCleanup) => refCleanup == null ? void 0 : refCleanup());
      };
    }, refs);
    return React96.useMemo(() => {
      if (refs.every((ref) => ref == null)) {
        return null;
      }
      return (value) => {
        if (cleanupRef.current) {
          cleanupRef.current();
          cleanupRef.current = void 0;
        }
        if (value != null) {
          cleanupRef.current = refEffect(value);
        }
      };
    }, refs);
  }

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/isHostComponent/isHostComponent.js
  function isHostComponent2(element) {
    return typeof element === "string";
  }
  var isHostComponent_default2 = isHostComponent2;

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/appendOwnerState/appendOwnerState.js
  function appendOwnerState2(elementType, otherProps, ownerState) {
    if (elementType === void 0 || isHostComponent_default2(elementType)) {
      return otherProps;
    }
    return __spreadProps(__spreadValues({}, otherProps), {
      ownerState: __spreadValues(__spreadValues({}, otherProps.ownerState), ownerState)
    });
  }
  var appendOwnerState_default2 = appendOwnerState2;

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/extractEventHandlers/extractEventHandlers.js
  function extractEventHandlers2(object, excludeKeys = []) {
    if (object === void 0) {
      return {};
    }
    const result = {};
    Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
      result[prop] = object[prop];
    });
    return result;
  }
  var extractEventHandlers_default2 = extractEventHandlers2;

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/omitEventHandlers/omitEventHandlers.js
  function omitEventHandlers2(object) {
    if (object === void 0) {
      return {};
    }
    const result = {};
    Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
      result[prop] = object[prop];
    });
    return result;
  }
  var omitEventHandlers_default2 = omitEventHandlers2;

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/mergeSlotProps/mergeSlotProps.js
  function mergeSlotProps2(parameters) {
    const {
      getSlotProps,
      additionalProps,
      externalSlotProps,
      externalForwardedProps,
      className
    } = parameters;
    if (!getSlotProps) {
      const joinedClasses2 = clsx_default(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
      const mergedStyle2 = __spreadValues(__spreadValues(__spreadValues({}, additionalProps == null ? void 0 : additionalProps.style), externalForwardedProps == null ? void 0 : externalForwardedProps.style), externalSlotProps == null ? void 0 : externalSlotProps.style);
      const props2 = __spreadValues(__spreadValues(__spreadValues({}, additionalProps), externalForwardedProps), externalSlotProps);
      if (joinedClasses2.length > 0) {
        props2.className = joinedClasses2;
      }
      if (Object.keys(mergedStyle2).length > 0) {
        props2.style = mergedStyle2;
      }
      return {
        props: props2,
        internalRef: void 0
      };
    }
    const eventHandlers = extractEventHandlers_default2(__spreadValues(__spreadValues({}, externalForwardedProps), externalSlotProps));
    const componentsPropsWithoutEventHandlers = omitEventHandlers_default2(externalSlotProps);
    const otherPropsWithoutEventHandlers = omitEventHandlers_default2(externalForwardedProps);
    const internalSlotProps = getSlotProps(eventHandlers);
    const joinedClasses = clsx_default(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
    const mergedStyle = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, internalSlotProps == null ? void 0 : internalSlotProps.style), additionalProps == null ? void 0 : additionalProps.style), externalForwardedProps == null ? void 0 : externalForwardedProps.style), externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props = __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, internalSlotProps), additionalProps), otherPropsWithoutEventHandlers), componentsPropsWithoutEventHandlers);
    if (joinedClasses.length > 0) {
      props.className = joinedClasses;
    }
    if (Object.keys(mergedStyle).length > 0) {
      props.style = mergedStyle;
    }
    return {
      props,
      internalRef: internalSlotProps.ref
    };
  }
  var mergeSlotProps_default2 = mergeSlotProps2;

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/resolveComponentProps/resolveComponentProps.js
  function resolveComponentProps2(componentProps, ownerState, slotState) {
    if (typeof componentProps === "function") {
      return componentProps(ownerState, slotState);
    }
    return componentProps;
  }
  var resolveComponentProps_default2 = resolveComponentProps2;

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/useSlotProps/useSlotProps.js
  function useSlotProps2(parameters) {
    var _b;
    const _a = parameters, {
      elementType,
      externalSlotProps,
      ownerState,
      skipResolvingSlotProps = false
    } = _a, other = __objRest(_a, [
      "elementType",
      "externalSlotProps",
      "ownerState",
      "skipResolvingSlotProps"
    ]);
    const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps_default2(externalSlotProps, ownerState);
    const {
      props: mergedProps,
      internalRef
    } = mergeSlotProps_default2(__spreadProps(__spreadValues({}, other), {
      externalSlotProps: resolvedComponentsProps
    }));
    const ref = useForkRef2(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_b = parameters.additionalProps) == null ? void 0 : _b.ref);
    const props = appendOwnerState_default2(elementType, __spreadProps(__spreadValues({}, mergedProps), {
      ref
    }), ownerState);
    return props;
  }
  var useSlotProps_default2 = useSlotProps2;

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/ClassNameGenerator/ClassNameGenerator.js
  var defaultGenerator2 = (componentName) => componentName;
  var createClassNameGenerator2 = () => {
    let generate = defaultGenerator2;
    return {
      configure(generator) {
        generate = generator;
      },
      generate(componentName) {
        return generate(componentName);
      },
      reset() {
        generate = defaultGenerator2;
      }
    };
  };
  var ClassNameGenerator2 = createClassNameGenerator2();
  var ClassNameGenerator_default2 = ClassNameGenerator2;

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js
  var globalStateClasses2 = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
  };
  function generateUtilityClass2(componentName, slot, globalStatePrefix = "Mui") {
    const globalStateClass = globalStateClasses2[slot];
    return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator_default2.generate(componentName)}-${slot}`;
  }

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/generateUtilityClasses/generateUtilityClasses.js
  function generateUtilityClasses2(componentName, slots, globalStatePrefix = "Mui") {
    const result = {};
    slots.forEach((slot) => {
      result[slot] = generateUtilityClass2(componentName, slot, globalStatePrefix);
    });
    return result;
  }

  // node_modules/@mui/x-charts/hooks/useInteractionItemProps.js
  var React103 = __toESM(require_react());

  // node_modules/@mui/x-charts/context/InteractionProvider.js
  var React97 = __toESM(require_react());
  var import_jsx_runtime57 = __toESM(require_jsx_runtime());
  var InteractionContext = /* @__PURE__ */ React97.createContext({
    item: null,
    axis: {
      x: null,
      y: null
    },
    useVoronoiInteraction: false,
    dispatch: () => null
  });
  if (false) {
    InteractionContext.displayName = "InteractionContext";
  }
  var dataReducer = (prevState, action) => {
    switch (action.type) {
      case "enterItem":
        return _extends({}, prevState, {
          item: action.data
        });
      case "exitChart":
        if (prevState.item === null && prevState.axis.x === null && prevState.axis.y === null) {
          return prevState;
        }
        return _extends({}, prevState, {
          axis: {
            x: null,
            y: null
          },
          item: null
        });
      case "updateVoronoiUsage":
        return _extends({}, prevState, {
          useVoronoiInteraction: action.useVoronoiInteraction
        });
      case "leaveItem":
        if (prevState.item === null || Object.keys(action.data).some((key) => action.data[key] !== prevState.item[key])) {
          return prevState;
        }
        return _extends({}, prevState, {
          item: null
        });
      case "updateAxis":
        if (action.data.x === prevState.axis.x && action.data.y === prevState.axis.y) {
          return prevState;
        }
        return _extends({}, prevState, {
          axis: action.data
        });
      default:
        return prevState;
    }
  };
  function InteractionProvider(props) {
    const {
      children
    } = props;
    const [data, dispatch] = React97.useReducer(dataReducer, {
      item: null,
      axis: {
        x: null,
        y: null
      },
      useVoronoiInteraction: false
    });
    const value = React97.useMemo(() => _extends({}, data, {
      dispatch
    }), [data]);
    return /* @__PURE__ */ (0, import_jsx_runtime57.jsx)(InteractionContext.Provider, {
      value,
      children
    });
  }

  // node_modules/@mui/x-charts/context/HighlightedProvider/HighlightedProvider.js
  var React100 = __toESM(require_react());

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/useControlled/useControlled.js
  var React98 = __toESM(require_react(), 1);
  function useControlled({
    controlled,
    default: defaultProp,
    name,
    state = "value"
  }) {
    const {
      current: isControlled
    } = React98.useRef(controlled !== void 0);
    const [valueState, setValue] = React98.useState(defaultProp);
    const value = isControlled ? controlled : valueState;
    if (false) {
      React98.useEffect(() => {
        if (isControlled !== (controlled !== void 0)) {
          console.error([`MUI: A component is changing the ${isControlled ? "" : "un"}controlled ${state} state of ${name} to be ${isControlled ? "un" : ""}controlled.`, "Elements should not switch from uncontrolled to controlled (or vice versa).", `Decide between using a controlled or uncontrolled ${name} element for the lifetime of the component.`, "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", "More info: https://fb.me/react-controlled-components"].join("\n"));
        }
      }, [state, name, controlled]);
      const {
        current: defaultValue
      } = React98.useRef(defaultProp);
      React98.useEffect(() => {
        if (!isControlled && !Object.is(defaultValue, defaultProp)) {
          console.error([`MUI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. To suppress this warning opt to use a controlled ${name}.`].join("\n"));
        }
      }, [JSON.stringify(defaultProp)]);
    }
    const setValueIfUncontrolled = React98.useCallback((newValue) => {
      if (!isControlled) {
        setValue(newValue);
      }
    }, []);
    return [value, setValueIfUncontrolled];
  }

  // node_modules/@mui/x-charts/context/HighlightedProvider/HighlightedContext.js
  var React99 = __toESM(require_react());
  var HighlightedContext = /* @__PURE__ */ React99.createContext({
    isInitialized: false,
    data: {
      highlightedItem: null,
      setHighlighted: () => {
      },
      clearHighlighted: () => {
      },
      isHighlighted: () => false,
      isFaded: () => false
    }
  });
  if (false) {
    HighlightedContext.displayName = "HighlightedContext";
  }

  // node_modules/@mui/x-charts/context/HighlightedProvider/createIsFaded.js
  var createIsFaded = (highlightScope, highlightedItem) => (input) => {
    if (!highlightScope) {
      return false;
    }
    if (highlightScope.fade === "series") {
      return input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId) && input.dataIndex !== (highlightedItem == null ? void 0 : highlightedItem.dataIndex);
    }
    if (highlightScope.fade === "global") {
      return input.seriesId !== (highlightedItem == null ? void 0 : highlightedItem.seriesId) || input.dataIndex !== (highlightedItem == null ? void 0 : highlightedItem.dataIndex);
    }
    return false;
  };

  // node_modules/@mui/x-charts/context/HighlightedProvider/createIsHighlighted.js
  var createIsHighlighted = (highlightScope, highlightedItem) => (input) => {
    if (!highlightScope) {
      return false;
    }
    if (highlightScope.highlight === "series") {
      return input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId);
    }
    if (highlightScope.highlight === "item") {
      return input.dataIndex === (highlightedItem == null ? void 0 : highlightedItem.dataIndex) && input.seriesId === (highlightedItem == null ? void 0 : highlightedItem.seriesId);
    }
    return false;
  };

  // node_modules/@mui/x-charts/context/HighlightedProvider/HighlightedProvider.js
  var import_jsx_runtime58 = __toESM(require_jsx_runtime());
  var _excluded = ["highlighted", "faded"];
  var mergeDeprecatedOptions = (options) => {
    const _ref = options != null ? options : {}, {
      highlighted,
      faded
    } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded);
    return _extends({
      highlight: highlighted,
      fade: faded
    }, other);
  };
  function HighlightedProvider({
    children,
    highlightedItem: highlightedItemProps,
    onHighlightChange
  }) {
    var _a;
    const [highlightedItem, setHighlightedItem] = useControlled({
      controlled: highlightedItemProps,
      default: null,
      name: "HighlightedProvider",
      state: "highlightedItem"
    });
    const series = useSeries();
    const seriesById = React100.useMemo(() => {
      const map2 = /* @__PURE__ */ new Map();
      Object.keys(series).forEach((seriesType) => {
        var _a2;
        const seriesData = series[seriesType];
        Object.keys((_a2 = seriesData == null ? void 0 : seriesData.series) != null ? _a2 : {}).forEach((seriesId) => {
          const seriesItem = seriesData == null ? void 0 : seriesData.series[seriesId];
          map2.set(seriesId, mergeDeprecatedOptions(seriesItem == null ? void 0 : seriesItem.highlightScope));
        });
      });
      return map2;
    }, [series]);
    const highlightScope = highlightedItem && highlightedItem.seriesId ? (_a = seriesById.get(highlightedItem.seriesId)) != null ? _a : void 0 : void 0;
    const providerValue = React100.useMemo(() => {
      return {
        isInitialized: true,
        data: {
          highlightScope,
          highlightedItem,
          setHighlighted: (itemData) => {
            setHighlightedItem(itemData);
            onHighlightChange == null ? void 0 : onHighlightChange(itemData);
          },
          clearHighlighted: () => {
            setHighlightedItem(null);
            onHighlightChange == null ? void 0 : onHighlightChange(null);
          },
          isHighlighted: createIsHighlighted(highlightScope, highlightedItem),
          isFaded: createIsFaded(highlightScope, highlightedItem)
        }
      };
    }, [highlightedItem, highlightScope, setHighlightedItem, onHighlightChange]);
    return /* @__PURE__ */ (0, import_jsx_runtime58.jsx)(HighlightedContext.Provider, {
      value: providerValue,
      children
    });
  }
  false ? HighlightedProvider.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    children: import_prop_types.default.node,
    /**
     * The item currently highlighted. Turns highlighting into a controlled prop.
     */
    highlightedItem: import_prop_types.default.shape({
      dataIndex: import_prop_types.default.number,
      seriesId: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])
    }),
    /**
     * The callback fired when the highlighted item changes.
     *
     * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
     */
    onHighlightChange: import_prop_types.default.func
  } : void 0;

  // node_modules/@mui/x-charts/context/HighlightedProvider/useHighlighted.js
  var React101 = __toESM(require_react());
  function useHighlighted() {
    const {
      isInitialized,
      data
    } = React101.useContext(HighlightedContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the highlighted ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    return data;
  }

  // node_modules/@mui/x-charts/context/HighlightedProvider/useItemHighlighted.js
  function useItemHighlighted(item) {
    const highlighted = useHighlighted();
    if (!item) {
      return {
        isHighlighted: false,
        isFaded: false
      };
    }
    const isHighlighted = highlighted.isHighlighted(item);
    const isFaded = !isHighlighted && highlighted.isFaded(item);
    return {
      isHighlighted,
      isFaded
    };
  }

  // node_modules/@mui/x-charts/context/ZAxisContextProvider.js
  var React102 = __toESM(require_react());
  var import_jsx_runtime59 = __toESM(require_jsx_runtime());
  var ZAxisContext = /* @__PURE__ */ React102.createContext({
    zAxis: {},
    zAxisIds: []
  });
  if (false) {
    ZAxisContext.displayName = "ZAxisContext";
  }
  function ZAxisContextProvider(props) {
    const {
      zAxis: inZAxis,
      dataset,
      children
    } = props;
    const zAxis = React102.useMemo(() => inZAxis == null ? void 0 : inZAxis.map((axisConfig) => {
      const dataKey = axisConfig.dataKey;
      if (dataKey === void 0 || axisConfig.data !== void 0) {
        return axisConfig;
      }
      if (dataset === void 0) {
        throw new Error("MUI X: z-axis uses `dataKey` but no `dataset` is provided.");
      }
      return _extends({}, axisConfig, {
        data: dataset.map((d) => d[dataKey])
      });
    }), [inZAxis, dataset]);
    const value = React102.useMemo(() => {
      var _a;
      const allZAxis = (_a = zAxis == null ? void 0 : zAxis.map((axis, index) => _extends({
        id: `defaultized-z-axis-${index}`
      }, axis))) != null ? _a : [];
      const completedZAxis = {};
      allZAxis.forEach((axis) => {
        completedZAxis[axis.id] = _extends({}, axis, {
          colorScale: axis.colorMap && (axis.colorMap.type === "ordinal" && axis.data ? getOrdinalColorScale(_extends({
            values: axis.data
          }, axis.colorMap)) : getColorScale(axis.colorMap.type === "continuous" ? _extends({
            min: axis.min,
            max: axis.max
          }, axis.colorMap) : axis.colorMap))
        });
      });
      return {
        zAxis: completedZAxis,
        zAxisIds: allZAxis.map(({
          id
        }) => id)
      };
    }, [zAxis]);
    return /* @__PURE__ */ (0, import_jsx_runtime59.jsx)(ZAxisContext.Provider, {
      value,
      children
    });
  }
  false ? ZAxisContextProvider.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    children: import_prop_types.default.node,
    /**
     * An array of objects that can be used to populate series and axes data using their `dataKey` property.
     */
    dataset: import_prop_types.default.arrayOf(import_prop_types.default.object),
    /**
     * The configuration of the z-axes.
     */
    zAxis: import_prop_types.default.arrayOf(import_prop_types.default.shape({
      colorMap: import_prop_types.default.oneOfType([import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        type: import_prop_types.default.oneOf(["ordinal"]).isRequired,
        unknownColor: import_prop_types.default.string,
        values: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number, import_prop_types.default.string]).isRequired)
      }), import_prop_types.default.shape({
        color: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string.isRequired), import_prop_types.default.func]).isRequired,
        max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        type: import_prop_types.default.oneOf(["continuous"]).isRequired
      }), import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        thresholds: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]).isRequired).isRequired,
        type: import_prop_types.default.oneOf(["piecewise"]).isRequired
      })]),
      data: import_prop_types.default.array,
      dataKey: import_prop_types.default.string,
      id: import_prop_types.default.string,
      max: import_prop_types.default.number,
      min: import_prop_types.default.number
    }))
  } : void 0;

  // node_modules/@mui/x-charts/hooks/useInteractionItemProps.js
  var useInteractionItemProps = (skip) => {
    const {
      dispatch: dispatchInteraction
    } = React103.useContext(InteractionContext);
    const {
      setHighlighted,
      clearHighlighted
    } = useHighlighted();
    if (skip) {
      return () => ({});
    }
    const getInteractionItemProps = (data) => {
      const onPointerDown = (event) => {
        if (event.currentTarget.hasPointerCapture(event.pointerId)) {
          event.currentTarget.releasePointerCapture(event.pointerId);
        }
      };
      const onPointerEnter = () => {
        dispatchInteraction({
          type: "enterItem",
          data
        });
        setHighlighted({
          seriesId: data.seriesId,
          dataIndex: data.dataIndex
        });
      };
      const onPointerLeave = (event) => {
        if (event.currentTarget.hasPointerCapture(event.pointerId)) {
          event.currentTarget.releasePointerCapture(event.pointerId);
        }
        dispatchInteraction({
          type: "leaveItem",
          data
        });
        clearHighlighted();
      };
      return {
        onPointerEnter,
        onPointerLeave,
        onPointerDown
      };
    };
    return getInteractionItemProps;
  };

  // node_modules/@mui/x-charts/BarChart/BarElement.js
  var import_jsx_runtime60 = __toESM(require_jsx_runtime());
  var _excluded2 = ["id", "dataIndex", "classes", "color", "slots", "slotProps", "style", "onClick"];
  function getBarElementUtilityClass(slot) {
    return generateUtilityClass2("MuiBarElement", slot);
  }
  var barElementClasses = generateUtilityClasses2("MuiBarElement", ["root"]);
  var useUtilityClasses23 = (ownerState) => {
    const {
      classes,
      id
    } = ownerState;
    const slots = {
      root: ["root", `series-${id}`]
    };
    return composeClasses2(slots, getBarElementUtilityClass, classes);
  };
  var BarElementPath = styled_default2(animated.rect, {
    name: "MuiBarElement",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })(({
    ownerState
  }) => ({
    stroke: "none",
    fill: ownerState.isHighlighted ? color2(ownerState.color).brighter(0.5).formatHex() : ownerState.color,
    transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
    opacity: ownerState.isFaded && 0.3 || 1
  }));
  function BarElement(props) {
    var _a;
    const {
      id,
      dataIndex,
      classes: innerClasses,
      color: color3,
      slots,
      slotProps,
      style: style4,
      onClick
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded2);
    const getInteractionItemProps = useInteractionItemProps();
    const {
      isFaded,
      isHighlighted
    } = useItemHighlighted({
      seriesId: id,
      dataIndex
    });
    const ownerState = {
      id,
      dataIndex,
      classes: innerClasses,
      color: color3,
      isFaded,
      isHighlighted
    };
    const classes = useUtilityClasses23(ownerState);
    const Bar = (_a = slots == null ? void 0 : slots.bar) != null ? _a : BarElementPath;
    const barProps = useSlotProps_default2({
      elementType: Bar,
      externalSlotProps: slotProps == null ? void 0 : slotProps.bar,
      externalForwardedProps: other,
      additionalProps: _extends({}, getInteractionItemProps({
        type: "bar",
        seriesId: id,
        dataIndex
      }), {
        style: style4,
        onClick,
        cursor: onClick ? "pointer" : "unset"
      }),
      className: classes.root,
      ownerState
    });
    return /* @__PURE__ */ (0, import_jsx_runtime60.jsx)(Bar, _extends({}, barProps));
  }
  false ? BarElement.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    classes: import_prop_types.default.object,
    dataIndex: import_prop_types.default.number.isRequired,
    id: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]).isRequired,
    /**
     * The props used for each component slot.
     * @default {}
     */
    slotProps: import_prop_types.default.object,
    /**
     * Overridable component slots.
     * @default {}
     */
    slots: import_prop_types.default.object
  } : void 0;

  // node_modules/@mui/x-charts/hooks/useChartId.js
  var React105 = __toESM(require_react());
  function useChartId() {
    const {
      chartId
    } = React105.useContext(DrawingContext);
    return React105.useMemo(() => chartId, [chartId]);
  }

  // node_modules/@mui/x-charts/hooks/useScale.js
  function getValueToPositionMapper(scale) {
    if (isBandScale(scale)) {
      return (value) => {
        var _a;
        return ((_a = scale(value)) != null ? _a : 0) + scale.bandwidth() / 2;
      };
    }
    return (value) => scale(value);
  }

  // node_modules/@mui/x-charts/hooks/useSvgRef.js
  var React106 = __toESM(require_react());
  function useSvgRef() {
    const {
      isInitialized,
      data
    } = React106.useContext(SvgContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the svg ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    return data;
  }

  // node_modules/@mui/x-charts/BarChart/BarClipPath.js
  var React107 = __toESM(require_react());

  // node_modules/@mui/x-charts/BarChart/getRadius.js
  var getRadius = (corner, {
    hasNegative,
    hasPositive,
    borderRadius: borderRadius2,
    layout
  }) => {
    if (!borderRadius2) {
      return 0;
    }
    const isVertical = layout === "vertical";
    if (corner === "top-left" && (isVertical && hasPositive || !isVertical && hasNegative)) {
      return borderRadius2;
    }
    if (corner === "top-right" && (isVertical && hasPositive || !isVertical && hasPositive)) {
      return borderRadius2;
    }
    if (corner === "bottom-right" && (isVertical && hasNegative || !isVertical && hasPositive)) {
      return borderRadius2;
    }
    if (corner === "bottom-left" && (isVertical && hasNegative || !isVertical && hasNegative)) {
      return borderRadius2;
    }
    return 0;
  };

  // node_modules/@mui/x-charts/BarChart/BarClipPath.js
  var import_jsx_runtime61 = __toESM(require_jsx_runtime());
  var _excluded3 = ["style", "maskId"];
  var buildInset = (corners) => `inset(0px round ${corners.topLeft}px ${corners.topRight}px ${corners.bottomRight}px ${corners.bottomLeft}px)`;
  function BarClipRect(props) {
    var _a, _b;
    const radiusData = props.ownerState;
    return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(animated.rect, {
      style: _extends({}, props.style, {
        clipPath: (props.ownerState.layout === "vertical" ? (_a = props.style) == null ? void 0 : _a.height : (_b = props.style) == null ? void 0 : _b.width).to((value) => buildInset({
          topLeft: Math.min(value, getRadius("top-left", radiusData)),
          topRight: Math.min(value, getRadius("top-right", radiusData)),
          bottomRight: Math.min(value, getRadius("bottom-right", radiusData)),
          bottomLeft: Math.min(value, getRadius("bottom-left", radiusData))
        }))
      })
    });
  }
  function BarClipPath(props) {
    const {
      style: style4,
      maskId
    } = props, rest = _objectWithoutPropertiesLoose(props, _excluded3);
    if (!props.borderRadius || props.borderRadius <= 0) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime61.jsx)("clipPath", {
      id: maskId,
      children: /* @__PURE__ */ (0, import_jsx_runtime61.jsx)(BarClipRect, {
        ownerState: rest,
        style: style4
      })
    });
  }

  // node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelPlot.js
  var React110 = __toESM(require_react());

  // node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelItem.js
  var React109 = __toESM(require_react());

  // node_modules/@mui/x-charts/BarChart/BarLabel/barLabelClasses.js
  function getBarLabelUtilityClass(slot) {
    return generateUtilityClass2("MuiBarLabel", slot);
  }
  var barLabelClasses = generateUtilityClasses2("MuiBarLabel", ["root", "highlighted", "faded"]);
  var useUtilityClasses24 = (ownerState) => {
    const {
      classes,
      seriesId,
      isFaded,
      isHighlighted
    } = ownerState;
    const slots = {
      root: ["root", `series-${seriesId}`, isHighlighted && "highlighted", isFaded && "faded"]
    };
    return composeClasses2(slots, getBarLabelUtilityClass, classes);
  };

  // node_modules/@mui/x-charts/BarChart/BarLabel/getBarLabel.js
  var getBarLabel = (options) => {
    const {
      barLabel,
      value,
      dataIndex,
      seriesId,
      height: height2,
      width: width2
    } = options;
    if (barLabel === "value") {
      return value ? value == null ? void 0 : value.toString() : null;
    }
    return barLabel({
      seriesId,
      dataIndex,
      value
    }, {
      bar: {
        height: height2,
        width: width2
      }
    });
  };

  // node_modules/@mui/x-charts/BarChart/BarLabel/BarLabel.js
  var React108 = __toESM(require_react());
  var import_jsx_runtime62 = __toESM(require_jsx_runtime());
  var _excluded4 = ["seriesId", "dataIndex", "color", "isFaded", "isHighlighted", "classes"];
  var BarLabelComponent = styled_default2(animated.text, {
    name: "MuiBarLabel",
    slot: "Root",
    overridesResolver: (_2, styles2) => [{
      [`&.${barLabelClasses.faded}`]: styles2.faded
    }, {
      [`&.${barLabelClasses.highlighted}`]: styles2.highlighted
    }, styles2.root]
  })(({
    theme
  }) => {
    var _a, _b, _c, _d;
    return _extends({}, (_a = theme == null ? void 0 : theme.typography) == null ? void 0 : _a.body2, {
      stroke: "none",
      fill: (_d = (_c = (_b = theme.vars || theme) == null ? void 0 : _b.palette) == null ? void 0 : _c.text) == null ? void 0 : _d.primary,
      transition: "opacity 0.2s ease-in, fill 0.2s ease-in",
      textAnchor: "middle",
      dominantBaseline: "central",
      pointerEvents: "none",
      opacity: 1,
      [`&.${barLabelClasses.faded}`]: {
        opacity: 0.3
      }
    });
  });
  function BarLabel(inProps) {
    const props = useThemeProps2({
      props: inProps,
      name: "MuiBarLabel"
    });
    const otherProps = _objectWithoutPropertiesLoose(props, _excluded4);
    return /* @__PURE__ */ (0, import_jsx_runtime62.jsx)(BarLabelComponent, _extends({}, otherProps));
  }
  false ? BarLabel.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    classes: import_prop_types.default.object,
    dataIndex: import_prop_types.default.number.isRequired,
    isFaded: import_prop_types.default.bool.isRequired,
    isHighlighted: import_prop_types.default.bool.isRequired,
    seriesId: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]).isRequired
  } : void 0;

  // node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelItem.js
  var import_jsx_runtime63 = __toESM(require_jsx_runtime());
  var _excluded5 = ["seriesId", "classes", "color", "style", "dataIndex", "barLabel", "slots", "slotProps", "height", "width", "value"];
  var _excluded22 = ["ownerState"];
  function BarLabelItem(props) {
    var _a;
    const {
      seriesId,
      classes: innerClasses,
      color: color3,
      style: style4,
      dataIndex,
      barLabel,
      slots,
      slotProps,
      height: height2,
      width: width2,
      value
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded5);
    const {
      isFaded,
      isHighlighted
    } = useItemHighlighted({
      seriesId,
      dataIndex
    });
    const ownerState = {
      seriesId,
      classes: innerClasses,
      color: color3,
      isFaded,
      isHighlighted,
      dataIndex
    };
    const classes = useUtilityClasses24(ownerState);
    const Component = (_a = slots == null ? void 0 : slots.barLabel) != null ? _a : BarLabel;
    const _useSlotProps = useSlotProps_default2({
      elementType: Component,
      externalSlotProps: slotProps == null ? void 0 : slotProps.barLabel,
      additionalProps: _extends({}, other, {
        style: style4,
        className: classes.root
      }),
      ownerState
    }), {
      ownerState: barLabelOwnerState
    } = _useSlotProps, barLabelProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded22);
    if (!barLabel) {
      return null;
    }
    const formattedLabelText = getBarLabel({
      barLabel,
      value,
      dataIndex,
      seriesId,
      height: height2,
      width: width2
    });
    if (!formattedLabelText) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime63.jsx)(Component, _extends({}, barLabelProps, barLabelOwnerState, {
      children: formattedLabelText
    }));
  }
  false ? BarLabelItem.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If provided, the function will be used to format the label of the bar.
     * It can be set to 'value' to display the current value.
     * @param {BarItem} item The item to format.
     * @param {BarLabelContext} context data about the bar.
     * @returns {string} The formatted label.
     */
    barLabel: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["value"]), import_prop_types.default.func]),
    classes: import_prop_types.default.object,
    color: import_prop_types.default.string.isRequired,
    dataIndex: import_prop_types.default.number.isRequired,
    /**
     * The height of the bar.
     */
    height: import_prop_types.default.number.isRequired,
    seriesId: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]).isRequired,
    /**
     * The props used for each component slot.
     * @default {}
     */
    slotProps: import_prop_types.default.object,
    /**
     * Overridable component slots.
     * @default {}
     */
    slots: import_prop_types.default.object,
    /**
     * The value of the data point.
     */
    value: import_prop_types.default.number,
    /**
     * The width of the bar.
     */
    width: import_prop_types.default.number.isRequired
  } : void 0;

  // node_modules/@mui/x-charts/BarChart/BarLabel/BarLabelPlot.js
  var import_jsx_runtime64 = __toESM(require_jsx_runtime());
  var _excluded6 = ["bars", "skipAnimation"];
  var leaveStyle = ({
    layout,
    yOrigin,
    x,
    width: width2,
    y,
    xOrigin,
    height: height2
  }) => _extends({}, layout === "vertical" ? {
    y: yOrigin,
    x: x + width2 / 2,
    height: 0,
    width: width2
  } : {
    y: y + height2 / 2,
    x: xOrigin,
    height: height2,
    width: 0
  });
  var enterStyle = ({
    x,
    width: width2,
    y,
    height: height2
  }) => ({
    x: x + width2 / 2,
    y: y + height2 / 2,
    height: height2,
    width: width2
  });
  function BarLabelPlot(props) {
    const {
      bars,
      skipAnimation: skipAnimation2
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded6);
    const barLabelTransition = useTransition(bars, {
      keys: (bar) => `${bar.seriesId}-${bar.dataIndex}`,
      from: leaveStyle,
      leave: null,
      enter: enterStyle,
      update: enterStyle,
      immediate: skipAnimation2
    });
    return /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(React110.Fragment, {
      children: barLabelTransition((style4, {
        seriesId,
        dataIndex,
        color: color3,
        value,
        width: width2,
        height: height2
      }) => /* @__PURE__ */ (0, import_jsx_runtime64.jsx)(BarLabelItem, _extends({
        seriesId,
        dataIndex,
        value,
        color: color3,
        width: width2,
        height: height2
      }, other, {
        style: style4
      })))
    });
  }

  // node_modules/@mui/x-charts/BarChart/checkScaleErrors.js
  var getAxisMessage = (axisDirection, axisId) => {
    const axisName = `${axisDirection}-axis`;
    const axisIdName = `${axisDirection}Axis`;
    const axisDefaultKey = axisDirection === "x" ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;
    return axisId === axisDefaultKey ? `The first \`${axisIdName}\`` : `The ${axisName} with id "${axisId}"`;
  };
  function checkScaleErrors(verticalLayout, seriesId, xAxisId, xAxis, yAxisId, yAxis) {
    const xAxisConfig = xAxis[xAxisId];
    const yAxisConfig = yAxis[yAxisId];
    const discreteAxisConfig = verticalLayout ? xAxisConfig : yAxisConfig;
    const continuousAxisConfig = verticalLayout ? yAxisConfig : xAxisConfig;
    const discreteAxisId = verticalLayout ? xAxisId : yAxisId;
    const continuousAxisId = verticalLayout ? yAxisId : xAxisId;
    const discreteAxisDirection = verticalLayout ? "x" : "y";
    const continuousAxisDirection = verticalLayout ? "y" : "x";
    if (!isBandScaleConfig(discreteAxisConfig)) {
      throw new Error(`MUI X: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should be of type "band" to display the bar series of id "${seriesId}".`);
    }
    if (discreteAxisConfig.data === void 0) {
      throw new Error(`MUI X: ${getAxisMessage(discreteAxisDirection, discreteAxisId)} should have data property.`);
    }
    if (isBandScaleConfig(continuousAxisConfig) || isPointScaleConfig(continuousAxisConfig)) {
      throw new Error(`MUI X: ${getAxisMessage(continuousAxisDirection, continuousAxisId)} should be a continuous type to display the bar series of id "${seriesId}".`);
    }
  }

  // node_modules/@mui/x-charts/context/AnimationProvider/AnimationContext.js
  var React111 = __toESM(require_react());
  var AnimationContext = /* @__PURE__ */ React111.createContext({
    isInitialized: false,
    data: {
      skipAnimation: void 0
    }
  });
  if (false) {
    AnimationContext.displayName = "AnimationContext";
  }

  // node_modules/@mui/x-charts/context/AnimationProvider/AnimationProvider.js
  var React112 = __toESM(require_react());
  var import_jsx_runtime65 = __toESM(require_jsx_runtime());
  function AnimationProvider(props) {
    const {
      children,
      skipAnimation: inSkipAnimation
    } = props;
    const isAnimationDisabledEnvironment = typeof window === "undefined" || !(window == null ? void 0 : window.matchMedia);
    const [skipAnimation2, setSkipAnimation] = React112.useState(isAnimationDisabledEnvironment || void 0);
    useIsomorphicLayoutEffect(() => {
      var _a;
      if (isAnimationDisabledEnvironment) {
        return void 0;
      }
      const handleMediaChange = (event) => {
        const inputValue = event.matches || void 0;
        setSkipAnimation(inputValue);
        globals_exports.assign({
          skipAnimation: inputValue
        });
      };
      const mql = window.matchMedia("(prefers-reduced-motion)");
      handleMediaChange(mql);
      (_a = mql == null ? void 0 : mql.addEventListener) == null ? void 0 : _a.call(mql, "change", handleMediaChange);
      return () => {
        var _a2;
        (_a2 = mql == null ? void 0 : mql.removeEventListener) == null ? void 0 : _a2.call(mql, "change", handleMediaChange);
      };
    }, []);
    const value = React112.useMemo(() => ({
      isInitialized: true,
      data: {
        // If dev sets `skipAnimation` to true, it will skip all animations.
        // If dev sets `skipAnimation` to false, it will use user's preference.
        skipAnimation: inSkipAnimation || skipAnimation2
      }
    }), [skipAnimation2, inSkipAnimation]);
    return /* @__PURE__ */ (0, import_jsx_runtime65.jsx)(AnimationContext.Provider, {
      value,
      children
    });
  }

  // node_modules/@mui/x-charts/context/AnimationProvider/useSkipAnimation.js
  var React113 = __toESM(require_react());
  function useSkipAnimation(skipAnimation2) {
    const {
      isInitialized,
      data
    } = React113.useContext(AnimationContext);
    if (!isInitialized) {
      throw new Error(["MUI X: Could not find the animation ref context.", "It looks like you rendered your component outside of a ChartsContainer parent component."].join("\n"));
    }
    return skipAnimation2 || data.skipAnimation;
  }

  // node_modules/@mui/x-charts/BarChart/BarPlot.js
  var import_jsx_runtime66 = __toESM(require_jsx_runtime());
  var _excluded7 = ["skipAnimation", "onItemClick", "borderRadius", "barLabel"];
  function getBandSize({
    bandWidth: W,
    numberOfGroups: N,
    gapRatio: r2
  }) {
    if (r2 === 0) {
      return {
        barWidth: W / N,
        offset: 0
      };
    }
    const barWidth = W / (N + (N - 1) * r2);
    const offset2 = r2 * barWidth;
    return {
      barWidth,
      offset: offset2
    };
  }
  var useAggregatedData = () => {
    var _a;
    const seriesData = (_a = useBarSeries()) != null ? _a : {
      series: {},
      stackingGroups: [],
      seriesOrder: []
    };
    const axisData = useCartesianContext();
    const chartId = useChartId();
    const {
      series,
      stackingGroups
    } = seriesData;
    const {
      xAxis,
      yAxis,
      xAxisIds,
      yAxisIds
    } = axisData;
    const defaultXAxisId = xAxisIds[0];
    const defaultYAxisId = yAxisIds[0];
    const masks = {};
    const data = stackingGroups.flatMap(({
      ids: groupIds
    }, groupIndex) => {
      return groupIds.flatMap((seriesId) => {
        var _a2, _b, _c, _d;
        const xAxisId = (_b = (_a2 = series[seriesId].xAxisId) != null ? _a2 : series[seriesId].xAxisKey) != null ? _b : defaultXAxisId;
        const yAxisId = (_d = (_c = series[seriesId].yAxisId) != null ? _c : series[seriesId].yAxisKey) != null ? _d : defaultYAxisId;
        const xAxisConfig = xAxis[xAxisId];
        const yAxisConfig = yAxis[yAxisId];
        const verticalLayout = series[seriesId].layout === "vertical";
        checkScaleErrors(verticalLayout, seriesId, xAxisId, xAxis, yAxisId, yAxis);
        const baseScaleConfig = verticalLayout ? xAxisConfig : yAxisConfig;
        const xScale = xAxisConfig.scale;
        const yScale = yAxisConfig.scale;
        const colorGetter = getColor_default(series[seriesId], xAxis[xAxisId], yAxis[yAxisId]);
        const bandWidth = baseScaleConfig.scale.bandwidth();
        const {
          barWidth,
          offset: offset2
        } = getBandSize({
          bandWidth,
          numberOfGroups: stackingGroups.length,
          gapRatio: baseScaleConfig.barGapRatio
        });
        const barOffset = groupIndex * (barWidth + offset2);
        const {
          stackedData
        } = series[seriesId];
        return stackedData.map((values3, dataIndex) => {
          var _a3, _b2, _c2, _d2;
          const valueCoordinates = values3.map((v) => verticalLayout ? yScale(v) : xScale(v));
          const minValueCoord = Math.round(Math.min(...valueCoordinates));
          const maxValueCoord = Math.round(Math.max(...valueCoordinates));
          const stackId = series[seriesId].stack;
          const result = {
            seriesId,
            dataIndex,
            layout: series[seriesId].layout,
            x: verticalLayout ? xScale((_a3 = xAxis[xAxisId].data) == null ? void 0 : _a3[dataIndex]) + barOffset : minValueCoord,
            y: verticalLayout ? minValueCoord : yScale((_b2 = yAxis[yAxisId].data) == null ? void 0 : _b2[dataIndex]) + barOffset,
            xOrigin: xScale(0),
            yOrigin: yScale(0),
            height: verticalLayout ? maxValueCoord - minValueCoord : barWidth,
            width: verticalLayout ? barWidth : maxValueCoord - minValueCoord,
            color: colorGetter(dataIndex),
            value: series[seriesId].data[dataIndex],
            maskId: `${chartId}_${stackId || seriesId}_${groupIndex}_${dataIndex}`
          };
          if (!masks[result.maskId]) {
            masks[result.maskId] = {
              id: result.maskId,
              width: 0,
              height: 0,
              hasNegative: false,
              hasPositive: false,
              layout: result.layout,
              xOrigin: xScale(0),
              yOrigin: yScale(0),
              x: 0,
              y: 0
            };
          }
          const mask = masks[result.maskId];
          mask.width = result.layout === "vertical" ? result.width : mask.width + result.width;
          mask.height = result.layout === "vertical" ? mask.height + result.height : result.height;
          mask.x = Math.min(mask.x === 0 ? Infinity : mask.x, result.x);
          mask.y = Math.min(mask.y === 0 ? Infinity : mask.y, result.y);
          mask.hasNegative = mask.hasNegative || ((_c2 = result.value) != null ? _c2 : 0) < 0;
          mask.hasPositive = mask.hasPositive || ((_d2 = result.value) != null ? _d2 : 0) > 0;
          return result;
        });
      });
    });
    return {
      completedData: data,
      masksData: Object.values(masks)
    };
  };
  var leaveStyle2 = ({
    layout,
    yOrigin,
    x,
    width: width2,
    y,
    xOrigin,
    height: height2
  }) => _extends({}, layout === "vertical" ? {
    y: yOrigin,
    x,
    height: 0,
    width: width2
  } : {
    y,
    x: xOrigin,
    height: height2,
    width: 0
  });
  var enterStyle2 = ({
    x,
    width: width2,
    y,
    height: height2
  }) => ({
    y,
    x,
    height: height2,
    width: width2
  });
  function BarPlot(props) {
    const {
      completedData,
      masksData
    } = useAggregatedData();
    const {
      skipAnimation: inSkipAnimation,
      onItemClick,
      borderRadius: borderRadius2,
      barLabel
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded7);
    const skipAnimation2 = useSkipAnimation(inSkipAnimation);
    const withoutBorderRadius = !borderRadius2 || borderRadius2 <= 0;
    const transition = useTransition(completedData, {
      keys: (bar) => `${bar.seriesId}-${bar.dataIndex}`,
      from: leaveStyle2,
      leave: leaveStyle2,
      enter: enterStyle2,
      update: enterStyle2,
      immediate: skipAnimation2
    });
    const maskTransition = useTransition(withoutBorderRadius ? [] : masksData, {
      keys: (v) => v.id,
      from: leaveStyle2,
      leave: leaveStyle2,
      enter: enterStyle2,
      update: enterStyle2,
      immediate: skipAnimation2
    });
    return /* @__PURE__ */ (0, import_jsx_runtime66.jsxs)(React114.Fragment, {
      children: [!withoutBorderRadius && maskTransition((style4, {
        id,
        hasPositive,
        hasNegative,
        layout
      }) => {
        return /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(BarClipPath, {
          maskId: id,
          borderRadius: borderRadius2,
          hasNegative,
          hasPositive,
          layout,
          style: style4
        });
      }), transition((style4, {
        seriesId,
        dataIndex,
        color: color3,
        maskId
      }) => {
        const barElement = /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(BarElement, _extends({
          id: seriesId,
          dataIndex,
          color: color3
        }, other, {
          onClick: onItemClick && ((event) => {
            onItemClick(event, {
              type: "bar",
              seriesId,
              dataIndex
            });
          }),
          style: style4
        }));
        if (withoutBorderRadius) {
          return barElement;
        }
        return /* @__PURE__ */ (0, import_jsx_runtime66.jsx)("g", {
          clipPath: `url(#${maskId})`,
          children: barElement
        });
      }), barLabel && /* @__PURE__ */ (0, import_jsx_runtime66.jsx)(BarLabelPlot, _extends({
        bars: completedData,
        skipAnimation: skipAnimation2,
        barLabel
      }, other))]
    });
  }
  false ? BarPlot.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * If provided, the function will be used to format the label of the bar.
     * It can be set to 'value' to display the current value.
     * @param {BarItem} item The item to format.
     * @param {BarLabelContext} context data about the bar.
     * @returns {string} The formatted label.
     */
    barLabel: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["value"]), import_prop_types.default.func]),
    /**
     * Defines the border radius of the bar element.
     */
    borderRadius: import_prop_types.default.number,
    /**
     * Callback fired when a bar item is clicked.
     * @param {React.MouseEvent<SVGElement, MouseEvent>} event The event source of the callback.
     * @param {BarItemIdentifier} barItemIdentifier The bar item identifier.
     */
    onItemClick: import_prop_types.default.func,
    /**
     * If `true`, animations are skipped.
     * @default undefined
     */
    skipAnimation: import_prop_types.default.bool,
    /**
     * The props used for each component slot.
     * @default {}
     */
    slotProps: import_prop_types.default.object,
    /**
     * Overridable component slots.
     * @default {}
     */
    slots: import_prop_types.default.object
  } : void 0;

  // node_modules/@mui/x-charts/ResponsiveChartContainer/ResponsiveChartContainer.js
  var React125 = __toESM(require_react());

  // node_modules/@mui/x-charts/ChartContainer/ChartContainer.js
  var React122 = __toESM(require_react());

  // node_modules/@mui/x-charts/ChartsSurface/ChartsSurface.js
  var React116 = __toESM(require_react());

  // node_modules/@mui/x-charts/hooks/useAxisEvents.js
  var React115 = __toESM(require_react());

  // node_modules/@mui/x-charts/internals/getSVGPoint.js
  function getSVGPoint(svg, event) {
    const pt = svg.createSVGPoint();
    pt.x = event.clientX;
    pt.y = event.clientY;
    return pt.matrixTransform(svg.getScreenCTM().inverse());
  }

  // node_modules/@mui/x-charts/hooks/useAxisEvents.js
  function getAsANumber(value) {
    return value instanceof Date ? value.getTime() : value;
  }
  var useAxisEvents = (disableAxisListener) => {
    const svgRef = useSvgRef();
    const drawingArea = useDrawingArea();
    const {
      xAxis,
      yAxis,
      xAxisIds,
      yAxisIds
    } = useCartesianContext();
    const {
      dispatch
    } = React115.useContext(InteractionContext);
    const usedXAxis = xAxisIds[0];
    const usedYAxis = yAxisIds[0];
    const mousePosition = React115.useRef({
      isInChart: false,
      x: -1,
      y: -1
    });
    React115.useEffect(() => {
      const element = svgRef.current;
      if (element === null || disableAxisListener) {
        return () => {
        };
      }
      function getNewAxisState(axisConfig, mouseValue) {
        const {
          scale,
          data: axisData,
          reverse
        } = axisConfig;
        if (!isBandScale(scale)) {
          const value = scale.invert(mouseValue);
          if (axisData === void 0) {
            return {
              value,
              index: -1
            };
          }
          const valueAsNumber = getAsANumber(value);
          const closestIndex = axisData == null ? void 0 : axisData.findIndex((pointValue, index) => {
            const v = getAsANumber(pointValue);
            if (v > valueAsNumber) {
              if (index === 0 || Math.abs(valueAsNumber - v) <= Math.abs(valueAsNumber - getAsANumber(axisData[index - 1]))) {
                return true;
              }
            }
            if (v <= valueAsNumber) {
              if (index === axisData.length - 1 || Math.abs(getAsANumber(value) - v) < Math.abs(getAsANumber(value) - getAsANumber(axisData[index + 1]))) {
                return true;
              }
            }
            return false;
          });
          return {
            value: closestIndex !== void 0 && closestIndex >= 0 ? axisData[closestIndex] : value,
            index: closestIndex
          };
        }
        const dataIndex = scale.bandwidth() === 0 ? Math.floor((mouseValue - Math.min(...scale.range()) + scale.step() / 2) / scale.step()) : Math.floor((mouseValue - Math.min(...scale.range())) / scale.step());
        if (dataIndex < 0 || dataIndex >= axisData.length) {
          return null;
        }
        if (reverse) {
          const reverseIndex = axisData.length - 1 - dataIndex;
          return {
            index: reverseIndex,
            value: axisData[reverseIndex]
          };
        }
        return {
          index: dataIndex,
          value: axisData[dataIndex]
        };
      }
      const handleOut = () => {
        mousePosition.current = {
          isInChart: false,
          x: -1,
          y: -1
        };
        dispatch({
          type: "exitChart"
        });
      };
      const handleMove = (event) => {
        const target = "targetTouches" in event ? event.targetTouches[0] : event;
        const svgPoint = getSVGPoint(element, target);
        mousePosition.current.x = svgPoint.x;
        mousePosition.current.y = svgPoint.y;
        if (!drawingArea.isPointInside(svgPoint, {
          targetElement: event.target
        })) {
          if (mousePosition.current.isInChart) {
            dispatch({
              type: "exitChart"
            });
            mousePosition.current.isInChart = false;
          }
          return;
        }
        mousePosition.current.isInChart = true;
        const newStateX = getNewAxisState(xAxis[usedXAxis], svgPoint.x);
        const newStateY = getNewAxisState(yAxis[usedYAxis], svgPoint.y);
        dispatch({
          type: "updateAxis",
          data: {
            x: newStateX,
            y: newStateY
          }
        });
      };
      const handleDown = (event) => {
        const target = event.currentTarget;
        if (!target) {
          return;
        }
        if (target.hasPointerCapture(event.pointerId)) {
          target.releasePointerCapture(event.pointerId);
        }
      };
      element.addEventListener("pointerdown", handleDown);
      element.addEventListener("pointermove", handleMove);
      element.addEventListener("pointerout", handleOut);
      element.addEventListener("pointercancel", handleOut);
      element.addEventListener("pointerleave", handleOut);
      return () => {
        element.removeEventListener("pointerdown", handleDown);
        element.removeEventListener("pointermove", handleMove);
        element.removeEventListener("pointerout", handleOut);
        element.removeEventListener("pointercancel", handleOut);
        element.removeEventListener("pointerleave", handleOut);
      };
    }, [svgRef, dispatch, usedYAxis, yAxis, usedXAxis, xAxis, disableAxisListener, drawingArea]);
  };

  // node_modules/@mui/x-charts/ChartsSurface/ChartsSurface.js
  var import_jsx_runtime67 = __toESM(require_jsx_runtime());
  var _excluded8 = ["children", "width", "height", "viewBox", "disableAxisListener", "className", "title", "desc"];
  var ChartChartsSurfaceStyles = styled_default2("svg", {
    name: "MuiChartsSurface",
    slot: "Root"
  })(() => ({
    // This prevents default touch actions when using the svg on mobile devices.
    // For example, prevent page scroll & zoom.
    touchAction: "none"
  }));
  var ChartsSurface = /* @__PURE__ */ React116.forwardRef(function ChartsSurface2(inProps, ref) {
    const props = useThemeProps2({
      props: inProps,
      name: "MuiChartsSurface"
    });
    const {
      children,
      width: width2,
      height: height2,
      viewBox,
      disableAxisListener = false,
      className,
      title,
      desc
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded8);
    const svgView = _extends({
      width: width2,
      height: height2,
      x: 0,
      y: 0
    }, viewBox);
    useAxisEvents(disableAxisListener);
    return /* @__PURE__ */ (0, import_jsx_runtime67.jsxs)(ChartChartsSurfaceStyles, _extends({
      width: width2,
      height: height2,
      viewBox: `${svgView.x} ${svgView.y} ${svgView.width} ${svgView.height}`,
      ref,
      className
    }, other, {
      children: [/* @__PURE__ */ (0, import_jsx_runtime67.jsx)("title", {
        children: title
      }), /* @__PURE__ */ (0, import_jsx_runtime67.jsx)("desc", {
        children: desc
      }), children]
    }));
  });
  false ? ChartsSurface.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    children: import_prop_types.default.node,
    className: import_prop_types.default.string,
    desc: import_prop_types.default.string,
    /**
     * If `true`, the charts will not listen to the mouse move event.
     * It might break interactive features, but will improve performance.
     * @default false
     */
    disableAxisListener: import_prop_types.default.bool,
    /**
     * The height of the chart in px.
     */
    height: import_prop_types.default.number.isRequired,
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    title: import_prop_types.default.string,
    viewBox: import_prop_types.default.shape({
      height: import_prop_types.default.number,
      width: import_prop_types.default.number,
      x: import_prop_types.default.number,
      y: import_prop_types.default.number
    }),
    /**
     * The width of the chart in px.
     */
    width: import_prop_types.default.number.isRequired
  } : void 0;

  // node_modules/@mui/x-charts/internals/components/ChartsAxesGradients/ChartsAxesGradients.js
  var React119 = __toESM(require_react());

  // node_modules/@mui/x-charts/internals/components/ChartsAxesGradients/ChartsPiecewiseGradient.js
  var React117 = __toESM(require_react());
  var import_jsx_runtime68 = __toESM(require_jsx_runtime());
  function ChartsPiecewiseGradient(props) {
    const {
      isReversed,
      gradientId,
      size,
      direction,
      scale,
      colorMap
    } = props;
    if (size <= 0) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime68.jsx)("linearGradient", {
      id: gradientId,
      x1: "0",
      x2: "0",
      y1: "0",
      y2: "0",
      [`${direction}${isReversed ? 1 : 2}`]: `${size}px`,
      gradientUnits: "userSpaceOnUse",
      children: colorMap.thresholds.map((threshold2, index) => {
        const x = scale(threshold2);
        if (x === void 0) {
          return null;
        }
        const offset2 = isReversed ? 1 - x / size : x / size;
        return /* @__PURE__ */ (0, import_jsx_runtime68.jsxs)(React117.Fragment, {
          children: [/* @__PURE__ */ (0, import_jsx_runtime68.jsx)("stop", {
            offset: offset2,
            stopColor: colorMap.colors[index],
            stopOpacity: 1
          }), /* @__PURE__ */ (0, import_jsx_runtime68.jsx)("stop", {
            offset: offset2,
            stopColor: colorMap.colors[index + 1],
            stopOpacity: 1
          })]
        }, threshold2.toString() + index);
      })
    });
  }

  // node_modules/@mui/x-charts/internals/components/ChartsAxesGradients/ChartsContinuousGradient.js
  var React118 = __toESM(require_react());
  var import_jsx_runtime69 = __toESM(require_jsx_runtime());
  var PX_PRECISION = 10;
  function ChartsContinuousGradient(props) {
    var _a, _b;
    const {
      gradientUnits,
      isReversed,
      gradientId,
      size,
      direction,
      scale,
      colorScale,
      colorMap
    } = props;
    const extremValues = [(_a = colorMap.min) != null ? _a : 0, (_b = colorMap.max) != null ? _b : 100];
    const extremPositions = extremValues.map(scale).filter((p) => p !== void 0);
    if (extremPositions.length !== 2) {
      return null;
    }
    const interpolator = typeof extremValues[0] === "number" ? number_default(extremValues[0], extremValues[1]) : date_default(extremValues[0], extremValues[1]);
    const numberOfPoints = Math.round((Math.max(...extremPositions) - Math.min(...extremPositions)) / PX_PRECISION);
    const keyPrefix = `${extremValues[0]}-${extremValues[1]}-`;
    return /* @__PURE__ */ (0, import_jsx_runtime69.jsx)("linearGradient", {
      id: gradientId,
      x1: "0",
      x2: "0",
      y1: "0",
      y2: "0",
      [`${direction}${isReversed ? 1 : 2}`]: gradientUnits === "objectBoundingBox" ? 1 : `${size}px`,
      gradientUnits: gradientUnits != null ? gradientUnits : "userSpaceOnUse",
      children: Array.from({
        length: numberOfPoints + 1
      }, (_2, index) => {
        const value = interpolator(index / numberOfPoints);
        if (value === void 0) {
          return null;
        }
        const x = scale(value);
        if (x === void 0) {
          return null;
        }
        const offset2 = isReversed ? 1 - x / size : x / size;
        const color3 = colorScale(value);
        if (color3 === null) {
          return null;
        }
        return /* @__PURE__ */ (0, import_jsx_runtime69.jsx)("stop", {
          offset: offset2,
          stopColor: color3,
          stopOpacity: 1
        }, keyPrefix + index);
      })
    });
  }

  // node_modules/@mui/x-charts/internals/components/ChartsAxesGradients/ChartsAxesGradients.js
  var import_jsx_runtime70 = __toESM(require_jsx_runtime());
  function useChartGradient() {
    const {
      chartId
    } = React119.useContext(DrawingContext);
    return React119.useCallback((axisId, direction) => `${chartId}-gradient-${direction}-${axisId}`, [chartId]);
  }
  function ChartsAxesGradients() {
    const {
      top: top2,
      height: height2,
      bottom: bottom2,
      left: left2,
      width: width2,
      right: right2
    } = useDrawingArea();
    const svgHeight = top2 + height2 + bottom2;
    const svgWidth = left2 + width2 + right2;
    const getGradientId = useChartGradient();
    const {
      xAxisIds,
      xAxis,
      yAxisIds,
      yAxis
    } = useCartesianContext();
    return /* @__PURE__ */ (0, import_jsx_runtime70.jsxs)("defs", {
      children: [yAxisIds.filter((axisId) => yAxis[axisId].colorMap !== void 0).map((axisId) => {
        const gradientId = getGradientId(axisId, "y");
        const {
          colorMap,
          scale,
          colorScale,
          reverse
        } = yAxis[axisId];
        if ((colorMap == null ? void 0 : colorMap.type) === "piecewise") {
          return /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(ChartsPiecewiseGradient, {
            isReversed: !reverse,
            scale,
            colorMap,
            size: svgHeight,
            gradientId,
            direction: "y"
          }, gradientId);
        }
        if ((colorMap == null ? void 0 : colorMap.type) === "continuous") {
          return /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(ChartsContinuousGradient, {
            isReversed: !reverse,
            scale,
            colorScale,
            colorMap,
            size: svgHeight,
            gradientId,
            direction: "y"
          }, gradientId);
        }
        return null;
      }), xAxisIds.filter((axisId) => xAxis[axisId].colorMap !== void 0).map((axisId) => {
        const gradientId = getGradientId(axisId, "x");
        const {
          colorMap,
          scale,
          reverse,
          colorScale
        } = xAxis[axisId];
        if ((colorMap == null ? void 0 : colorMap.type) === "piecewise") {
          return /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(ChartsPiecewiseGradient, {
            isReversed: reverse,
            scale,
            colorMap,
            size: svgWidth,
            gradientId,
            direction: "x"
          }, gradientId);
        }
        if ((colorMap == null ? void 0 : colorMap.type) === "continuous") {
          return /* @__PURE__ */ (0, import_jsx_runtime70.jsx)(ChartsContinuousGradient, {
            isReversed: reverse,
            scale,
            colorScale,
            colorMap,
            size: svgWidth,
            gradientId,
            direction: "x"
          }, gradientId);
        }
        return null;
      })]
    });
  }

  // node_modules/@mui/x-charts/ChartContainer/useChartContainerProps.js
  var React121 = __toESM(require_react());

  // node_modules/@mui/x-charts/ChartContainer/useDefaultizeAxis.js
  var React120 = __toESM(require_react());
  var defaultizeAxis = (inAxis, dataset, axisName) => {
    var _a;
    const DEFAULT_AXIS_KEY = axisName === "x" ? DEFAULT_X_AXIS_KEY : DEFAULT_Y_AXIS_KEY;
    return [...(_a = inAxis == null ? void 0 : inAxis.map((axis, index) => _extends({
      id: `defaultized-${axisName}-axis-${index}`
    }, axis))) != null ? _a : [], ...inAxis === void 0 || inAxis.findIndex(({
      id
    }) => id === DEFAULT_AXIS_KEY) === -1 ? [{
      id: DEFAULT_AXIS_KEY,
      scaleType: "linear"
    }] : []].map((axisConfig) => {
      const dataKey = axisConfig.dataKey;
      if (dataKey === void 0 || axisConfig.data !== void 0) {
        return axisConfig;
      }
      if (dataset === void 0) {
        throw new Error(`MUI X: ${axisName}-axis uses \`dataKey\` but no \`dataset\` is provided.`);
      }
      return _extends({}, axisConfig, {
        data: dataset.map((d) => d[dataKey])
      });
    });
  };
  var useDefaultizeAxis = (inXAxis, inYAxis, dataset) => {
    const xAxis = React120.useMemo(() => defaultizeAxis(inXAxis, dataset, "x"), [inXAxis, dataset]);
    const yAxis = React120.useMemo(() => defaultizeAxis(inYAxis, dataset, "y"), [inYAxis, dataset]);
    return [xAxis, yAxis];
  };

  // node_modules/@mui/x-charts/ChartContainer/useChartContainerProps.js
  var _excluded9 = ["width", "height", "series", "margin", "xAxis", "yAxis", "zAxis", "colors", "dataset", "sx", "title", "desc", "disableAxisListener", "highlightedItem", "onHighlightChange", "plugins", "children", "skipAnimation"];
  var useChartContainerProps = (props, ref) => {
    const {
      width: width2,
      height: height2,
      series,
      margin: margin2,
      xAxis,
      yAxis,
      zAxis,
      colors: colors3,
      dataset,
      sx,
      title,
      desc,
      disableAxisListener,
      highlightedItem,
      onHighlightChange,
      plugins,
      children,
      skipAnimation: skipAnimation2
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded9);
    const svgRef = React121.useRef(null);
    const chartSurfaceRef = useForkRef2(ref, svgRef);
    const [defaultizedXAxis, defaultizedYAxis] = useDefaultizeAxis(xAxis, yAxis, dataset);
    const drawingProviderProps = {
      width: width2,
      height: height2,
      margin: margin2,
      svgRef
    };
    const animationProviderProps = {
      skipAnimation: skipAnimation2
    };
    const pluginProviderProps = {
      plugins
    };
    const seriesProviderProps = {
      series,
      colors: colors3,
      dataset
    };
    const cartesianProviderProps = {
      xAxis: defaultizedXAxis,
      yAxis: defaultizedYAxis,
      dataset
    };
    const zAxisContextProps = {
      zAxis,
      dataset
    };
    const highlightedProviderProps = {
      highlightedItem,
      onHighlightChange
    };
    const chartsSurfaceProps = _extends({}, other, {
      width: width2,
      height: height2,
      ref: chartSurfaceRef,
      sx,
      title,
      desc,
      disableAxisListener
    });
    return {
      children,
      drawingProviderProps,
      seriesProviderProps,
      cartesianProviderProps,
      zAxisContextProps,
      highlightedProviderProps,
      chartsSurfaceProps,
      pluginProviderProps,
      animationProviderProps,
      xAxis: defaultizedXAxis,
      yAxis: defaultizedYAxis
    };
  };

  // node_modules/@mui/x-charts/ChartContainer/ChartContainer.js
  var import_jsx_runtime71 = __toESM(require_jsx_runtime());
  var ChartContainer = /* @__PURE__ */ React122.forwardRef(function ChartContainer2(props, ref) {
    const {
      children,
      drawingProviderProps,
      seriesProviderProps,
      cartesianProviderProps,
      zAxisContextProps,
      highlightedProviderProps,
      chartsSurfaceProps,
      pluginProviderProps,
      animationProviderProps
    } = useChartContainerProps(props, ref);
    return /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(DrawingProvider, _extends({}, drawingProviderProps, {
      children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(PluginProvider, _extends({}, pluginProviderProps, {
        children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(SeriesProvider, _extends({}, seriesProviderProps, {
          children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(CartesianProvider, _extends({}, cartesianProviderProps, {
            children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(ZAxisContextProvider, _extends({}, zAxisContextProps, {
              children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(InteractionProvider, {
                children: /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(HighlightedProvider, _extends({}, highlightedProviderProps, {
                  children: /* @__PURE__ */ (0, import_jsx_runtime71.jsxs)(ChartsSurface, _extends({}, chartsSurfaceProps, {
                    children: [/* @__PURE__ */ (0, import_jsx_runtime71.jsx)(ChartsAxesGradients, {}), /* @__PURE__ */ (0, import_jsx_runtime71.jsx)(AnimationProvider, _extends({}, animationProviderProps, {
                      children
                    }))]
                  }))
                }))
              })
            }))
          }))
        }))
      }))
    }));
  });
  false ? ChartContainer.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    children: import_prop_types.default.node,
    className: import_prop_types.default.string,
    /**
     * Color palette used to colorize multiple series.
     * @default blueberryTwilightPalette
     */
    colors: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string), import_prop_types.default.func]),
    /**
     * An array of objects that can be used to populate series and axes data using their `dataKey` property.
     */
    dataset: import_prop_types.default.arrayOf(import_prop_types.default.object),
    desc: import_prop_types.default.string,
    /**
     * If `true`, the charts will not listen to the mouse move event.
     * It might break interactive features, but will improve performance.
     * @default false
     */
    disableAxisListener: import_prop_types.default.bool,
    /**
     * The height of the chart in px.
     */
    height: import_prop_types.default.number.isRequired,
    /**
     * The item currently highlighted. Turns highlighting into a controlled prop.
     */
    highlightedItem: import_prop_types.default.shape({
      dataIndex: import_prop_types.default.number,
      seriesId: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])
    }),
    /**
     * The margin between the SVG and the drawing area.
     * It's used for leaving some space for extra information such as the x- and y-axis or legend.
     * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
     * @default object Depends on the charts type.
     */
    margin: import_prop_types.default.shape({
      bottom: import_prop_types.default.number,
      left: import_prop_types.default.number,
      right: import_prop_types.default.number,
      top: import_prop_types.default.number
    }),
    /**
     * The callback fired when the highlighted item changes.
     *
     * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
     */
    onHighlightChange: import_prop_types.default.func,
    /**
     * An array of plugins defining how to preprocess data.
     * If not provided, the container supports line, bar, scatter and pie charts.
     */
    plugins: import_prop_types.default.arrayOf(import_prop_types.default.object),
    /**
     * The array of series to display.
     * Each type of series has its own specificity.
     * Please refer to the appropriate docs page to learn more about it.
     */
    series: import_prop_types.default.arrayOf(import_prop_types.default.object).isRequired,
    /**
     * If `true`, animations are skipped.
     * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
     */
    skipAnimation: import_prop_types.default.bool,
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    title: import_prop_types.default.string,
    viewBox: import_prop_types.default.shape({
      height: import_prop_types.default.number,
      width: import_prop_types.default.number,
      x: import_prop_types.default.number,
      y: import_prop_types.default.number
    }),
    /**
     * The width of the chart in px.
     */
    width: import_prop_types.default.number.isRequired,
    /**
     * The configuration of the x-axes.
     * If not provided, a default axis config is used.
     * An array of [[AxisConfig]] objects.
     */
    xAxis: import_prop_types.default.arrayOf(import_prop_types.default.shape({
      classes: import_prop_types.default.object,
      colorMap: import_prop_types.default.oneOfType([import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        type: import_prop_types.default.oneOf(["ordinal"]).isRequired,
        unknownColor: import_prop_types.default.string,
        values: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number, import_prop_types.default.string]).isRequired)
      }), import_prop_types.default.shape({
        color: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string.isRequired), import_prop_types.default.func]).isRequired,
        max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        type: import_prop_types.default.oneOf(["continuous"]).isRequired
      }), import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        thresholds: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]).isRequired).isRequired,
        type: import_prop_types.default.oneOf(["piecewise"]).isRequired
      })]),
      data: import_prop_types.default.array,
      dataKey: import_prop_types.default.string,
      disableLine: import_prop_types.default.bool,
      disableTicks: import_prop_types.default.bool,
      domainLimit: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["nice", "strict"]), import_prop_types.default.func]),
      fill: import_prop_types.default.string,
      hideTooltip: import_prop_types.default.bool,
      id: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]),
      label: import_prop_types.default.string,
      labelFontSize: import_prop_types.default.number,
      labelStyle: import_prop_types.default.object,
      max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
      min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
      position: import_prop_types.default.oneOf(["bottom", "top"]),
      reverse: import_prop_types.default.bool,
      scaleType: import_prop_types.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
      slotProps: import_prop_types.default.object,
      slots: import_prop_types.default.object,
      stroke: import_prop_types.default.string,
      sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
      tickFontSize: import_prop_types.default.number,
      tickInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.array, import_prop_types.default.func]),
      tickLabelInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.func]),
      tickLabelPlacement: import_prop_types.default.oneOf(["middle", "tick"]),
      tickLabelStyle: import_prop_types.default.object,
      tickMaxStep: import_prop_types.default.number,
      tickMinStep: import_prop_types.default.number,
      tickNumber: import_prop_types.default.number,
      tickPlacement: import_prop_types.default.oneOf(["end", "extremities", "middle", "start"]),
      tickSize: import_prop_types.default.number,
      valueFormatter: import_prop_types.default.func
    })),
    /**
     * The configuration of the y-axes.
     * If not provided, a default axis config is used.
     * An array of [[AxisConfig]] objects.
     */
    yAxis: import_prop_types.default.arrayOf(import_prop_types.default.shape({
      classes: import_prop_types.default.object,
      colorMap: import_prop_types.default.oneOfType([import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        type: import_prop_types.default.oneOf(["ordinal"]).isRequired,
        unknownColor: import_prop_types.default.string,
        values: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number, import_prop_types.default.string]).isRequired)
      }), import_prop_types.default.shape({
        color: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string.isRequired), import_prop_types.default.func]).isRequired,
        max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        type: import_prop_types.default.oneOf(["continuous"]).isRequired
      }), import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        thresholds: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]).isRequired).isRequired,
        type: import_prop_types.default.oneOf(["piecewise"]).isRequired
      })]),
      data: import_prop_types.default.array,
      dataKey: import_prop_types.default.string,
      disableLine: import_prop_types.default.bool,
      disableTicks: import_prop_types.default.bool,
      domainLimit: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["nice", "strict"]), import_prop_types.default.func]),
      fill: import_prop_types.default.string,
      hideTooltip: import_prop_types.default.bool,
      id: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]),
      label: import_prop_types.default.string,
      labelFontSize: import_prop_types.default.number,
      labelStyle: import_prop_types.default.object,
      max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
      min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
      position: import_prop_types.default.oneOf(["left", "right"]),
      reverse: import_prop_types.default.bool,
      scaleType: import_prop_types.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
      slotProps: import_prop_types.default.object,
      slots: import_prop_types.default.object,
      stroke: import_prop_types.default.string,
      sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
      tickFontSize: import_prop_types.default.number,
      tickInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.array, import_prop_types.default.func]),
      tickLabelInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.func]),
      tickLabelPlacement: import_prop_types.default.oneOf(["middle", "tick"]),
      tickLabelStyle: import_prop_types.default.object,
      tickMaxStep: import_prop_types.default.number,
      tickMinStep: import_prop_types.default.number,
      tickNumber: import_prop_types.default.number,
      tickPlacement: import_prop_types.default.oneOf(["end", "extremities", "middle", "start"]),
      tickSize: import_prop_types.default.number,
      valueFormatter: import_prop_types.default.func
    })),
    /**
     * The configuration of the z-axes.
     */
    zAxis: import_prop_types.default.arrayOf(import_prop_types.default.shape({
      colorMap: import_prop_types.default.oneOfType([import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        type: import_prop_types.default.oneOf(["ordinal"]).isRequired,
        unknownColor: import_prop_types.default.string,
        values: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number, import_prop_types.default.string]).isRequired)
      }), import_prop_types.default.shape({
        color: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string.isRequired), import_prop_types.default.func]).isRequired,
        max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        type: import_prop_types.default.oneOf(["continuous"]).isRequired
      }), import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        thresholds: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]).isRequired).isRequired,
        type: import_prop_types.default.oneOf(["piecewise"]).isRequired
      })]),
      data: import_prop_types.default.array,
      dataKey: import_prop_types.default.string,
      id: import_prop_types.default.string,
      max: import_prop_types.default.number,
      min: import_prop_types.default.number
    }))
  } : void 0;

  // node_modules/@mui/x-charts/ResponsiveChartContainer/ResizableContainer.js
  var ResizableContainer = styled_default2("div", {
    name: "MuiResponsiveChart",
    slot: "Container"
  })(({
    ownerState
  }) => {
    var _a, _b;
    return {
      width: (_a = ownerState.width) != null ? _a : "100%",
      height: (_b = ownerState.height) != null ? _b : "100%",
      display: "flex",
      position: "relative",
      flexGrow: 1,
      flexDirection: "column",
      alignItems: "center",
      justifyContent: "center",
      overflow: "hidden",
      "&>svg": {
        width: "100%",
        height: "100%"
      }
    };
  });

  // node_modules/@mui/x-charts/ResponsiveChartContainer/useChartContainerDimensions.js
  var React124 = __toESM(require_react());

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/useEnhancedEffect/useEnhancedEffect.js
  var React123 = __toESM(require_react(), 1);
  var useEnhancedEffect2 = typeof window !== "undefined" ? React123.useLayoutEffect : React123.useEffect;
  var useEnhancedEffect_default2 = useEnhancedEffect2;

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/ownerDocument/ownerDocument.js
  function ownerDocument2(node2) {
    return node2 && node2.ownerDocument || document;
  }

  // node_modules/@mui/x-charts/node_modules/@mui/utils/esm/ownerWindow/ownerWindow.js
  function ownerWindow2(node2) {
    const doc = ownerDocument2(node2);
    return doc.defaultView || window;
  }

  // node_modules/@mui/x-charts/ResponsiveChartContainer/useChartContainerDimensions.js
  var useChartContainerDimensions = (inWidth, inHeight, resolveSizeBeforeRender) => {
    const stateRef = React124.useRef({
      displayError: false,
      initialCompute: true,
      computeRun: 0
    });
    const rootRef = React124.useRef(null);
    const [width2, setWidth] = React124.useState(0);
    const [height2, setHeight] = React124.useState(0);
    const computeSize = React124.useCallback(() => {
      const mainEl = rootRef == null ? void 0 : rootRef.current;
      if (!mainEl) {
        return {};
      }
      const win = ownerWindow2(mainEl);
      const computedStyle = win.getComputedStyle(mainEl);
      const newHeight = Math.floor(parseFloat(computedStyle.height)) || 0;
      const newWidth = Math.floor(parseFloat(computedStyle.width)) || 0;
      setWidth(newWidth);
      setHeight(newHeight);
      return {
        width: newWidth,
        height: newHeight
      };
    }, []);
    React124.useEffect(() => {
      stateRef.current.displayError = true;
    }, []);
    useEnhancedEffect_default2(() => {
      if (!resolveSizeBeforeRender || !stateRef.current.initialCompute || stateRef.current.computeRun > 20) {
        return;
      }
      const computedSize = computeSize();
      if (computedSize.width !== width2 || computedSize.height !== height2) {
        stateRef.current.computeRun += 1;
      } else if (stateRef.current.initialCompute) {
        stateRef.current.initialCompute = false;
      }
    }, [width2, height2, computeSize, resolveSizeBeforeRender]);
    useEnhancedEffect_default2(() => {
      if (inWidth !== void 0 && inHeight !== void 0) {
        return () => {
        };
      }
      computeSize();
      const elementToObserve = rootRef.current;
      if (typeof ResizeObserver === "undefined") {
        return () => {
        };
      }
      let animationFrame;
      const observer = new ResizeObserver(() => {
        animationFrame = requestAnimationFrame(() => {
          computeSize();
        });
      });
      if (elementToObserve) {
        observer.observe(elementToObserve);
      }
      return () => {
        if (animationFrame) {
          cancelAnimationFrame(animationFrame);
        }
        if (elementToObserve) {
          observer.unobserve(elementToObserve);
        }
      };
    }, [computeSize, inHeight, inWidth]);
    if (false) {
      if (stateRef.current.displayError && inWidth === void 0 && width2 === 0) {
        console.error(`MUI X: ChartContainer does not have \`width\` prop, and its container has no \`width\` defined.`);
        stateRef.current.displayError = false;
      }
      if (stateRef.current.displayError && inHeight === void 0 && height2 === 0) {
        console.error(`MUI X: ChartContainer does not have \`height\` prop, and its container has no \`height\` defined.`);
        stateRef.current.displayError = false;
      }
    }
    return {
      containerRef: rootRef,
      width: inWidth != null ? inWidth : width2,
      height: inHeight != null ? inHeight : height2
    };
  };

  // node_modules/@mui/x-charts/ResponsiveChartContainer/useResponsiveChartContainerProps.js
  var _excluded10 = ["width", "height", "resolveSizeBeforeRender", "margin", "children", "series", "colors", "dataset", "desc", "disableAxisListener", "highlightedItem", "onHighlightChange", "plugins", "sx", "title", "viewBox", "xAxis", "yAxis", "zAxis", "skipAnimation"];
  var useResponsiveChartContainerProps = (props, ref) => {
    const {
      width: width2,
      height: height2,
      resolveSizeBeforeRender,
      margin: margin2,
      children,
      series,
      colors: colors3,
      dataset,
      desc,
      disableAxisListener,
      highlightedItem,
      onHighlightChange,
      plugins,
      sx,
      title,
      viewBox,
      xAxis,
      yAxis,
      zAxis,
      skipAnimation: skipAnimation2
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded10);
    const {
      containerRef,
      width: dWidth,
      height: dHeight
    } = useChartContainerDimensions(width2, height2, resolveSizeBeforeRender);
    const resizableChartContainerProps = _extends({}, other, {
      ownerState: {
        width: width2,
        height: height2
      },
      ref: containerRef
    });
    const chartContainerProps = {
      margin: margin2,
      children,
      series,
      colors: colors3,
      dataset,
      desc,
      disableAxisListener,
      highlightedItem,
      onHighlightChange,
      plugins,
      sx,
      title,
      viewBox,
      xAxis,
      yAxis,
      zAxis,
      skipAnimation: skipAnimation2,
      width: dWidth,
      height: dHeight,
      ref
    };
    return {
      hasIntrinsicSize: dWidth && dHeight,
      chartContainerProps,
      resizableChartContainerProps
    };
  };

  // node_modules/@mui/x-charts/ResponsiveChartContainer/ResponsiveChartContainer.js
  var import_jsx_runtime72 = __toESM(require_jsx_runtime());
  var ResponsiveChartContainer = /* @__PURE__ */ React125.forwardRef(function ResponsiveChartContainer2(props, ref) {
    const {
      hasIntrinsicSize,
      chartContainerProps,
      resizableChartContainerProps
    } = useResponsiveChartContainerProps(props, ref);
    return /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(ResizableContainer, _extends({}, resizableChartContainerProps, {
      children: hasIntrinsicSize ? /* @__PURE__ */ (0, import_jsx_runtime72.jsx)(ChartContainer, _extends({}, chartContainerProps)) : null
    }));
  });
  false ? ResponsiveChartContainer.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    children: import_prop_types.default.node,
    className: import_prop_types.default.string,
    /**
     * Color palette used to colorize multiple series.
     * @default blueberryTwilightPalette
     */
    colors: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string), import_prop_types.default.func]),
    /**
     * An array of objects that can be used to populate series and axes data using their `dataKey` property.
     */
    dataset: import_prop_types.default.arrayOf(import_prop_types.default.object),
    desc: import_prop_types.default.string,
    /**
     * If `true`, the charts will not listen to the mouse move event.
     * It might break interactive features, but will improve performance.
     * @default false
     */
    disableAxisListener: import_prop_types.default.bool,
    /**
     * The height of the chart in px. If not defined, it takes the height of the parent element.
     */
    height: import_prop_types.default.number,
    /**
     * The item currently highlighted. Turns highlighting into a controlled prop.
     */
    highlightedItem: import_prop_types.default.shape({
      dataIndex: import_prop_types.default.number,
      seriesId: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string])
    }),
    /**
     * The margin between the SVG and the drawing area.
     * It's used for leaving some space for extra information such as the x- and y-axis or legend.
     * Accepts an object with the optional properties: `top`, `bottom`, `left`, and `right`.
     * @default object Depends on the charts type.
     */
    margin: import_prop_types.default.shape({
      bottom: import_prop_types.default.number,
      left: import_prop_types.default.number,
      right: import_prop_types.default.number,
      top: import_prop_types.default.number
    }),
    /**
     * The callback fired when the highlighted item changes.
     *
     * @param {HighlightItemData | null} highlightedItem  The newly highlighted item.
     */
    onHighlightChange: import_prop_types.default.func,
    /**
     * An array of plugins defining how to preprocess data.
     * If not provided, the container supports line, bar, scatter and pie charts.
     */
    plugins: import_prop_types.default.arrayOf(import_prop_types.default.object),
    /**
     * The chart will try to wait for the parent container to resolve its size
     * before it renders for the first time.
     *
     * This can be useful in some scenarios where the chart appear to grow after
     * the first render, like when used inside a grid.
     *
     * @default false
     */
    resolveSizeBeforeRender: import_prop_types.default.bool,
    /**
     * The array of series to display.
     * Each type of series has its own specificity.
     * Please refer to the appropriate docs page to learn more about it.
     */
    series: import_prop_types.default.arrayOf(import_prop_types.default.object).isRequired,
    /**
     * If `true`, animations are skipped.
     * If unset or `false`, the animations respects the user's `prefers-reduced-motion` setting.
     */
    skipAnimation: import_prop_types.default.bool,
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    title: import_prop_types.default.string,
    viewBox: import_prop_types.default.shape({
      height: import_prop_types.default.number,
      width: import_prop_types.default.number,
      x: import_prop_types.default.number,
      y: import_prop_types.default.number
    }),
    /**
     * The width of the chart in px. If not defined, it takes the width of the parent element.
     */
    width: import_prop_types.default.number,
    /**
     * The configuration of the x-axes.
     * If not provided, a default axis config is used.
     * An array of [[AxisConfig]] objects.
     */
    xAxis: import_prop_types.default.arrayOf(import_prop_types.default.shape({
      classes: import_prop_types.default.object,
      colorMap: import_prop_types.default.oneOfType([import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        type: import_prop_types.default.oneOf(["ordinal"]).isRequired,
        unknownColor: import_prop_types.default.string,
        values: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number, import_prop_types.default.string]).isRequired)
      }), import_prop_types.default.shape({
        color: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string.isRequired), import_prop_types.default.func]).isRequired,
        max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        type: import_prop_types.default.oneOf(["continuous"]).isRequired
      }), import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        thresholds: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]).isRequired).isRequired,
        type: import_prop_types.default.oneOf(["piecewise"]).isRequired
      })]),
      data: import_prop_types.default.array,
      dataKey: import_prop_types.default.string,
      disableLine: import_prop_types.default.bool,
      disableTicks: import_prop_types.default.bool,
      domainLimit: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["nice", "strict"]), import_prop_types.default.func]),
      fill: import_prop_types.default.string,
      hideTooltip: import_prop_types.default.bool,
      id: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]),
      label: import_prop_types.default.string,
      labelFontSize: import_prop_types.default.number,
      labelStyle: import_prop_types.default.object,
      max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
      min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
      position: import_prop_types.default.oneOf(["bottom", "top"]),
      reverse: import_prop_types.default.bool,
      scaleType: import_prop_types.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
      slotProps: import_prop_types.default.object,
      slots: import_prop_types.default.object,
      stroke: import_prop_types.default.string,
      sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
      tickFontSize: import_prop_types.default.number,
      tickInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.array, import_prop_types.default.func]),
      tickLabelInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.func]),
      tickLabelPlacement: import_prop_types.default.oneOf(["middle", "tick"]),
      tickLabelStyle: import_prop_types.default.object,
      tickMaxStep: import_prop_types.default.number,
      tickMinStep: import_prop_types.default.number,
      tickNumber: import_prop_types.default.number,
      tickPlacement: import_prop_types.default.oneOf(["end", "extremities", "middle", "start"]),
      tickSize: import_prop_types.default.number,
      valueFormatter: import_prop_types.default.func
    })),
    /**
     * The configuration of the y-axes.
     * If not provided, a default axis config is used.
     * An array of [[AxisConfig]] objects.
     */
    yAxis: import_prop_types.default.arrayOf(import_prop_types.default.shape({
      classes: import_prop_types.default.object,
      colorMap: import_prop_types.default.oneOfType([import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        type: import_prop_types.default.oneOf(["ordinal"]).isRequired,
        unknownColor: import_prop_types.default.string,
        values: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number, import_prop_types.default.string]).isRequired)
      }), import_prop_types.default.shape({
        color: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string.isRequired), import_prop_types.default.func]).isRequired,
        max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        type: import_prop_types.default.oneOf(["continuous"]).isRequired
      }), import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        thresholds: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]).isRequired).isRequired,
        type: import_prop_types.default.oneOf(["piecewise"]).isRequired
      })]),
      data: import_prop_types.default.array,
      dataKey: import_prop_types.default.string,
      disableLine: import_prop_types.default.bool,
      disableTicks: import_prop_types.default.bool,
      domainLimit: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["nice", "strict"]), import_prop_types.default.func]),
      fill: import_prop_types.default.string,
      hideTooltip: import_prop_types.default.bool,
      id: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]),
      label: import_prop_types.default.string,
      labelFontSize: import_prop_types.default.number,
      labelStyle: import_prop_types.default.object,
      max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
      min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
      position: import_prop_types.default.oneOf(["left", "right"]),
      reverse: import_prop_types.default.bool,
      scaleType: import_prop_types.default.oneOf(["band", "linear", "log", "point", "pow", "sqrt", "time", "utc"]),
      slotProps: import_prop_types.default.object,
      slots: import_prop_types.default.object,
      stroke: import_prop_types.default.string,
      sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
      tickFontSize: import_prop_types.default.number,
      tickInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.array, import_prop_types.default.func]),
      tickLabelInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.func]),
      tickLabelPlacement: import_prop_types.default.oneOf(["middle", "tick"]),
      tickLabelStyle: import_prop_types.default.object,
      tickMaxStep: import_prop_types.default.number,
      tickMinStep: import_prop_types.default.number,
      tickNumber: import_prop_types.default.number,
      tickPlacement: import_prop_types.default.oneOf(["end", "extremities", "middle", "start"]),
      tickSize: import_prop_types.default.number,
      valueFormatter: import_prop_types.default.func
    })),
    /**
     * The configuration of the z-axes.
     */
    zAxis: import_prop_types.default.arrayOf(import_prop_types.default.shape({
      colorMap: import_prop_types.default.oneOfType([import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        type: import_prop_types.default.oneOf(["ordinal"]).isRequired,
        unknownColor: import_prop_types.default.string,
        values: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number, import_prop_types.default.string]).isRequired)
      }), import_prop_types.default.shape({
        color: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.string.isRequired), import_prop_types.default.func]).isRequired,
        max: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        min: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]),
        type: import_prop_types.default.oneOf(["continuous"]).isRequired
      }), import_prop_types.default.shape({
        colors: import_prop_types.default.arrayOf(import_prop_types.default.string).isRequired,
        thresholds: import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number]).isRequired).isRequired,
        type: import_prop_types.default.oneOf(["piecewise"]).isRequired
      })]),
      data: import_prop_types.default.array,
      dataKey: import_prop_types.default.string,
      id: import_prop_types.default.string,
      max: import_prop_types.default.number,
      min: import_prop_types.default.number
    }))
  } : void 0;

  // node_modules/@mui/x-charts/ChartsXAxis/ChartsXAxis.js
  var React128 = __toESM(require_react());

  // node_modules/@mui/x-charts/ChartsAxis/axisClasses.js
  function getAxisUtilityClass(slot) {
    return generateUtilityClass2("MuiChartsAxis", slot);
  }
  var axisClasses = generateUtilityClasses2("MuiChartsAxis", ["root", "line", "tickContainer", "tick", "tickLabel", "label", "directionX", "directionY", "top", "bottom", "left", "right"]);

  // node_modules/@mui/x-charts/internals/components/AxisSharedComponents.js
  var AxisRoot = styled_default2("g", {
    name: "MuiChartsAxis",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })(({
    theme
  }) => ({
    [`& .${axisClasses.tickLabel}`]: _extends({}, theme.typography.caption, {
      fill: (theme.vars || theme).palette.text.primary
    }),
    [`& .${axisClasses.label}`]: _extends({}, theme.typography.body1, {
      fill: (theme.vars || theme).palette.text.primary
    }),
    [`& .${axisClasses.line}`]: {
      stroke: (theme.vars || theme).palette.text.primary,
      shapeRendering: "crispEdges",
      strokeWidth: 1
    },
    [`& .${axisClasses.tick}`]: {
      stroke: (theme.vars || theme).palette.text.primary,
      shapeRendering: "crispEdges"
    }
  }));

  // node_modules/@mui/x-charts/ChartsText/ChartsText.js
  var React126 = __toESM(require_react());

  // node_modules/@mui/x-charts/internals/domUtils.js
  function isSsr() {
    return typeof window === "undefined";
  }
  var stringCache = {
    widthCache: {},
    cacheCount: 0
  };
  var MAX_CACHE_NUM = 2e3;
  var SPAN_STYLE = {
    position: "absolute",
    top: "-20000px",
    left: 0,
    padding: 0,
    margin: 0,
    border: "none",
    whiteSpace: "pre"
  };
  var STYLE_LIST = ["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height", "top", "left", "fontSize", "padding", "margin", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom"];
  var MEASUREMENT_SPAN_ID = "mui_measurement_span";
  function autoCompleteStyle(name, value) {
    if (STYLE_LIST.indexOf(name) >= 0 && value === +value) {
      return `${value}px`;
    }
    return value;
  }
  function camelToMiddleLine(text) {
    const strs = text.split("");
    const formatStrs = strs.reduce((result, entry) => {
      if (entry === entry.toUpperCase()) {
        return [...result, "-", entry.toLowerCase()];
      }
      return [...result, entry];
    }, []);
    return formatStrs.join("");
  }
  var getStyleString = (style4) => Object.keys(style4).sort().reduce((result, s) => `${result}${camelToMiddleLine(s)}:${autoCompleteStyle(s, style4[s])};`, "");
  var domCleanTimeout;
  var getStringSize = (text, style4 = {}) => {
    if (text === void 0 || text === null || isSsr()) {
      return {
        width: 0,
        height: 0
      };
    }
    const str = `${text}`;
    const styleString = getStyleString(style4);
    const cacheKey2 = `${str}-${styleString}`;
    if (stringCache.widthCache[cacheKey2]) {
      return stringCache.widthCache[cacheKey2];
    }
    try {
      let measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
      if (measurementSpan === null) {
        measurementSpan = document.createElement("span");
        measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
        measurementSpan.setAttribute("aria-hidden", "true");
        document.body.appendChild(measurementSpan);
      }
      const measurementSpanStyle = _extends({}, SPAN_STYLE, style4);
      Object.keys(measurementSpanStyle).map((styleKey) => {
        measurementSpan.style[camelToMiddleLine(styleKey)] = autoCompleteStyle(styleKey, measurementSpanStyle[styleKey]);
        return styleKey;
      });
      measurementSpan.textContent = str;
      const rect = measurementSpan.getBoundingClientRect();
      const result = {
        width: rect.width,
        height: rect.height
      };
      stringCache.widthCache[cacheKey2] = result;
      if (stringCache.cacheCount + 1 > MAX_CACHE_NUM) {
        stringCache.cacheCount = 0;
        stringCache.widthCache = {};
      } else {
        stringCache.cacheCount += 1;
      }
      if (domCleanTimeout) {
        clearTimeout(domCleanTimeout);
      }
      domCleanTimeout = setTimeout(() => {
        measurementSpan.textContent = "";
      }, 0);
      return result;
    } catch (e) {
      return {
        width: 0,
        height: 0
      };
    }
  };

  // node_modules/@mui/x-charts/internals/getWordsByLines.js
  function getWordsByLines({
    style: style4,
    needsComputation,
    text
  }) {
    return text.split("\n").map((subText) => _extends({
      text: subText
    }, needsComputation ? getStringSize(subText, style4) : {
      width: 0,
      height: 0
    }));
  }

  // node_modules/@mui/x-charts/ChartsText/ChartsText.js
  var import_jsx_runtime73 = __toESM(require_jsx_runtime());
  var _excluded11 = ["x", "y", "style", "text", "ownerState"];
  var _excluded23 = ["angle", "textAnchor", "dominantBaseline"];
  function ChartsText(props) {
    const {
      x,
      y,
      style: styleProps,
      text
    } = props, textProps = _objectWithoutPropertiesLoose(props, _excluded11);
    const _ref = styleProps != null ? styleProps : {}, {
      angle,
      textAnchor,
      dominantBaseline
    } = _ref, style4 = _objectWithoutPropertiesLoose(_ref, _excluded23);
    const wordsByLines = React126.useMemo(() => getWordsByLines({
      style: style4,
      needsComputation: text.includes("\n"),
      text
    }), [style4, text]);
    let startDy;
    switch (dominantBaseline) {
      case "hanging":
        startDy = 0;
        break;
      case "central":
        startDy = (wordsByLines.length - 1) / 2 * -wordsByLines[0].height;
        break;
      default:
        startDy = (wordsByLines.length - 1) * -wordsByLines[0].height;
        break;
    }
    const transforms = [];
    if (angle) {
      transforms.push(`rotate(${angle}, ${x}, ${y})`);
    }
    return /* @__PURE__ */ (0, import_jsx_runtime73.jsx)("text", _extends({}, textProps, {
      transform: transforms.length > 0 ? transforms.join(" ") : void 0,
      x,
      y,
      textAnchor,
      dominantBaseline,
      style: style4,
      children: wordsByLines.map((line2, index) => /* @__PURE__ */ (0, import_jsx_runtime73.jsx)("tspan", {
        x,
        dy: `${index === 0 ? startDy : wordsByLines[0].height}px`,
        dominantBaseline,
        children: line2.text
      }, index))
    }));
  }
  false ? ChartsText.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Height of a text line (in `em`).
     */
    lineHeight: import_prop_types.default.number,
    /**
     * If `true`, the line width is computed.
     * @default false
     */
    needsComputation: import_prop_types.default.bool,
    ownerState: import_prop_types.default.any,
    /**
     * Style applied to text elements.
     */
    style: import_prop_types.default.object,
    /**
     * Text displayed.
     */
    text: import_prop_types.default.string.isRequired
  } : void 0;

  // node_modules/@mui/x-charts/internals/geometry.js
  var ANGLE_APPROX = 5;
  function getMinXTranslation(width2, height2, angle = 0) {
    if (false) {
      if (angle > 90 && angle < -90) {
        warnOnce([`MUI X: It seems you applied an angle larger than 90\xB0 or smaller than -90\xB0 to an axis text.`, `This could cause some text overlapping.`, `If you encounter a use case where it's needed, please open an issue.`]);
      }
    }
    const standardAngle = Math.min(Math.abs(angle) % 180, Math.abs(Math.abs(angle) % 180 - 180) % 180);
    if (standardAngle < ANGLE_APPROX) {
      return width2;
    }
    if (standardAngle > 90 - ANGLE_APPROX) {
      return height2;
    }
    const radAngle = standardAngle * Math.PI / 180;
    const angleSwich = Math.atan2(height2, width2);
    if (radAngle < angleSwich) {
      return width2 / Math.cos(radAngle);
    }
    return height2 / Math.sin(radAngle);
  }

  // node_modules/@mui/x-charts/hooks/useMounted.js
  var React127 = __toESM(require_react());
  function useMounted(defer = false) {
    const [mountedState, setMountedState] = React127.useState(false);
    useEnhancedEffect_default2(() => {
      if (!defer) {
        setMountedState(true);
      }
    }, [defer]);
    React127.useEffect(() => {
      if (defer) {
        setMountedState(true);
      }
    }, [defer]);
    return mountedState;
  }

  // node_modules/@mui/x-charts/ChartsXAxis/ChartsXAxis.js
  var import_jsx_runtime74 = __toESM(require_jsx_runtime());
  var _excluded12 = ["scale", "tickNumber", "reverse"];
  var useUtilityClasses25 = (ownerState) => {
    const {
      classes,
      position: position2
    } = ownerState;
    const slots = {
      root: ["root", "directionX", position2],
      line: ["line"],
      tickContainer: ["tickContainer"],
      tick: ["tick"],
      tickLabel: ["tickLabel"],
      label: ["label"]
    };
    return composeClasses2(slots, getAxisUtilityClass, classes);
  };
  function addLabelDimension(xTicks, {
    tickLabelStyle: style4,
    tickLabelInterval,
    reverse,
    isMounted
  }) {
    const withDimension = xTicks.map((tick) => {
      if (!isMounted || tick.formattedValue === void 0) {
        return _extends({}, tick, {
          width: 0,
          height: 0
        });
      }
      const tickSizes = getWordsByLines({
        style: style4,
        needsComputation: true,
        text: tick.formattedValue
      });
      return _extends({}, tick, {
        width: Math.max(...tickSizes.map((size) => size.width)),
        height: Math.max(tickSizes.length * tickSizes[0].height)
      });
    });
    if (typeof tickLabelInterval === "function") {
      return withDimension.map((item, index) => _extends({}, item, {
        skipLabel: !tickLabelInterval(item.value, index)
      }));
    }
    let currentTextLimit = 0;
    let previousTextLimit = 0;
    const direction = reverse ? -1 : 1;
    return withDimension.map((item, labelIndex) => {
      const {
        width: width2,
        offset: offset2,
        labelOffset,
        height: height2
      } = item;
      const distance = getMinXTranslation(width2, height2, style4 == null ? void 0 : style4.angle);
      const textPosition = offset2 + labelOffset;
      const gapRatio = 1.2;
      currentTextLimit = textPosition - direction * (gapRatio * distance) / 2;
      if (labelIndex > 0 && direction * currentTextLimit < direction * previousTextLimit) {
        return _extends({}, item, {
          skipLabel: true
        });
      }
      previousTextLimit = textPosition + direction * (gapRatio * distance) / 2;
      return item;
    });
  }
  var XAxisRoot = styled_default2(AxisRoot, {
    name: "MuiChartsXAxis",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  var defaultProps2 = {
    position: "bottom",
    disableLine: false,
    disableTicks: false,
    tickSize: 6
  };
  function ChartsXAxis(inProps) {
    var _a, _b, _c, _d, _e;
    const {
      xAxisIds,
      xAxis
    } = useCartesianContext();
    const _xAxis = xAxis[(_a = inProps.axisId) != null ? _a : xAxisIds[0]], {
      scale: xScale,
      tickNumber,
      reverse
    } = _xAxis, settings = _objectWithoutPropertiesLoose(_xAxis, _excluded12);
    const isMounted = useMounted();
    const themedProps = useThemeProps2({
      props: _extends({}, settings, inProps),
      name: "MuiChartsXAxis"
    });
    const defaultizedProps = _extends({}, defaultProps2, themedProps);
    const {
      position: position2,
      disableLine,
      disableTicks,
      tickLabelStyle,
      label,
      labelStyle,
      tickFontSize,
      labelFontSize,
      tickSize: tickSizeProp,
      valueFormatter,
      slots,
      slotProps,
      tickInterval,
      tickLabelInterval,
      tickPlacement,
      tickLabelPlacement,
      sx
    } = defaultizedProps;
    const theme = useTheme5();
    const classes = useUtilityClasses25(_extends({}, defaultizedProps, {
      theme
    }));
    const {
      left: left2,
      top: top2,
      width: width2,
      height: height2,
      isPointInside
    } = useDrawingArea();
    const tickSize = disableTicks ? 4 : tickSizeProp;
    const positionSign = position2 === "bottom" ? 1 : -1;
    const Line = (_b = slots == null ? void 0 : slots.axisLine) != null ? _b : "line";
    const Tick = (_c = slots == null ? void 0 : slots.axisTick) != null ? _c : "line";
    const TickLabel = (_d = slots == null ? void 0 : slots.axisTickLabel) != null ? _d : ChartsText;
    const Label = (_e = slots == null ? void 0 : slots.axisLabel) != null ? _e : ChartsText;
    const axisTickLabelProps = useSlotProps_default2({
      elementType: TickLabel,
      externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
      additionalProps: {
        style: _extends({
          textAnchor: "middle",
          dominantBaseline: position2 === "bottom" ? "hanging" : "auto",
          fontSize: tickFontSize != null ? tickFontSize : 12
        }, tickLabelStyle)
      },
      className: classes.tickLabel,
      ownerState: {}
    });
    const xTicks = useTicks({
      scale: xScale,
      tickNumber,
      valueFormatter,
      tickInterval,
      tickPlacement,
      tickLabelPlacement
    });
    const xTicksWithDimension = addLabelDimension(xTicks, {
      tickLabelStyle: axisTickLabelProps.style,
      tickLabelInterval,
      reverse,
      isMounted
    });
    const labelRefPoint = {
      x: left2 + width2 / 2,
      y: positionSign * (tickSize + 22)
    };
    const axisLabelProps = useSlotProps_default2({
      elementType: Label,
      externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
      additionalProps: {
        style: _extends({
          fontSize: labelFontSize != null ? labelFontSize : 14,
          textAnchor: "middle",
          dominantBaseline: position2 === "bottom" ? "hanging" : "auto"
        }, labelStyle)
      },
      ownerState: {}
    });
    const domain = xScale.domain();
    const ordinalAxis = isBandScale(xScale);
    if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity)) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime74.jsxs)(XAxisRoot, {
      transform: `translate(0, ${position2 === "bottom" ? top2 + height2 : top2})`,
      className: classes.root,
      sx,
      children: [!disableLine && /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(Line, _extends({
        x1: left2,
        x2: left2 + width2,
        className: classes.line
      }, slotProps == null ? void 0 : slotProps.axisLine)), xTicksWithDimension.map(({
        formattedValue,
        offset: offset2,
        labelOffset,
        skipLabel
      }, index) => {
        const xTickLabel = labelOffset != null ? labelOffset : 0;
        const yTickLabel = positionSign * (tickSize + 3);
        const showTick = isPointInside({
          x: offset2,
          y: -1
        }, {
          direction: "x"
        });
        const showTickLabel = isPointInside({
          x: offset2 + xTickLabel,
          y: -1
        }, {
          direction: "x"
        });
        return /* @__PURE__ */ (0, import_jsx_runtime74.jsxs)("g", {
          transform: `translate(${offset2}, 0)`,
          className: classes.tickContainer,
          children: [!disableTicks && showTick && /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(Tick, _extends({
            y2: positionSign * tickSize,
            className: classes.tick
          }, slotProps == null ? void 0 : slotProps.axisTick)), formattedValue !== void 0 && !skipLabel && showTickLabel && /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(TickLabel, _extends({
            x: xTickLabel,
            y: yTickLabel
          }, axisTickLabelProps, {
            text: formattedValue.toString()
          }))]
        }, index);
      }), label && /* @__PURE__ */ (0, import_jsx_runtime74.jsx)("g", {
        className: classes.label,
        children: /* @__PURE__ */ (0, import_jsx_runtime74.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
          text: label
        }))
      })]
    });
  }
  false ? ChartsXAxis.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * The id of the axis to render.
     * If undefined, it will be the first defined axis.
     */
    axisId: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]),
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * If true, the axis line is disabled.
     * @default false
     */
    disableLine: import_prop_types.default.bool,
    /**
     * If true, the ticks are disabled.
     * @default false
     */
    disableTicks: import_prop_types.default.bool,
    /**
     * The fill color of the axis text.
     * @default 'currentColor'
     */
    fill: import_prop_types.default.string,
    /**
     * The label of the axis.
     */
    label: import_prop_types.default.string,
    /**
     * The font size of the axis label.
     * @default 14
     * @deprecated Consider using `labelStyle.fontSize` instead.
     */
    labelFontSize: import_prop_types.default.number,
    /**
     * The style applied to the axis label.
     */
    labelStyle: import_prop_types.default.object,
    /**
     * Position of the axis.
     */
    position: import_prop_types.default.oneOf(["bottom", "top"]),
    /**
     * The props used for each component slot.
     * @default {}
     */
    slotProps: import_prop_types.default.object,
    /**
     * Overridable component slots.
     * @default {}
     */
    slots: import_prop_types.default.object,
    /**
     * The stroke color of the axis line.
     * @default 'currentColor'
     */
    stroke: import_prop_types.default.string,
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * The font size of the axis ticks text.
     * @default 12
     * @deprecated Consider using `tickLabelStyle.fontSize` instead.
     */
    tickFontSize: import_prop_types.default.number,
    /**
     * Defines which ticks are displayed.
     * Its value can be:
     * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
     * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
     * - an array containing the values where ticks should be displayed.
     * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
     * @default 'auto'
     */
    tickInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.array, import_prop_types.default.func]),
    /**
     * Defines which ticks get its label displayed. Its value can be:
     * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
     * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
     * @default 'auto'
     */
    tickLabelInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.func]),
    /**
     * The placement of ticks label. Can be the middle of the band, or the tick position.
     * Only used if scale is 'band'.
     * @default 'middle'
     */
    tickLabelPlacement: import_prop_types.default.oneOf(["middle", "tick"]),
    /**
     * The style applied to ticks text.
     */
    tickLabelStyle: import_prop_types.default.object,
    /**
     * Maximal step between two ticks.
     * When using time data, the value is assumed to be in ms.
     * Not supported by categorical axis (band, points).
     */
    tickMaxStep: import_prop_types.default.number,
    /**
     * Minimal step between two ticks.
     * When using time data, the value is assumed to be in ms.
     * Not supported by categorical axis (band, points).
     */
    tickMinStep: import_prop_types.default.number,
    /**
     * The number of ticks. This number is not guaranteed.
     * Not supported by categorical axis (band, points).
     */
    tickNumber: import_prop_types.default.number,
    /**
     * The placement of ticks in regard to the band interval.
     * Only used if scale is 'band'.
     * @default 'extremities'
     */
    tickPlacement: import_prop_types.default.oneOf(["end", "extremities", "middle", "start"]),
    /**
     * The size of the ticks.
     * @default 6
     */
    tickSize: import_prop_types.default.number
  } : void 0;

  // node_modules/@mui/x-charts/ChartsYAxis/ChartsYAxis.js
  var React129 = __toESM(require_react());
  var import_jsx_runtime75 = __toESM(require_jsx_runtime());
  var _excluded13 = ["scale", "tickNumber"];
  var useUtilityClasses26 = (ownerState) => {
    const {
      classes,
      position: position2
    } = ownerState;
    const slots = {
      root: ["root", "directionY", position2],
      line: ["line"],
      tickContainer: ["tickContainer"],
      tick: ["tick"],
      tickLabel: ["tickLabel"],
      label: ["label"]
    };
    return composeClasses2(slots, getAxisUtilityClass, classes);
  };
  var YAxisRoot = styled_default2(AxisRoot, {
    name: "MuiChartsYAxis",
    slot: "Root",
    overridesResolver: (props, styles2) => styles2.root
  })({});
  var defaultProps3 = {
    position: "left",
    disableLine: false,
    disableTicks: false,
    tickFontSize: 12,
    labelFontSize: 14,
    tickSize: 6
  };
  function ChartsYAxis(inProps) {
    var _a, _b, _c, _d, _e;
    const {
      yAxisIds,
      yAxis
    } = useCartesianContext();
    const _yAxis = yAxis[(_a = inProps.axisId) != null ? _a : yAxisIds[0]], {
      scale: yScale,
      tickNumber
    } = _yAxis, settings = _objectWithoutPropertiesLoose(_yAxis, _excluded13);
    const themedProps = useThemeProps2({
      props: _extends({}, settings, inProps),
      name: "MuiChartsYAxis"
    });
    const defaultizedProps = _extends({}, defaultProps3, themedProps);
    const {
      position: position2,
      disableLine,
      disableTicks,
      tickFontSize,
      label,
      labelFontSize,
      labelStyle,
      tickLabelStyle,
      tickSize: tickSizeProp,
      valueFormatter,
      slots,
      slotProps,
      tickPlacement,
      tickLabelPlacement,
      tickInterval,
      tickLabelInterval,
      sx
    } = defaultizedProps;
    const theme = useTheme5();
    const isRtl = useRtl();
    const classes = useUtilityClasses26(_extends({}, defaultizedProps, {
      theme
    }));
    const {
      left: left2,
      top: top2,
      width: width2,
      height: height2,
      isPointInside
    } = useDrawingArea();
    const tickSize = disableTicks ? 4 : tickSizeProp;
    const yTicks = useTicks({
      scale: yScale,
      tickNumber,
      valueFormatter,
      tickPlacement,
      tickLabelPlacement,
      tickInterval
    });
    const positionSign = position2 === "right" ? 1 : -1;
    const labelRefPoint = {
      x: positionSign * (tickFontSize + tickSize + 10),
      y: top2 + height2 / 2
    };
    const Line = (_b = slots == null ? void 0 : slots.axisLine) != null ? _b : "line";
    const Tick = (_c = slots == null ? void 0 : slots.axisTick) != null ? _c : "line";
    const TickLabel = (_d = slots == null ? void 0 : slots.axisTickLabel) != null ? _d : ChartsText;
    const Label = (_e = slots == null ? void 0 : slots.axisLabel) != null ? _e : ChartsText;
    const revertAnchor = !isRtl && position2 === "right" || isRtl && position2 !== "right";
    const axisTickLabelProps = useSlotProps_default2({
      elementType: TickLabel,
      externalSlotProps: slotProps == null ? void 0 : slotProps.axisTickLabel,
      additionalProps: {
        style: _extends({
          fontSize: tickFontSize,
          textAnchor: revertAnchor ? "start" : "end",
          dominantBaseline: "central"
        }, tickLabelStyle)
      },
      className: classes.tickLabel,
      ownerState: {}
    });
    const axisLabelProps = useSlotProps_default2({
      elementType: Label,
      externalSlotProps: slotProps == null ? void 0 : slotProps.axisLabel,
      additionalProps: {
        style: _extends({
          fontSize: labelFontSize,
          angle: positionSign * 90,
          textAnchor: "middle",
          dominantBaseline: "auto"
        }, labelStyle)
      },
      ownerState: {}
    });
    const lineSlotProps = useSlotProps_default2({
      elementType: Line,
      externalSlotProps: slotProps == null ? void 0 : slotProps.axisLine,
      additionalProps: {
        strokeLinecap: "square"
      },
      ownerState: {}
    });
    const domain = yScale.domain();
    const ordinalAxis = isBandScale(yScale);
    if (ordinalAxis && domain.length === 0 || !ordinalAxis && domain.some(isInfinity)) {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)(YAxisRoot, {
      transform: `translate(${position2 === "right" ? left2 + width2 : left2}, 0)`,
      className: classes.root,
      sx,
      children: [!disableLine && /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Line, _extends({
        y1: top2,
        y2: top2 + height2,
        className: classes.line
      }, lineSlotProps)), yTicks.map(({
        formattedValue,
        offset: offset2,
        labelOffset,
        value
      }, index) => {
        const xTickLabel = positionSign * (tickSize + 2);
        const yTickLabel = labelOffset;
        const skipLabel = typeof tickLabelInterval === "function" && !(tickLabelInterval == null ? void 0 : tickLabelInterval(value, index));
        const showLabel = isPointInside({
          x: -1,
          y: offset2
        }, {
          direction: "y"
        });
        if (!showLabel) {
          return null;
        }
        return /* @__PURE__ */ (0, import_jsx_runtime75.jsxs)("g", {
          transform: `translate(0, ${offset2})`,
          className: classes.tickContainer,
          children: [!disableTicks && /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Tick, _extends({
            x2: positionSign * tickSize,
            className: classes.tick
          }, slotProps == null ? void 0 : slotProps.axisTick)), formattedValue !== void 0 && !skipLabel && /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(TickLabel, _extends({
            x: xTickLabel,
            y: yTickLabel,
            text: formattedValue.toString()
          }, axisTickLabelProps))]
        }, index);
      }), label && /* @__PURE__ */ (0, import_jsx_runtime75.jsx)("g", {
        className: classes.label,
        children: /* @__PURE__ */ (0, import_jsx_runtime75.jsx)(Label, _extends({}, labelRefPoint, axisLabelProps, {
          text: label
        }))
      })]
    });
  }
  false ? ChartsYAxis.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * The id of the axis to render.
     * If undefined, it will be the first defined axis.
     */
    axisId: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]),
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * If true, the axis line is disabled.
     * @default false
     */
    disableLine: import_prop_types.default.bool,
    /**
     * If true, the ticks are disabled.
     * @default false
     */
    disableTicks: import_prop_types.default.bool,
    /**
     * The fill color of the axis text.
     * @default 'currentColor'
     */
    fill: import_prop_types.default.string,
    /**
     * The label of the axis.
     */
    label: import_prop_types.default.string,
    /**
     * The font size of the axis label.
     * @default 14
     * @deprecated Consider using `labelStyle.fontSize` instead.
     */
    labelFontSize: import_prop_types.default.number,
    /**
     * The style applied to the axis label.
     */
    labelStyle: import_prop_types.default.object,
    /**
     * Position of the axis.
     */
    position: import_prop_types.default.oneOf(["left", "right"]),
    /**
     * The props used for each component slot.
     * @default {}
     */
    slotProps: import_prop_types.default.object,
    /**
     * Overridable component slots.
     * @default {}
     */
    slots: import_prop_types.default.object,
    /**
     * The stroke color of the axis line.
     * @default 'currentColor'
     */
    stroke: import_prop_types.default.string,
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object]),
    /**
     * The font size of the axis ticks text.
     * @default 12
     * @deprecated Consider using `tickLabelStyle.fontSize` instead.
     */
    tickFontSize: import_prop_types.default.number,
    /**
     * Defines which ticks are displayed.
     * Its value can be:
     * - 'auto' In such case the ticks are computed based on axis scale and other parameters.
     * - a filtering function of the form `(value, index) => boolean` which is available only if the axis has "point" scale.
     * - an array containing the values where ticks should be displayed.
     * @see See {@link https://mui.com/x/react-charts/axis/#fixed-tick-positions}
     * @default 'auto'
     */
    tickInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.array, import_prop_types.default.func]),
    /**
     * Defines which ticks get its label displayed. Its value can be:
     * - 'auto' In such case, labels are displayed if they do not overlap with the previous one.
     * - a filtering function of the form (value, index) => boolean. Warning: the index is tick index, not data ones.
     * @default 'auto'
     */
    tickLabelInterval: import_prop_types.default.oneOfType([import_prop_types.default.oneOf(["auto"]), import_prop_types.default.func]),
    /**
     * The placement of ticks label. Can be the middle of the band, or the tick position.
     * Only used if scale is 'band'.
     * @default 'middle'
     */
    tickLabelPlacement: import_prop_types.default.oneOf(["middle", "tick"]),
    /**
     * The style applied to ticks text.
     */
    tickLabelStyle: import_prop_types.default.object,
    /**
     * Maximal step between two ticks.
     * When using time data, the value is assumed to be in ms.
     * Not supported by categorical axis (band, points).
     */
    tickMaxStep: import_prop_types.default.number,
    /**
     * Minimal step between two ticks.
     * When using time data, the value is assumed to be in ms.
     * Not supported by categorical axis (band, points).
     */
    tickMinStep: import_prop_types.default.number,
    /**
     * The number of ticks. This number is not guaranteed.
     * Not supported by categorical axis (band, points).
     */
    tickNumber: import_prop_types.default.number,
    /**
     * The placement of ticks in regard to the band interval.
     * Only used if scale is 'band'.
     * @default 'extremities'
     */
    tickPlacement: import_prop_types.default.oneOf(["end", "extremities", "middle", "start"]),
    /**
     * The size of the ticks.
     * @default 6
     */
    tickSize: import_prop_types.default.number
  } : void 0;

  // node_modules/@mui/x-charts/ChartsTooltip/ChartsTooltip.js
  var React135 = __toESM(require_react());

  // node_modules/@mui/x-charts/ChartsTooltip/utils.js
  var React130 = __toESM(require_react());
  function generateVirtualElement(mousePosition) {
    if (mousePosition === null) {
      return {
        getBoundingClientRect: () => ({
          width: 0,
          height: 0,
          x: 0,
          y: 0,
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          toJSON: () => ""
        })
      };
    }
    const {
      x,
      y
    } = mousePosition;
    const boundingBox = {
      width: 0,
      height: 0,
      x,
      y,
      top: y,
      right: x,
      bottom: y,
      left: x
    };
    return {
      getBoundingClientRect: () => _extends({}, boundingBox, {
        toJSON: () => JSON.stringify(boundingBox)
      })
    };
  }
  function useMouseTracker() {
    const svgRef = useSvgRef();
    const [mousePosition, setMousePosition] = React130.useState(null);
    React130.useEffect(() => {
      const element = svgRef.current;
      if (element === null) {
        return () => {
        };
      }
      const handleOut = (event) => {
        if (event.pointerType !== "mouse") {
          setMousePosition(null);
        }
      };
      const handleMove = (event) => {
        setMousePosition({
          x: event.clientX,
          y: event.clientY,
          height: event.height,
          pointerType: event.pointerType
        });
      };
      element.addEventListener("pointerdown", handleMove);
      element.addEventListener("pointermove", handleMove);
      element.addEventListener("pointerup", handleOut);
      return () => {
        element.removeEventListener("pointerdown", handleMove);
        element.removeEventListener("pointermove", handleMove);
        element.removeEventListener("pointerup", handleOut);
      };
    }, [svgRef]);
    return mousePosition;
  }
  function getTooltipHasData(trigger, displayedData) {
    if (trigger === "item") {
      return displayedData !== null;
    }
    const hasAxisXData = displayedData.x !== null;
    const hasAxisYData = displayedData.y !== null;
    return hasAxisXData || hasAxisYData;
  }
  function utcFormatter(v) {
    if (v instanceof Date) {
      return v.toUTCString();
    }
    return v.toLocaleString();
  }

  // node_modules/@mui/x-charts/ChartsTooltip/ChartsItemTooltipContent.js
  var React132 = __toESM(require_react());

  // node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsItemTooltipContent.js
  var React131 = __toESM(require_react());

  // node_modules/@mui/x-charts/ChartsTooltip/chartsTooltipClasses.js
  function getChartsTooltipUtilityClass(slot) {
    return generateUtilityClass2("MuiChartsTooltip", slot);
  }
  var chartsTooltipClasses = generateUtilityClasses2("MuiChartsTooltip", ["root", "paper", "table", "row", "cell", "mark", "markCell", "labelCell", "valueCell"]);

  // node_modules/@mui/x-charts/ChartsTooltip/ChartsTooltipTable.js
  var ChartsTooltipPaper = styled_default2("div", {
    name: "MuiChartsTooltip",
    slot: "Container",
    overridesResolver: (props, styles2) => styles2.paper
  })(({
    theme
  }) => ({
    boxShadow: theme.shadows[1],
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    transition: theme.transitions.create("box-shadow"),
    borderRadius: theme.shape.borderRadius
  }));
  var ChartsTooltipTable = styled_default2("table", {
    name: "MuiChartsTooltip",
    slot: "Table",
    overridesResolver: (props, styles2) => styles2.table
  })(({
    theme
  }) => ({
    borderSpacing: 0,
    "& thead td": {
      borderBottom: `solid ${(theme.vars || theme).palette.divider} 1px`
    }
  }));
  var ChartsTooltipRow = styled_default2("tr", {
    name: "MuiChartsTooltip",
    slot: "Row",
    overridesResolver: (props, styles2) => styles2.row
  })(({
    theme
  }) => ({
    "tr:first-of-type& td": {
      paddingTop: theme.spacing(1)
    },
    "tr:last-of-type& td": {
      paddingBottom: theme.spacing(1)
    }
  }));
  var ChartsTooltipCell = styled_default2("td", {
    name: "MuiChartsTooltip",
    slot: "Cell",
    overridesResolver: (props, styles2) => styles2.cell
  })(({
    theme
  }) => ({
    verticalAlign: "middle",
    color: (theme.vars || theme).palette.text.secondary,
    [`&.${chartsTooltipClasses.labelCell}`]: {
      paddingLeft: theme.spacing(1)
    },
    [`&.${chartsTooltipClasses.valueCell}`]: {
      paddingLeft: theme.spacing(4),
      color: (theme.vars || theme).palette.text.primary
    },
    "td:first-of-type&": {
      paddingLeft: theme.spacing(2)
    },
    "td:last-of-type&": {
      paddingRight: theme.spacing(2)
    }
  }));
  var ChartsTooltipMark = styled_default2("div", {
    name: "MuiChartsTooltip",
    slot: "Mark",
    overridesResolver: (props, styles2) => styles2.mark,
    shouldForwardProp: (prop) => shouldForwardProp(prop) && prop !== "color"
  })(({
    theme,
    color: color3
  }) => ({
    width: theme.spacing(1),
    height: theme.spacing(1),
    borderRadius: "50%",
    boxShadow: theme.shadows[1],
    background: color3,
    borderColor: (theme.vars || theme).palette.background.paper,
    border: `solid ${(theme.vars || theme).palette.background.paper} ${theme.spacing(0.25)}`,
    boxSizing: "content-box"
  }));

  // node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsItemTooltipContent.js
  var import_jsx_runtime76 = __toESM(require_jsx_runtime());
  function DefaultChartsItemTooltipContent(props) {
    var _a;
    const {
      series,
      itemData,
      sx,
      classes,
      getColor: getColor5
    } = props;
    if (itemData.dataIndex === void 0 || !series.data[itemData.dataIndex]) {
      return null;
    }
    const {
      displayedLabel,
      color: color3
    } = series.type === "pie" ? {
      color: getColor5(itemData.dataIndex),
      displayedLabel: getLabel(series.data[itemData.dataIndex].label, "tooltip")
    } : {
      color: getColor5(itemData.dataIndex),
      displayedLabel: getLabel(series.label, "tooltip")
    };
    const value = series.type === "pie" ? _extends({}, series.data[itemData.dataIndex], {
      label: getLabel(series.data[itemData.dataIndex].label, "tooltip")
    }) : series.data[itemData.dataIndex];
    const formattedValue = (_a = series.valueFormatter) == null ? void 0 : _a.call(series, value, {
      dataIndex: itemData.dataIndex
    });
    return /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(ChartsTooltipPaper, {
      sx,
      className: classes.paper,
      children: /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(ChartsTooltipTable, {
        className: classes.table,
        children: /* @__PURE__ */ (0, import_jsx_runtime76.jsx)("tbody", {
          children: /* @__PURE__ */ (0, import_jsx_runtime76.jsxs)(ChartsTooltipRow, {
            className: classes.row,
            children: [/* @__PURE__ */ (0, import_jsx_runtime76.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.markCell, classes.cell),
              children: /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(ChartsTooltipMark, {
                color: color3,
                className: classes.mark
              })
            }), /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.labelCell, classes.cell),
              children: displayedLabel
            }), /* @__PURE__ */ (0, import_jsx_runtime76.jsx)(ChartsTooltipCell, {
              className: clsx_default(classes.valueCell, classes.cell),
              children: formattedValue
            })]
          })
        })
      })
    });
  }
  false ? DefaultChartsItemTooltipContent.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object.isRequired,
    /**
     * Get the color of the item with index `dataIndex`.
     * @param {number} dataIndex The data index of the item.
     * @returns {string} The color to display.
     */
    getColor: import_prop_types.default.func.isRequired,
    /**
     * The data used to identify the triggered item.
     */
    itemData: import_prop_types.default.shape({
      dataIndex: import_prop_types.default.number,
      seriesId: import_prop_types.default.oneOfType([import_prop_types.default.number, import_prop_types.default.string]).isRequired,
      type: import_prop_types.default.oneOf(["bar", "line", "pie", "scatter"]).isRequired
    }).isRequired,
    /**
     * The series linked to the triggered axis.
     */
    series: import_prop_types.default.object.isRequired,
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;

  // node_modules/@mui/x-charts/ChartsTooltip/ChartsItemTooltipContent.js
  var import_jsx_runtime77 = __toESM(require_jsx_runtime());
  function ChartsItemTooltipContent(props) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const {
      content,
      itemData,
      sx,
      classes,
      contentProps
    } = props;
    const series = useSeries()[itemData.type].series[itemData.seriesId];
    const {
      xAxis,
      yAxis,
      xAxisIds,
      yAxisIds
    } = useCartesianContext();
    const {
      zAxis,
      zAxisIds
    } = React132.useContext(ZAxisContext);
    const colorProcessors = useColorProcessor();
    const xAxisId = (_b = (_a = series.xAxisId) != null ? _a : series.xAxisKey) != null ? _b : xAxisIds[0];
    const yAxisId = (_d = (_c = series.yAxisId) != null ? _c : series.yAxisKey) != null ? _d : yAxisIds[0];
    const zAxisId = (_f = (_e = series.zAxisId) != null ? _e : series.zAxisKey) != null ? _f : zAxisIds[0];
    const getColor5 = (_h = (_g = colorProcessors[series.type]) == null ? void 0 : _g.call(colorProcessors, series, xAxisId && xAxis[xAxisId], yAxisId && yAxis[yAxisId], zAxisId && zAxis[zAxisId])) != null ? _h : () => "";
    const Content = content != null ? content : DefaultChartsItemTooltipContent;
    const chartTooltipContentProps = useSlotProps_default2({
      elementType: Content,
      externalSlotProps: contentProps,
      additionalProps: {
        itemData,
        series,
        sx,
        classes,
        getColor: getColor5
      },
      ownerState: {}
    });
    return /* @__PURE__ */ (0, import_jsx_runtime77.jsx)(Content, _extends({}, chartTooltipContentProps));
  }

  // node_modules/@mui/x-charts/ChartsTooltip/ChartsAxisTooltipContent.js
  var React134 = __toESM(require_react());

  // node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsAxisTooltipContent.js
  var React133 = __toESM(require_react());

  // node_modules/@mui/x-charts/internals/configInit.js
  var instance;
  var CartesianSeriesTypes = class {
    constructor() {
      this.types = /* @__PURE__ */ new Set();
      if (instance) {
        throw new Error("You can only create one instance!");
      }
      instance = this.types;
    }
    addType(value) {
      this.types.add(value);
    }
    getTypes() {
      return this.types;
    }
  };
  var cartesianSeriesTypes = new CartesianSeriesTypes();
  cartesianSeriesTypes.addType("bar");
  cartesianSeriesTypes.addType("line");
  cartesianSeriesTypes.addType("scatter");

  // node_modules/@mui/x-charts/internals/isCartesian.js
  function isCartesianSeriesType(seriesType) {
    return cartesianSeriesTypes.getTypes().has(seriesType);
  }
  function isCartesianSeries(series) {
    return isCartesianSeriesType(series.type);
  }

  // node_modules/@mui/x-charts/ChartsTooltip/DefaultChartsAxisTooltipContent.js
  var import_jsx_runtime78 = __toESM(require_jsx_runtime());
  function DefaultChartsAxisTooltipContent(props) {
    var _a;
    const {
      series,
      axis,
      dataIndex,
      axisValue,
      sx,
      classes
    } = props;
    if (dataIndex == null) {
      return null;
    }
    const axisFormatter = (_a = axis.valueFormatter) != null ? _a : (v) => axis.scaleType === "utc" ? utcFormatter(v) : v.toLocaleString();
    return /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ChartsTooltipPaper, {
      sx,
      className: classes.paper,
      children: /* @__PURE__ */ (0, import_jsx_runtime78.jsxs)(ChartsTooltipTable, {
        className: classes.table,
        children: [axisValue != null && !axis.hideTooltip && /* @__PURE__ */ (0, import_jsx_runtime78.jsx)("thead", {
          children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ChartsTooltipRow, {
            children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ChartsTooltipCell, {
              colSpan: 3,
              children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(Typography_default, {
                children: axisFormatter(axisValue, {
                  location: "tooltip"
                })
              })
            })
          })
        }), /* @__PURE__ */ (0, import_jsx_runtime78.jsx)("tbody", {
          children: series.filter(isCartesianSeries).map(({
            id,
            label,
            valueFormatter,
            data,
            getColor: getColor5
          }) => {
            var _a2;
            const formattedValue = valueFormatter((_a2 = data[dataIndex]) != null ? _a2 : null, {
              dataIndex
            });
            if (formattedValue == null) {
              return null;
            }
            const formattedLabel = getLabel(label, "tooltip");
            const color3 = getColor5(dataIndex);
            return /* @__PURE__ */ (0, import_jsx_runtime78.jsxs)(ChartsTooltipRow, {
              className: classes.row,
              children: [/* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ChartsTooltipCell, {
                className: clsx_default(classes.markCell, classes.cell),
                children: color3 && /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ChartsTooltipMark, {
                  color: color3,
                  className: classes.mark
                })
              }), /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ChartsTooltipCell, {
                className: clsx_default(classes.labelCell, classes.cell),
                children: formattedLabel ? /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(Typography_default, {
                  children: formattedLabel
                }) : null
              }), /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(ChartsTooltipCell, {
                className: clsx_default(classes.valueCell, classes.cell),
                children: /* @__PURE__ */ (0, import_jsx_runtime78.jsx)(Typography_default, {
                  children: formattedValue
                })
              })]
            }, id);
          })
        })]
      })
    });
  }
  false ? DefaultChartsAxisTooltipContent.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * The properties of the triggered axis.
     */
    axis: import_prop_types.default.object.isRequired,
    /**
     * Data identifying the triggered axis.
     */
    axisData: import_prop_types.default.shape({
      x: import_prop_types.default.shape({
        index: import_prop_types.default.number,
        value: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number, import_prop_types.default.string]).isRequired
      }),
      y: import_prop_types.default.shape({
        index: import_prop_types.default.number,
        value: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number, import_prop_types.default.string]).isRequired
      })
    }).isRequired,
    /**
     * The value associated to the current mouse position.
     */
    axisValue: import_prop_types.default.oneOfType([import_prop_types.default.instanceOf(Date), import_prop_types.default.number, import_prop_types.default.string]),
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object.isRequired,
    /**
     * The index of the data item triggered.
     */
    dataIndex: import_prop_types.default.number,
    /**
     * The series linked to the triggered axis.
     */
    series: import_prop_types.default.arrayOf(import_prop_types.default.object).isRequired,
    sx: import_prop_types.default.oneOfType([import_prop_types.default.arrayOf(import_prop_types.default.oneOfType([import_prop_types.default.func, import_prop_types.default.object, import_prop_types.default.bool])), import_prop_types.default.func, import_prop_types.default.object])
  } : void 0;

  // node_modules/@mui/x-charts/ChartsTooltip/ChartsAxisTooltipContent.js
  var import_jsx_runtime79 = __toESM(require_jsx_runtime());
  function ChartsAxisTooltipContent(props) {
    const {
      content,
      contentProps,
      axisData,
      sx,
      classes
    } = props;
    const isXaxis = axisData.x && axisData.x.index !== -1;
    const dataIndex = isXaxis ? axisData.x && axisData.x.index : axisData.y && axisData.y.index;
    const axisValue = isXaxis ? axisData.x && axisData.x.value : axisData.y && axisData.y.value;
    const {
      xAxisIds,
      xAxis,
      yAxisIds,
      yAxis
    } = useCartesianContext();
    const {
      zAxisIds,
      zAxis
    } = React134.useContext(ZAxisContext);
    const series = useSeries();
    const colorProcessors = useColorProcessor();
    const USED_AXIS_ID = isXaxis ? xAxisIds[0] : yAxisIds[0];
    const relevantSeries = React134.useMemo(() => {
      const rep = [];
      Object.keys(series).filter(isCartesianSeriesType).forEach((seriesType) => {
        series[seriesType].seriesOrder.forEach((seriesId) => {
          var _a, _b, _c, _d, _e, _f;
          const item = series[seriesType].series[seriesId];
          const providedXAxisId = (_a = item.xAxisId) != null ? _a : item.xAxisKey;
          const providedYAxisId = (_b = item.yAxisId) != null ? _b : item.yAxisKey;
          const axisKey = isXaxis ? providedXAxisId : providedYAxisId;
          if (axisKey === void 0 || axisKey === USED_AXIS_ID) {
            const seriesToAdd = series[seriesType].series[seriesId];
            const xAxisId = providedXAxisId != null ? providedXAxisId : xAxisIds[0];
            const yAxisId = providedYAxisId != null ? providedYAxisId : yAxisIds[0];
            const zAxisId = (_d = (_c = seriesToAdd.zAxisId) != null ? _c : seriesToAdd.zAxisKey) != null ? _d : zAxisIds[0];
            const getColor5 = (_f = (_e = colorProcessors[seriesType]) == null ? void 0 : _e.call(colorProcessors, seriesToAdd, xAxis[xAxisId], yAxis[yAxisId], zAxisId && zAxis[zAxisId])) != null ? _f : () => "";
            rep.push(_extends({}, seriesToAdd, {
              getColor: getColor5
            }));
          }
        });
      });
      return rep;
    }, [USED_AXIS_ID, colorProcessors, isXaxis, series, xAxis, xAxisIds, yAxis, yAxisIds, zAxis, zAxisIds]);
    const relevantAxis = React134.useMemo(() => {
      return isXaxis ? xAxis[USED_AXIS_ID] : yAxis[USED_AXIS_ID];
    }, [USED_AXIS_ID, isXaxis, xAxis, yAxis]);
    const Content = content != null ? content : DefaultChartsAxisTooltipContent;
    const chartTooltipContentProps = useSlotProps_default2({
      elementType: Content,
      externalSlotProps: contentProps,
      additionalProps: {
        axisData,
        series: relevantSeries,
        axis: relevantAxis,
        dataIndex,
        axisValue,
        sx,
        classes
      },
      ownerState: {}
    });
    return /* @__PURE__ */ (0, import_jsx_runtime79.jsx)(Content, _extends({}, chartTooltipContentProps));
  }

  // node_modules/@mui/x-charts/ChartsTooltip/ChartsTooltip.js
  var import_jsx_runtime80 = __toESM(require_jsx_runtime());
  var useUtilityClasses27 = (ownerState) => {
    const {
      classes
    } = ownerState;
    const slots = {
      root: ["root"],
      paper: ["paper"],
      table: ["table"],
      row: ["row"],
      cell: ["cell"],
      mark: ["mark"],
      markCell: ["markCell"],
      labelCell: ["labelCell"],
      valueCell: ["valueCell"]
    };
    return composeClasses2(slots, getChartsTooltipUtilityClass, classes);
  };
  var ChartsTooltipRoot = styled_default2(Popper_default, {
    name: "MuiChartsTooltip",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })(({
    theme
  }) => ({
    pointerEvents: "none",
    zIndex: theme.zIndex.modal
  }));
  function ChartsTooltip(inProps) {
    var _a, _b, _c;
    const props = useThemeProps2({
      props: inProps,
      name: "MuiChartsTooltip"
    });
    const {
      trigger = "axis",
      itemContent,
      axisContent,
      slots,
      slotProps
    } = props;
    const mousePosition = useMouseTracker();
    const {
      item,
      axis
    } = React135.useContext(InteractionContext);
    const displayedData = trigger === "item" ? item : axis;
    const tooltipHasData = getTooltipHasData(trigger, displayedData);
    const popperOpen = mousePosition !== null && tooltipHasData;
    const classes = useUtilityClasses27({
      classes: props.classes
    });
    const PopperComponent = (_a = slots == null ? void 0 : slots.popper) != null ? _a : ChartsTooltipRoot;
    const popperProps = useSlotProps_default2({
      elementType: PopperComponent,
      externalSlotProps: slotProps == null ? void 0 : slotProps.popper,
      additionalProps: {
        open: popperOpen,
        placement: (mousePosition == null ? void 0 : mousePosition.pointerType) === "mouse" ? "right-start" : "top",
        anchorEl: generateVirtualElement(mousePosition),
        modifiers: [{
          name: "offset",
          options: {
            offset: [0, (mousePosition == null ? void 0 : mousePosition.pointerType) === "touch" ? 40 - mousePosition.height : 0]
          }
        }]
      },
      ownerState: {}
    });
    if (trigger === "none") {
      return null;
    }
    return /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(NoSsr_default, {
      children: popperOpen && /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(PopperComponent, _extends({}, popperProps, {
        className: classes.root,
        children: trigger === "item" ? /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(ChartsItemTooltipContent, {
          itemData: displayedData,
          content: (_b = slots == null ? void 0 : slots.itemContent) != null ? _b : itemContent,
          contentProps: slotProps == null ? void 0 : slotProps.itemContent,
          sx: {
            mx: 2
          },
          classes
        }) : /* @__PURE__ */ (0, import_jsx_runtime80.jsx)(ChartsAxisTooltipContent, {
          axisData: displayedData,
          content: (_c = slots == null ? void 0 : slots.axisContent) != null ? _c : axisContent,
          contentProps: slotProps == null ? void 0 : slotProps.axisContent,
          sx: {
            mx: 2
          },
          classes
        })
      }))
    });
  }
  false ? ChartsTooltip.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Component to override the tooltip content when trigger is set to 'axis'.
     * @deprecated Use slots.axisContent instead
     */
    axisContent: import_prop_types.default.elementType,
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * Component to override the tooltip content when trigger is set to 'item'.
     * @deprecated Use slots.itemContent instead
     */
    itemContent: import_prop_types.default.elementType,
    /**
     * The props used for each component slot.
     * @default {}
     */
    slotProps: import_prop_types.default.object,
    /**
     * Overridable component slots.
     * @default {}
     */
    slots: import_prop_types.default.object,
    /**
     * Select the kind of tooltip to display
     * - 'item': Shows data about the item below the mouse.
     * - 'axis': Shows values associated with the hovered x value
     * - 'none': Does not display tooltip
     * @default 'axis'
     */
    trigger: import_prop_types.default.oneOf(["axis", "item", "none"])
  } : void 0;

  // node_modules/@mui/x-charts/ChartsAxisHighlight/ChartsAxisHighlight.js
  var React136 = __toESM(require_react());
  var import_jsx_runtime81 = __toESM(require_jsx_runtime());
  function getAxisHighlightUtilityClass(slot) {
    return generateUtilityClass2("MuiChartsAxisHighlight", slot);
  }
  var chartsAxisHighlightClasses = generateUtilityClasses2("MuiChartsAxisHighlight", ["root"]);
  var useUtilityClasses28 = () => {
    const slots = {
      root: ["root"]
    };
    return composeClasses2(slots, getAxisHighlightUtilityClass);
  };
  var ChartsAxisHighlightPath = styled_default2("path", {
    name: "MuiChartsAxisHighlight",
    slot: "Root",
    overridesResolver: (_2, styles2) => styles2.root
  })(({
    theme
  }) => ({
    pointerEvents: "none",
    variants: [{
      props: {
        axisHighlight: "band"
      },
      style: _extends({
        fill: "white",
        fillOpacity: 0.1
      }, theme.applyStyles("light", {
        fill: "gray"
      }))
    }, {
      props: {
        axisHighlight: "line"
      },
      style: _extends({
        strokeDasharray: "5 2",
        stroke: "#ffffff"
      }, theme.applyStyles("light", {
        stroke: "#000000"
      }))
    }]
  }));
  function ChartsAxisHighlight(props) {
    const {
      x: xAxisHighlight,
      y: yAxisHighlight
    } = props;
    const {
      xAxisIds,
      xAxis,
      yAxisIds,
      yAxis
    } = useCartesianContext();
    const classes = useUtilityClasses28();
    const USED_X_AXIS_ID = xAxisIds[0];
    const USED_Y_AXIS_ID = yAxisIds[0];
    const xScale = xAxis[USED_X_AXIS_ID].scale;
    const yScale = yAxis[USED_Y_AXIS_ID].scale;
    const {
      axis
    } = React136.useContext(InteractionContext);
    const getXPosition = getValueToPositionMapper(xScale);
    const getYPosition = getValueToPositionMapper(yScale);
    const axisX = axis.x;
    const axisY = axis.y;
    const isBandScaleX = xAxisHighlight === "band" && axisX !== null && isBandScale(xScale);
    const isBandScaleY = yAxisHighlight === "band" && axisY !== null && isBandScale(yScale);
    if (false) {
      const isXError = isBandScaleX && xScale(axisX.value) === void 0;
      const isYError = isBandScaleY && yScale(axisY.value) === void 0;
      if (isXError || isYError) {
        console.error([`MUI X: The position value provided for the axis is not valid for the current scale.`, `This probably means something is wrong with the data passed to the chart.`, `The ChartsAxisHighlight component will not be displayed.`].join("\n"));
      }
    }
    return /* @__PURE__ */ (0, import_jsx_runtime81.jsxs)(React136.Fragment, {
      children: [isBandScaleX && xScale(axisX.value) !== void 0 && /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(
        ChartsAxisHighlightPath,
        {
          d: `M ${xScale(axisX.value) - (xScale.step() - xScale.bandwidth()) / 2} ${yScale.range()[0]} l ${xScale.step()} 0 l 0 ${yScale.range()[1] - yScale.range()[0]} l ${-xScale.step()} 0 Z`,
          className: classes.root,
          ownerState: {
            axisHighlight: "band"
          }
        }
      ), isBandScaleY && yScale(axisY.value) !== void 0 && /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(ChartsAxisHighlightPath, {
        d: `M ${xScale.range()[0]} ${// @ts-expect-error, yScale value is checked in the statement above
        yScale(axisY.value) - (yScale.step() - yScale.bandwidth()) / 2} l 0 ${yScale.step()} l ${xScale.range()[1] - xScale.range()[0]} 0 l 0 ${-yScale.step()} Z`,
        className: classes.root,
        ownerState: {
          axisHighlight: "band"
        }
      }), xAxisHighlight === "line" && axis.x !== null && /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(ChartsAxisHighlightPath, {
        d: `M ${getXPosition(axis.x.value)} ${yScale.range()[0]} L ${getXPosition(axis.x.value)} ${yScale.range()[1]}`,
        className: classes.root,
        ownerState: {
          axisHighlight: "line"
        }
      }), yAxisHighlight === "line" && axis.y !== null && /* @__PURE__ */ (0, import_jsx_runtime81.jsx)(ChartsAxisHighlightPath, {
        d: `M ${xScale.range()[0]} ${getYPosition(axis.y.value)} L ${xScale.range()[1]} ${getYPosition(axis.y.value)}`,
        className: classes.root,
        ownerState: {
          axisHighlight: "line"
        }
      })]
    });
  }
  false ? ChartsAxisHighlight.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    x: import_prop_types.default.oneOf(["band", "line", "none"]),
    y: import_prop_types.default.oneOf(["band", "line", "none"])
  } : void 0;

  // node_modules/@mui/x-charts/ChartsGrid/ChartsGrid.js
  var React139 = __toESM(require_react());

  // node_modules/@mui/x-charts/ChartsGrid/chartsGridClasses.js
  function getChartsGridUtilityClass(slot) {
    return generateUtilityClass2("MuiChartsGrid", slot);
  }
  var chartsGridClasses = generateUtilityClasses2("MuiChartsGrid", ["root", "line", "horizontalLine", "verticalLine"]);

  // node_modules/@mui/x-charts/ChartsGrid/styledCommonents.js
  var GridRoot = styled_default2("g", {
    name: "MuiChartsGrid",
    slot: "Root",
    overridesResolver: (props, styles2) => [{
      [`&.${chartsGridClasses.verticalLine}`]: styles2.verticalLine
    }, {
      [`&.${chartsGridClasses.horizontalLine}`]: styles2.horizontalLine
    }, styles2.root]
  })({});
  var GridLine = styled_default2("line", {
    name: "MuiChartsGrid",
    slot: "Line",
    overridesResolver: (props, styles2) => styles2.line
  })(({
    theme
  }) => ({
    stroke: (theme.vars || theme).palette.divider,
    shapeRendering: "crispEdges",
    strokeWidth: 1
  }));

  // node_modules/@mui/x-charts/ChartsGrid/ChartsVerticalGrid.js
  var React137 = __toESM(require_react());
  var import_jsx_runtime82 = __toESM(require_jsx_runtime());
  function ChartsGridVertical(props) {
    const {
      axis,
      drawingArea,
      classes
    } = props;
    const {
      scale,
      tickNumber,
      tickInterval
    } = axis;
    const xTicks = useTicks({
      scale,
      tickNumber,
      tickInterval
    });
    return /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(React137.Fragment, {
      children: xTicks.map(({
        value,
        offset: offset2
      }) => /* @__PURE__ */ (0, import_jsx_runtime82.jsx)(GridLine, {
        y1: drawingArea.top,
        y2: drawingArea.top + drawingArea.height,
        x1: offset2,
        x2: offset2,
        className: classes.verticalLine
      }, `vertical-${value}`))
    });
  }

  // node_modules/@mui/x-charts/ChartsGrid/ChartsHorizontalGrid.js
  var React138 = __toESM(require_react());
  var import_jsx_runtime83 = __toESM(require_jsx_runtime());
  function ChartsGridHorizontal(props) {
    const {
      axis,
      drawingArea,
      classes
    } = props;
    const {
      scale,
      tickNumber,
      tickInterval
    } = axis;
    const yTicks = useTicks({
      scale,
      tickNumber,
      tickInterval
    });
    return /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(React138.Fragment, {
      children: yTicks.map(({
        value,
        offset: offset2
      }) => /* @__PURE__ */ (0, import_jsx_runtime83.jsx)(GridLine, {
        y1: offset2,
        y2: offset2,
        x1: drawingArea.left,
        x2: drawingArea.left + drawingArea.width,
        className: classes.horizontalLine
      }, `horizontal-${value}`))
    });
  }

  // node_modules/@mui/x-charts/ChartsGrid/ChartsGrid.js
  var import_jsx_runtime84 = __toESM(require_jsx_runtime());
  var _excluded14 = ["vertical", "horizontal"];
  var useUtilityClasses29 = ({
    classes
  }) => {
    const slots = {
      root: ["root"],
      verticalLine: ["line", "verticalLine"],
      horizontalLine: ["line", "horizontalLine"]
    };
    return composeClasses2(slots, getChartsGridUtilityClass, classes);
  };
  function ChartsGrid(inProps) {
    const props = useThemeProps2({
      props: inProps,
      name: "MuiChartsGrid"
    });
    const drawingArea = useDrawingArea();
    const {
      vertical,
      horizontal
    } = props, other = _objectWithoutPropertiesLoose(props, _excluded14);
    const {
      xAxis,
      xAxisIds,
      yAxis,
      yAxisIds
    } = useCartesianContext();
    const classes = useUtilityClasses29(props);
    const horizontalAxis = yAxis[yAxisIds[0]];
    const verticalAxis = xAxis[xAxisIds[0]];
    return /* @__PURE__ */ (0, import_jsx_runtime84.jsxs)(GridRoot, _extends({}, other, {
      className: classes.root,
      children: [vertical && /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(ChartsGridVertical, {
        axis: verticalAxis,
        drawingArea,
        classes
      }), horizontal && /* @__PURE__ */ (0, import_jsx_runtime84.jsx)(ChartsGridHorizontal, {
        axis: horizontalAxis,
        drawingArea,
        classes
      })]
    }));
  }
  false ? ChartsGrid.propTypes = {
    // ----------------------------- Warning --------------------------------
    // | These PropTypes are generated from the TypeScript type definitions |
    // | To update them edit the TypeScript types and run "pnpm proptypes"  |
    // ----------------------------------------------------------------------
    /**
     * Override or extend the styles applied to the component.
     */
    classes: import_prop_types.default.object,
    /**
     * Displays horizontal grid.
     */
    horizontal: import_prop_types.default.bool,
    /**
     * Displays vertical grid.
     */
    vertical: import_prop_types.default.bool
  } : void 0;

  // src/Components/Charts/BaseBarChart.tsx
  var import_react28 = __toESM(require_react());

  // src/Components/Charts/BaseBarChartLegend.tsx
  var import_jsx_runtime85 = __toESM(require_jsx_runtime());
  var BaseBarChartLegend = ({ yAxis }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(Stack_default, { spacing: 2, direction: "row", flexWrap: "wrap", justifyContent: "center", children: yAxis.map((axis, index) => /* @__PURE__ */ (0, import_jsx_runtime85.jsxs)(Box_default, { display: "flex", alignItems: "center", children: [
      /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(Box_default, { sx: { width: 12, height: 12, bgcolor: axis.color, borderRadius: "2px", mr: 1 } }),
      /* @__PURE__ */ (0, import_jsx_runtime85.jsx)(Typography_default, { variant: "body2", children: axis.label })
    ] }, index)) });
  };

  // src/Components/Charts/BaseBarChart.tsx
  var import_jsx_runtime86 = __toESM(require_jsx_runtime());
  var BaseBarChart = ({ xAxis, yAxis, dataset }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime86.jsxs)(import_react28.Fragment, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(Box_default, { sx: { height: 300 }, children: /* @__PURE__ */ (0, import_jsx_runtime86.jsxs)(
        ResponsiveChartContainer,
        {
          xAxis,
          margin: { top: 20, left: 35, right: 20, bottom: 35 },
          series: yAxis.map((axis) => __spreadProps(__spreadValues({}, axis), { type: "bar" })),
          dataset,
          children: [
            /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(BarPlot, {}),
            /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(ChartsGrid, { vertical: true, horizontal: true }),
            /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(ChartsXAxis, {}),
            /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(ChartsYAxis, {}),
            /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(ChartsTooltip, { slotProps: { popper: { sx: { zIndex: 2e3 } } } }),
            /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(ChartsAxisHighlight, { x: "band" })
          ]
        }
      ) }),
      /* @__PURE__ */ (0, import_jsx_runtime86.jsx)(BaseBarChartLegend, { yAxis })
    ] });
  };

  // src/Components/Charts/BaseChartView.tsx
  var import_jsx_runtime87 = __toESM(require_jsx_runtime());
  var BaseChartView = ({ title, children, childrenSx, containerSx }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime87.jsxs)(Paper_default, { sx: __spreadValues({ width: "100%", p: 2, mt: 3 }, containerSx), children: [
      /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(Box_default, { sx: { display: "flex", alignItems: "center" }, children: /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(Typography_default, { sx: { mr: 2 }, variant: "h6", children: title }) }),
      /* @__PURE__ */ (0, import_jsx_runtime87.jsx)(Box_default, { sx: __spreadValues({ height: "100%" }, childrenSx), children })
    ] });
  };

  // src/Services/Charts.ts
  var import_dayjs = __toESM(require_dayjs_min());

  // src/Services/Config.ts
  var SettingsManager = class {
    static setup() {
      this.config = this.getEnvConfig();
    }
    static getEnvConfig() {
      return {
        repositoryUrl: "https://raw.githubusercontent.com/Nikita-Filonov/ui-coverage-report",
        apiDateFormat: "YYYY-MM-DD",
        apiTimeFormat: "HH:mm"
      };
    }
    static get repositoryUrl() {
      return this.config.repositoryUrl;
    }
    static get apiDateFormat() {
      return this.config.apiDateFormat;
    }
    static get apiTimeFormat() {
      return this.config.apiTimeFormat;
    }
    static get apiDateTimeFormat() {
      return `${this.apiDateFormat} ${this.apiTimeFormat}`;
    }
    static getStaticFileUrl(file) {
      return `${this.repositoryUrl}/main/static/${file}`;
    }
  };
  SettingsManager.config = {
    repositoryUrl: "",
    apiDateFormat: "",
    apiTimeFormat: ""
  };
  SettingsManager.setup();

  // src/Services/Charts.ts
  var dateTimeValueFormatter = (value) => (0, import_dayjs.default)(value).format(SettingsManager.apiDateTimeFormat);

  // src/Models/Actions.ts
  var ActionType = /* @__PURE__ */ ((ActionType2) => {
    ActionType2["Fill"] = "FILL";
    ActionType2["Type"] = "TYPE";
    ActionType2["Select"] = "SELECT";
    ActionType2["Click"] = "CLICK";
    ActionType2["Hover"] = "HOVER";
    ActionType2["Text"] = "TEXT";
    ActionType2["Value"] = "VALUE";
    ActionType2["Hidden"] = "HIDDEN";
    ActionType2["Visible"] = "VISIBLE";
    ActionType2["Checked"] = "CHECKED";
    ActionType2["Enabled"] = "ENABLED";
    ActionType2["Disabled"] = "DISABLED";
    ActionType2["Unchecked"] = "UNCHECKED";
    return ActionType2;
  })(ActionType || {});

  // src/Services/Actions.ts
  var import_dayjs2 = __toESM(require_dayjs_min());
  var normalizeActionType = (action) => {
    return action.toLowerCase().split("_").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
  };
  var getActionsChartData = (props) => {
    const { actions, createdAt } = props;
    const base = {
      createdAt: (0, import_dayjs2.default)(createdAt).toDate()
    };
    for (const action of actions) {
      base[action.type] = action.count;
    }
    return base;
  };
  var MAP_ACTION_TYPE_TO_COLOR = {
    // input
    ["FILL" /* Fill */]: green_default["300"],
    ["TYPE" /* Type */]: green_default["400"],
    ["SELECT" /* Select */]: green_default["500"],
    // action
    ["CLICK" /* Click */]: blue_default["300"],
    ["HOVER" /* Hover */]: blue_default["400"],
    // assert
    ["TEXT" /* Text */]: purple_default["300"],
    ["VALUE" /* Value */]: purple_default["400"],
    ["HIDDEN" /* Hidden */]: purple_default["500"],
    ["VISIBLE" /* Visible */]: purple_default["600"],
    ["CHECKED" /* Checked */]: orange_default["300"],
    ["ENABLED" /* Enabled */]: orange_default["400"],
    ["DISABLED" /* Disabled */]: orange_default["500"],
    ["UNCHECKED" /* Unchecked */]: orange_default["600"]
  };
  var ACTION_TYPES_BY_GROUP = {
    input: ["FILL" /* Fill */, "TYPE" /* Type */, "SELECT" /* Select */],
    action: ["CLICK" /* Click */, "HOVER" /* Hover */],
    assert: [
      "TEXT" /* Text */,
      "VALUE" /* Value */,
      "HIDDEN" /* Hidden */,
      "VISIBLE" /* Visible */,
      "CHECKED" /* Checked */,
      "ENABLED" /* Enabled */,
      "DISABLED" /* Disabled */,
      "UNCHECKED" /* Unchecked */
    ]
  };

  // src/Components/Charts/Agent/Elements/ElementHistoryChartView.tsx
  var import_jsx_runtime88 = __toESM(require_jsx_runtime());
  var ElementHistoryChartView = ({ history: history2 }) => {
    const chartData = (0, import_react29.useMemo)(() => history2.map(getActionsChartData), [history2]);
    return /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(BaseChartView, { title: "Element history", children: /* @__PURE__ */ (0, import_jsx_runtime88.jsx)(
      BaseBarChart,
      {
        xAxis: [{ dataKey: "createdAt", scaleType: "band", valueFormatter: dateTimeValueFormatter }],
        yAxis: Object.values(ActionType).map((type) => ({
          dataKey: type,
          label: normalizeActionType(type),
          color: MAP_ACTION_TYPE_TO_COLOR[type],
          stack: "total"
        })),
        dataset: chartData
      }
    ) });
  };

  // src/Services/Tables/Sorting.ts
  var import_lodash = __toESM(require_lodash());
  var import_react30 = __toESM(require_react());
  function descendingComparator(a, b, orderBy) {
    if (orderBy === null) {
      return 0;
    }
    const aValue = import_lodash.default.get(a, orderBy) || 0;
    const bValue = import_lodash.default.get(b, orderBy) || 0;
    if (bValue < aValue) {
      return -1;
    }
    if (bValue > aValue) {
      return 1;
    }
    return 0;
  }
  var getComparator = (order2, orderBy) => {
    return order2 === "desc" ? (a, b) => descendingComparator(a, b, orderBy) : (a, b) => -descendingComparator(a, b, orderBy);
  };
  var useTableSorting = ({ items }) => {
    const [orderBy, setOrderBy] = (0, import_react30.useState)(null);
    const [orderDirection, setOrderDirection] = (0, import_react30.useState)("asc");
    const sortedItems = (0, import_react30.useMemo)(
      () => [...items].sort(getComparator(orderDirection, orderBy)),
      [orderBy, orderDirection, items]
    );
    return { sortedItems, orderBy, orderDirection, setOrderBy, setOrderDirection };
  };

  // src/Components/Tables/BaseTableCell.tsx
  var import_jsx_runtime89 = __toESM(require_jsx_runtime());
  var BaseTableCell = ({ text, icon }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime89.jsxs)(Box_default, { sx: { display: "flex", alignItems: "center" }, children: [
      icon,
      /* @__PURE__ */ (0, import_jsx_runtime89.jsx)(Typography_default, { variant: "body2", children: text })
    ] });
  };

  // node_modules/@mui/icons-material/esm/MouseOutlined.js
  var import_jsx_runtime90 = __toESM(require_jsx_runtime());
  var MouseOutlined_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime90.jsx)("path", {
    d: "M20 9c-.04-4.39-3.6-7.93-8-7.93S4.04 4.61 4 9v6c0 4.42 3.58 8 8 8s8-3.58 8-8zm-2 0h-5V3.16c2.81.47 4.96 2.9 5 5.84m-7-5.84V9H6c.04-2.94 2.19-5.37 5-5.84M18 15c0 3.31-2.69 6-6 6s-6-2.69-6-6v-4h12z"
  }), "MouseOutlined");

  // node_modules/@mui/icons-material/esm/EditOutlined.js
  var import_jsx_runtime91 = __toESM(require_jsx_runtime());
  var EditOutlined_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime91.jsx)("path", {
    d: "m14.06 9.02.92.92L5.92 19H5v-.92zM17.66 3c-.25 0-.51.1-.7.29l-1.83 1.83 3.75 3.75 1.83-1.83c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.2-.2-.45-.29-.71-.29m-3.6 3.19L3 17.25V21h3.75L17.81 9.94z"
  }), "EditOutlined");

  // node_modules/@mui/icons-material/esm/ToggleOn.js
  var import_jsx_runtime92 = __toESM(require_jsx_runtime());
  var ToggleOn_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime92.jsx)("path", {
    d: "M17 7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h10c2.76 0 5-2.24 5-5s-2.24-5-5-5m0 8c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3"
  }), "ToggleOn");

  // node_modules/@mui/icons-material/esm/DoNotTouchOutlined.js
  var import_jsx_runtime93 = __toESM(require_jsx_runtime());
  var DoNotTouchOutlined_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime93.jsx)("path", {
    d: "M2.81 2.81 1.39 4.22 7 9.83v4.3l-2.6-1.48c-.17-.09-.34-.14-.54-.14-.26 0-.5.09-.7.26L2 13.88l6.8 7.18c.57.6 1.35.94 2.18.94H17c.62 0 1.18-.19 1.66-.52l1.12 1.12 1.41-1.41zM17 20h-6c-.39 0-.64-.23-.75-.36L6.87 16H9v-4.17l8.14 8.14c-.05.01-.09.03-.14.03m-3.17-9H14V3.25c0-.69.56-1.25 1.25-1.25s1.25.56 1.25 1.25V11h1V5.25c0-.69.56-1.25 1.25-1.25S20 4.56 20 5.25v11.92l-2-2V13h-2.17zm-.83-.83V2.25C13 1.56 12.44 1 11.75 1s-1.25.56-1.25 1.25v5.42zm-3.5-3.5V4.25C9.5 3.56 8.94 3 8.25 3c-.67 0-1.2.53-1.24 1.18z"
  }), "DoNotTouchOutlined");

  // node_modules/@mui/icons-material/esm/CheckBoxOutlined.js
  var import_jsx_runtime94 = __toESM(require_jsx_runtime());
  var CheckBoxOutlined_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime94.jsx)("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2m0 16H5V5h14zM17.99 9l-1.41-1.42-6.59 6.59-2.58-2.57-1.42 1.41 4 3.99z"
  }), "CheckBoxOutlined");

  // node_modules/@mui/icons-material/esm/CheckBoxOutlineBlank.js
  var import_jsx_runtime95 = __toESM(require_jsx_runtime());
  var CheckBoxOutlineBlank_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime95.jsx)("path", {
    d: "M19 5v14H5V5zm0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2"
  }), "CheckBoxOutlineBlank");

  // node_modules/@mui/icons-material/esm/VisibilityOutlined.js
  var import_jsx_runtime96 = __toESM(require_jsx_runtime());
  var VisibilityOutlined_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime96.jsx)("path", {
    d: "M12 6c3.79 0 7.17 2.13 8.82 5.5C19.17 14.87 15.79 17 12 17s-7.17-2.13-8.82-5.5C4.83 8.13 8.21 6 12 6m0-2C7 4 2.73 7.11 1 11.5 2.73 15.89 7 19 12 19s9.27-3.11 11-7.5C21.27 7.11 17 4 12 4m0 5c1.38 0 2.5 1.12 2.5 2.5S13.38 14 12 14s-2.5-1.12-2.5-2.5S10.62 9 12 9m0-2c-2.48 0-4.5 2.02-4.5 4.5S9.52 16 12 16s4.5-2.02 4.5-4.5S14.48 7 12 7"
  }), "VisibilityOutlined");

  // node_modules/@mui/icons-material/esm/VisibilityOffOutlined.js
  var import_jsx_runtime97 = __toESM(require_jsx_runtime());
  var VisibilityOffOutlined_default = createSvgIcon(/* @__PURE__ */ (0, import_jsx_runtime97.jsx)("path", {
    d: "M12 6c3.79 0 7.17 2.13 8.82 5.5-.59 1.22-1.42 2.27-2.41 3.12l1.41 1.41c1.39-1.23 2.49-2.77 3.18-4.53C21.27 7.11 17 4 12 4c-1.27 0-2.49.2-3.64.57l1.65 1.65C10.66 6.09 11.32 6 12 6m-1.07 1.14L13 9.21c.57.25 1.03.71 1.28 1.28l2.07 2.07c.08-.34.14-.7.14-1.07C16.5 9.01 14.48 7 12 7c-.37 0-.72.05-1.07.14M2.01 3.87l2.68 2.68C3.06 7.83 1.77 9.53 1 11.5 2.73 15.89 7 19 12 19c1.52 0 2.98-.29 4.32-.82l3.42 3.42 1.41-1.41L3.42 2.45zm7.5 7.5 2.61 2.61c-.04.01-.08.02-.12.02-1.38 0-2.5-1.12-2.5-2.5 0-.05.01-.08.01-.13m-3.4-3.4 1.75 1.75c-.23.55-.36 1.15-.36 1.78 0 2.48 2.02 4.5 4.5 4.5.63 0 1.23-.13 1.77-.36l.98.98c-.88.24-1.8.38-2.75.38-3.79 0-7.17-2.13-8.82-5.5.7-1.43 1.72-2.61 2.93-3.53"
  }), "VisibilityOffOutlined");

  // src/Components/Tables/Agent/Elements/ActionCell.tsx
  var import_jsx_runtime98 = __toESM(require_jsx_runtime());
  var MAP_ACTION_TYPE_TO_ICON = {
    // input
    ["FILL" /* Fill */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(EditOutlined_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    ["TYPE" /* Type */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(EditOutlined_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    ["SELECT" /* Select */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(EditOutlined_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    // action
    ["CLICK" /* Click */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(MouseOutlined_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    ["HOVER" /* Hover */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(MouseOutlined_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    // assert
    ["TEXT" /* Text */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(VisibilityOutlined_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    ["VALUE" /* Value */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(VisibilityOutlined_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    ["HIDDEN" /* Hidden */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(VisibilityOffOutlined_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    ["VISIBLE" /* Visible */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(VisibilityOutlined_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    ["CHECKED" /* Checked */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(CheckBoxOutlined_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    ["ENABLED" /* Enabled */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(ToggleOn_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    ["DISABLED" /* Disabled */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(DoNotTouchOutlined_default, { sx: { mr: 1.5 }, fontSize: "small" }),
    ["UNCHECKED" /* Unchecked */]: /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(CheckBoxOutlineBlank_default, { sx: { mr: 1.5 }, fontSize: "small" })
  };
  var ActionCell = ({ type }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime98.jsx)(BaseTableCell, { text: normalizeActionType(type), icon: MAP_ACTION_TYPE_TO_ICON[type] });
  };

  // src/Components/Tables/BaseTableRow.tsx
  var import_jsx_runtime99 = __toESM(require_jsx_runtime());
  var BaseTableRow = ({ cells }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime99.jsx)(TableRow_default, { hover: true, sx: { "&:last-child td, &:last-child th": { border: 0 } }, children: cells.map((cell, index) => /* @__PURE__ */ (0, import_jsx_runtime99.jsx)(TableCell_default, { align: cell.align || "left", children: cell.value }, index)) });
  };

  // src/Components/Tables/Agent/Elements/ActionCoverageTableRow.tsx
  var import_jsx_runtime100 = __toESM(require_jsx_runtime());
  var ActionCoverageTableRow = ({ action }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(BaseTableRow, { cells: [{ value: /* @__PURE__ */ (0, import_jsx_runtime100.jsx)(ActionCell, { type: action.type }) }, { value: action.count }] });
  };

  // src/Components/Tables/BaseTableHeader.tsx
  var import_jsx_runtime101 = __toESM(require_jsx_runtime());
  var BaseTableHeader = (props) => {
    const { cells, orderBy, setOrderBy, orderDirection, setOrderDirection } = props;
    const onOrder = (key) => () => {
      setOrderBy(key);
      setOrderDirection(orderDirection === "asc" ? "desc" : "asc");
    };
    return /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(TableHead_default, { children: /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(TableRow_default, { children: cells.map((cell, index) => /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(TableCell_default, { align: cell.align || "left", sx: { whiteSpace: "nowrap", pt: 2, pb: 2 }, children: cell.orderKey ? /* @__PURE__ */ (0, import_jsx_runtime101.jsx)(
      TableSortLabel_default,
      {
        active: orderBy === cell.orderKey,
        direction: orderDirection,
        onClick: onOrder(cell.orderKey),
        children: cell.value
      }
    ) : cell.value }, index)) }) });
  };

  // src/Components/Tables/Agent/Elements/ActionCoverageTableHeader.tsx
  var import_jsx_runtime102 = __toESM(require_jsx_runtime());
  var ActionCoverageTableHeader = (props) => {
    const { orderBy, setOrderBy, orderDirection, setOrderDirection } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime102.jsx)(
      BaseTableHeader,
      {
        cells: [
          { value: "Action", orderKey: "type" },
          { value: "Count", orderKey: "count" }
        ],
        orderBy,
        setOrderBy,
        orderDirection,
        setOrderDirection
      }
    );
  };

  // src/Components/Tables/BaseTable.tsx
  var import_jsx_runtime103 = __toESM(require_jsx_runtime());
  var BaseTable = (props) => {
    const { header, children, containerSx } = props;
    return /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(TableContainer_default, { component: Paper_default, sx: __spreadProps(__spreadValues({}, containerSx), { width: "100%" }), children: /* @__PURE__ */ (0, import_jsx_runtime103.jsxs)(Table_default, { size: "small", children: [
      header,
      /* @__PURE__ */ (0, import_jsx_runtime103.jsx)(TableBody_default, { children })
    ] }) });
  };

  // src/Components/Tables/Agent/Elements/ActionCoverageTable.tsx
  var import_jsx_runtime104 = __toESM(require_jsx_runtime());
  var ActionCoverageTable = ({ actions }) => {
    const { sortedItems, orderBy, setOrderBy, orderDirection, setOrderDirection } = useTableSorting({ items: actions });
    return /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(
      BaseTable,
      {
        containerSx: { mt: 3 },
        header: /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(
          ActionCoverageTableHeader,
          {
            orderBy,
            setOrderBy,
            orderDirection,
            setOrderDirection
          }
        ),
        children: sortedItems.map((action, index) => /* @__PURE__ */ (0, import_jsx_runtime104.jsx)(ActionCoverageTableRow, { action }, index))
      }
    );
  };

  // src/Views/Agent/Elements/ElementDetailsView.tsx
  var import_jsx_runtime105 = __toESM(require_jsx_runtime());
  var ElementDetailsView = ({ element }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)(Box_default, { children: [
      /* @__PURE__ */ (0, import_jsx_runtime105.jsxs)(WidgetInfoRowsView, { containerSx: { mt: 0 }, children: [
        /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(BaseInfoRowView, { name: "Selector", value: element.selector }),
        /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(BaseInfoRowView, { name: "Selector type", value: element.selectorType })
      ] }),
      /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ActionCoverageTable, { actions: element.actions }),
      /* @__PURE__ */ (0, import_jsx_runtime105.jsx)(ElementHistoryChartView, { history: element.history })
    ] });
  };

  // src/Components/Modals/Agent/Elements/ElementDetailsModal.tsx
  var import_jsx_runtime106 = __toESM(require_jsx_runtime());
  var ElementDetailsModal = ({ sx, modal, setModal, element }) => {
    return /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(BaseModal, { sx, title: "Element details", modal, setModal, maxWidth: "md", children: /* @__PURE__ */ (0, import_jsx_runtime106.jsx)(ElementDetailsView, { element }) });
  };

  // src/Components/Badges/Agent/Elements/ElementBadge.tsx
  var import_react31 = __toESM(require_react());
  var import_jsx_runtime107 = __toESM(require_jsx_runtime());
  var ElementBadge = ({ actions, settings }) => {
    const content = (0, import_react31.useMemo)(() => {
      switch (settings == null ? void 0 : settings.badgeContentType) {
        case "TOTAL_NUMBER_OF_ACTIONS" /* TotalNumberOfActions */:
          return actions.reduce((total, action) => total + action.count, 0);
        case "TOTAL_NUMBER_OF_ACTION_TYPES" /* TotalNumberOfActionTypes */:
          return actions.length;
        default:
          return 0;
      }
    }, [actions, settings == null ? void 0 : settings.badgeContentType]);
    return /* @__PURE__ */ (0, import_jsx_runtime107.jsx)(Badge_default, { color: settings == null ? void 0 : settings.badgeColor, badgeContent: content });
  };

  // src/Views/Agent/Elements/ElementView.tsx
  var import_jsx_runtime108 = __toESM(require_jsx_runtime());
  var ElementView = ({ element }) => {
    const { state } = useAgentInitialState();
    const { node: node2 } = useElement({ type: element.selectorType, value: element.selector, settings: state.settings });
    const [elementDetailsModal, setElementDetailsModal] = (0, import_react32.useState)(false);
    if (!node2) return null;
    const onElementDetails = () => setElementDetailsModal(true);
    return /* @__PURE__ */ (0, import_jsx_runtime108.jsxs)(BasePopper, { anchor: node2, children: [
      /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(IconButton_default, { onClick: onElementDetails, children: /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(ElementBadge, { actions: element.actions, settings: state.settings }) }),
      /* @__PURE__ */ (0, import_jsx_runtime108.jsx)(
        ElementDetailsModal,
        {
          sx: { zIndex: 1900 },
          modal: elementDetailsModal,
          setModal: setElementDetailsModal,
          element
        }
      )
    ] });
  };

  // src/Views/Agent/Elements/ElementsView.tsx
  var import_jsx_runtime109 = __toESM(require_jsx_runtime());
  var ElementsView = () => {
    var _a;
    const { state } = useAgentInitialState();
    return /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(import_react33.Fragment, { children: (_a = state == null ? void 0 : state.elements) == null ? void 0 : _a.map((element, index) => /* @__PURE__ */ (0, import_jsx_runtime109.jsx)(ElementView, { element }, index)) });
  };

  // src/Providers/AgentThemeProvider.tsx
  var import_react35 = __toESM(require_react());

  // src/Providers/ThemeProvider.tsx
  var import_react34 = __toESM(require_react());
  var import_jsx_runtime110 = __toESM(require_jsx_runtime());
  var darkTheme = createTheme2({
    palette: { mode: "dark" /* Dark */ },
    components: { MuiPaper: { defaultProps: { elevation: 5 } } }
  });
  var lightTheme = createTheme2({
    palette: { mode: "light" /* Light */ },
    components: { MuiPaper: { defaultProps: { elevation: 2 } } }
  });
  var ThemeContext3 = (0, import_react34.createContext)(null);

  // src/Providers/AgentThemeProvider.tsx
  var import_jsx_runtime111 = __toESM(require_jsx_runtime());
  var AgentThemeContext = (0, import_react35.createContext)(null);
  var AgentThemeProvider = ({ children }) => {
    const { state } = useAgentInitialState();
    return /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(AgentThemeContext.Provider, { value: null, children: /* @__PURE__ */ (0, import_jsx_runtime111.jsx)(ThemeProvider4, { theme: state.themeMode === "light" /* Light */ ? lightTheme : darkTheme, children }) });
  };

  // src/agent.index.tsx
  var import_jsx_runtime112 = __toESM(require_jsx_runtime());
  var IndexAgent = () => {
    return /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(AgentInitialStateProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(AgentThemeProvider, { children: /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(ElementsView, {}) }) });
  };
  document.addEventListener("DOMContentLoaded", () => {
    watchFrameRoot(() => /* @__PURE__ */ (0, import_jsx_runtime112.jsx)(IndexAgent, {}));
  });
})();
/*! Bundled license information:

scheduler/cjs/scheduler.production.js:
  (**
   * @license React
   * scheduler.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom.production.js:
  (**
   * @license React
   * react-dom.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-dom/cjs/react-dom-client.production.js:
  (**
   * @license React
   * react-dom-client.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react/cjs/react-jsx-runtime.production.js:
  (**
   * @license React
   * react-jsx-runtime.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.production.min.js:
  (** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.production.js:
  (**
   * @license React
   * react-is.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)

@mui/styled-engine/index.js:
  (**
   * @mui/styled-engine v6.4.11
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@mui/private-theming/index.js:
  (**
   * @mui/private-theming v6.4.9
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@mui/material/index.js:
  (**
   * @mui/material v6.4.11
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@mui/utils/esm/index.js:
  (**
   * @mui/utils v7.0.2
   *
   * @license MIT
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
